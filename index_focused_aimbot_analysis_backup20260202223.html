<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSA â€” Combat Simulation Analysis</title>
    <link rel="icon" type="image/png" href="crumb_logo.png" onerror="this.href='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ</text></svg>'">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0f1419;
            color: #fff;
            overflow: hidden;
        }

        #top-nav {
            height: 50px;
            background: #1a1f2e;
            border-bottom: 1px solid #2a2f3e;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 30px;
            position: relative;
            z-index: 1000;
            width: 100%;
        }

        #brand-logo {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-right: 30px;
            padding-right: 30px;
            border-right: 1px solid #2a2f3e;
        }

        #brand-logo img {
            height: 32px;
            width: auto;
            object-fit: contain;
        }

        #brand-text {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        #brand-name {
            font-size: 13px;
            font-weight: 600;
            color: #fff;
            letter-spacing: 0.5px;
        }

        #brand-tagline {
            font-size: 10px;
            color: #8a8fa5;
            font-style: italic;
        }

        .nav-item {
            padding: 8px 16px;
            cursor: pointer;
            color: #8a8fa5;
            font-size: 14px;
            transition: color 0.2s;
        }

        .nav-item:hover {
            color: #fff;
        }

        .nav-item.active {
            color: #4a90e2;
            border-bottom: 2px solid #4a90e2;
        }

        #container {
            display: flex;
            height: calc(100vh - 50px);
            visibility: visible;
        }

        #sidebar {
            width: 350px;
            background: #1a1f2e;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #2a2f3e;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            background: #0a0e15;
            display: block;
        }
        
        #minimap {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 250px;
            height: 250px;
            background: rgba(26, 31, 46, 0.9);
            border: 2px solid #4a90e2;
            border-radius: 4px;
            z-index: 1000;
            cursor: pointer;
        }
        
        #minimap-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        #fit-to-view {
            margin-left: 8px;
            visibility: visible;
        }


        #dashboard-view {
            flex: 1;
            padding: 20px 40px 40px 40px;
            overflow-y: auto;
            overflow-x: hidden;
            background: #0f1419;
            display: block;
            height: calc(100vh - 50px);
        }

        #dashboard-view.hidden {
            display: none;
        }

        #dashboard-content {
            max-width: 1000px;
            margin: 0 auto;
            color: #fff;
            padding-right: 20px;
        }

        #dashboard-content h1 {
            font-size: 32px;
            margin-bottom: 20px;
            color: #fff;
        }

        #dashboard-content h2 {
            font-size: 24px;
            margin-top: 30px;
            margin-bottom: 15px;
            color: #4a90e2;
            border-bottom: 2px solid #2a2f3e;
            padding-bottom: 10px;
        }

        #dashboard-content h3 {
            font-size: 18px;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #8a8fa5;
        }

        #dashboard-content h4 {
            font-size: 16px;
            margin-top: 15px;
            margin-bottom: 8px;
            color: #6a6f85;
            font-weight: 600;
        }

        #dashboard-content p {
            line-height: 1.6;
            color: #c0c5d0;
            margin-bottom: 10px;
        }

        #dashboard-content strong {
            color: #fff;
            font-weight: 600;
        }

        #dashboard-content ul, #dashboard-content ol {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        #dashboard-content li {
            line-height: 1.6;
            color: #c0c5d0;
            margin-bottom: 2px;
        }

        #dashboard-content code {
            background: #1a1f2e;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #4a90e2;
        }

        #dashboard-content pre {
            background: #1a1f2e;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
        }

        #dashboard-content pre code {
            background: none;
            padding: 0;
            color: #c0c5d0;
        }

        #dashboard-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }

        #dashboard-content table th,
        #dashboard-content table td {
            border: 1px solid #2a2f3e;
            padding: 10px;
            text-align: left;
        }

        #dashboard-content table th {
            background: #1a1f2e;
            color: #4a90e2;
        }

        #canvas {
            width: 100%;
            height: 100%;
        }

        /* GitHub CSV ì„ íƒ íŒì—… */
        #csv-popup {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        #csv-popup.active {
            display: flex;
        }

        #csv-popup-content {
            background: #1a1f2e;
            border: 1px solid #2a2f3e;
            border-radius: 8px;
            padding: 20px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        #csv-popup-content h3 {
            margin-top: 0;
            color: #fff;
            margin-bottom: 15px;
        }

        #csv-file-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #csv-file-list li {
            padding: 12px;
            margin-bottom: 8px;
            background: #2a2f3e;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            color: #fff;
        }

        #csv-file-list li:hover {
            background: #3a3f4e;
        }

        #csv-popup-close {
            margin-top: 15px;
            padding: 10px 20px;
            background: #4a90e2;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        #csv-popup-close:hover {
            background: #5aa0f2;
        }

        #bottom-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 300px;
            background: rgba(26, 31, 46, 0.98);
            border-top: 1px solid #2a2f3e;
            display: flex;
            flex-direction: column;
        }

        /* drag handle to resize bottom panel */
        #resize-handle {
            height: 6px;
            cursor: ns-resize;
            background: linear-gradient(180deg, #2a2f3e, #1a1f2e);
        }
        #resize-handle:hover {
            background: linear-gradient(180deg, #3a3f4e, #1f2738);
        }

        #controls {
            padding: 15px 20px;
            border-bottom: 1px solid #2a2f3e;
        }

        #event-tabs {
            display: flex;
            gap: 10px;
            padding: 10px 20px;
            border-bottom: 1px solid #2a2f3e;
            background: #1a1f2e;
        }

        .tab-btn {
            padding: 8px 16px;
            background: transparent;
            border: none;
            color: #8a8fa5;
            cursor: pointer;
            font-size: 13px;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab-btn:hover {
            color: #fff;
        }

        .tab-btn.active {
            color: #4a90e2;
            border-bottom-color: #4a90e2;
        }

        #event-log {
            flex: 1;
            overflow: auto;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            min-height: 0; /* flex itemì´ ìŠ¤í¬ë¡¤ ê°€ëŠ¥í•˜ë„ë¡ */
        }
        
        /* Action Stream íƒ­ì¼ ë•Œ ì„¸ë¡œ ë ˆì´ì•„ì›ƒ */
        #event-log.action-stream {
            overflow: auto;
            display: block;
            white-space: normal;
        }
        
        /* Aim Trace íƒ­ì¼ ë•Œ ì„¸ë¡œ ë ˆì´ì•„ì›ƒ */
        #event-log.aim-trace {
            overflow: auto;
            display: block;
            white-space: normal;
        }

        .event-item {
            padding: 6px 8px;
            background: #2a2f3e;
            border-radius: 3px;
            color: #8a8fa5;
            border-left: 3px solid transparent;
            cursor: pointer;
            transition: background 0.2s;
            white-space: normal;
            display: block;
            margin-bottom: 2px;
        }

        .event-item:hover {
            background: #3a3f4e;
        }

        .event-item.selected {
            background: #4a4f5e;
            border-left-color: #4a90e2;
        }

        .event-item.kill {
            border-left-color: #ff6b6b;
        }

        .event-item.attack {
            border-left-color: #ffa500;
        }

        .event-item.hit {
            border-left-color: #4a90e2;
        }

        .event-time {
            color: #6b9bd5;
            font-weight: 600;
        }

        .event-player {
            color: #4a90e2;
            font-weight: 500;
        }

        .event-victim {
            color: #ff6b6b;
            font-weight: 500;
        }

        .event-action {
            color: #8a8fa5;
        }

        .event-weapon {
            color: #ffa500;
            font-style: italic;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .play-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #4a90e2;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .play-btn:hover {
            background: #5aa0f2;
        }

        .timeline {
            flex: 1;
            height: 6px;
            background: #2a2f3e;
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }

        .timeline-progress {
            height: 100%;
            background: #4a90e2;
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s;
        }

        .time-display {
            min-width: 100px;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .speed-btn {
            padding: 5px 10px;
            background: #2a2f3e;
            border: 1px solid #3a3f4e;
            color: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
        }

        .speed-btn.active {
            background: #4a90e2;
            border-color: #4a90e2;
        }

        .sidebar-section {
            margin-bottom: 25px;
        }

        .sidebar-section h3 {
            font-size: 12px;
            color: #8a8fa5;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #2a2f3e;
            font-size: 12px;
        }

        .stat-label {
            color: #8a8fa5;
        }

        .stat-value {
            color: #fff;
            font-weight: 500;
        }

        .stat-group {
            margin-bottom: 15px;
        }

        .stat-group-title {
            font-size: 11px;
            color: #6a6f85;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #file-input {
            margin-bottom: 20px;
            padding: 12px;
            background: #2a2f3e;
            border-radius: 6px;
            border: 1px solid #3a3f4e;
        }

        #file-input input[type="file"] {
            color: white;
            font-size: 12px;
        }

        #loading {
            text-align: center;
            padding: 20px;
            color: #8a8fa5;
            font-size: 14px;
        }

        .player-item {
            padding: 8px;
            margin-bottom: 5px;
            background: #2a2f3e;
            border-radius: 4px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-item.ct {
            border-left: 3px solid #5b9bd5;
        }

        .player-item.terrorist {
            border-left: 3px solid #ff6b6b;
        }

        .player-kd {
            font-size: 11px;
            color: #8a8fa5;
        }

        #map-info {
            background: #2a2f3e;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
        }

        #map-info-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        #map-bounds {
            font-size: 11px;
            color: #8a8fa5;
            font-family: 'Courier New', monospace;
        }

        #focus-controls {
            position: absolute;
            top: 80px; /* event-picker ì•„ë˜ì— ë°°ì¹˜ (event-picker ë†’ì´ + ì—¬ë°±) */
            left: 20px;
            background: rgba(26, 31, 46, 0.95);
            padding: 15px;
            border-radius: 8px;
            width: auto;
            min-width: 500px;
            max-width: 800px;
            display: none; /* ê¸°ë³¸ì ìœ¼ë¡œ ìˆ¨ê¹€ */
            z-index: 119; /* event-picker(z-index: 120)ë³´ë‹¤ ë‚®ê²Œ */
        }
        
        /* ì¸ë¼ì¸ ìŠ¤íƒ€ì¼ì´ ìš°ì„ í•˜ë¯€ë¡œ style.display = 'block'ì´ ì„¤ì •ë˜ë©´ í‘œì‹œë¨ */

        #focus-controls button {
            padding: 8px 16px;
            background: #4a90e2;
            border: none;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 10px;
        }

        #focus-controls button:hover {
            background: #5aa0f2;
        }

        #focus-info {
            font-size: 12px;
            color: #8a8fa5;
            margin-bottom: 10px;
        }

        /* Camera/Zoom Info Panel (top-right) */
        #camera-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(26, 31, 46, 0.95);
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 11px;
            color: #8a8fa5;
            font-family: 'Courier New', monospace;
            z-index: 50;
            min-width: 200px;
            border: 1px solid rgba(74, 143, 226, 0.3);
            cursor: move;
            user-select: none;
        }
        
        #camera-info.dragging {
            opacity: 0.8;
            border-color: rgba(74, 143, 226, 0.8);
        }

        #camera-info-title {
            font-size: 12px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 8px;
            border-bottom: 1px solid rgba(74, 143, 226, 0.3);
            padding-bottom: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        #camera-info-title:hover {
            color: #4a90e2;
        }

        #camera-info-toggle {
            font-size: 10px;
            color: #8a8fa5;
            margin-left: 8px;
            transition: transform 0.2s;
        }

        #camera-info-title:hover #camera-info-toggle {
            color: #4a90e2;
        }

        #camera-info.collapsed #camera-info-content {
            display: none;
        }

        #camera-info.collapsed #camera-info-title {
            margin-bottom: 0;
            border-bottom: none;
        }

        #camera-info-content {
            line-height: 1.6;
            transition: opacity 0.2s;
        }

        #camera-info-content .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        #camera-info-content .info-label {
            color: #8a8fa5;
        }

        #camera-info-content .info-value {
            color: #ffffff;
            font-weight: 500;
        }

        /* Kill event picker (top-left of canvas) */
        #event-picker {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(26, 31, 46, 0.95);
            border: 1px solid #2a2f3e;
            border-radius: 8px;
            padding: 10px;
            display: flex;
            gap: 8px;
            align-items: center;
            z-index: 120;
        }

        #event-picker select, #event-picker button {
            background: #2a2f3e;
            border: 1px solid #3a3f4e;
            color: #fff;
            border-radius: 4px;
            padding: 6px 8px;
            font-size: 12px;
        }

        #event-picker button.primary {
            background: #4a90e2;
            border-color: #4a90e2;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="top-nav">
        <div id="brand-logo">
            <img id="brand-image" src="crumb_logo.png" alt="CRUMB Logo" onerror="this.style.display='none'">
            <div id="brand-text">
                <div id="brand-name">CSA â€” Combat Simulation Analysis</div>
                <div id="brand-tagline">"Follow every trace." ğŸ</div>
            </div>
        </div>
        <div class="nav-item active">Info</div>
        <div class="nav-item">ì‹œë®¬ë ˆì´ì…˜ ë¶„ì„</div>
        <div class="nav-item" id="report-tab">ë¶„ì„ ë³´ê³ ì„œ</div>
        <div class="nav-item" id="lang-toggle" style="margin-left: auto; cursor: pointer; padding: 8px 12px; background: #2a2f3e; border-radius: 4px;">ğŸŒ EN</div>
    </div>

    <div id="container" style="display: none;">
        <div id="sidebar">
            <div class="sidebar-section">
                <h3>File Load</h3>
                <div id="file-input">
                    <button id="select-csv-btn" style="width: 100%; padding: 10px; background: #4a90e2; color: #fff; border: none; border-radius: 4px; cursor: pointer; margin-bottom: 10px;">íŒŒì¼ ì„ íƒ</button>
                    <div id="selected-file" style="font-size: 12px; color: #8a8fa5; margin-bottom: 10px;">ì„ íƒëœ íŒŒì¼ ì—†ìŒ</div>
                    <div id="loading" style="display: none;">CSV íŒŒì¼ ì²˜ë¦¬ ì¤‘...</div>
                </div>
            </div>


            

            <div class="sidebar-section">
                <h3>ë§¤ì¹˜ ê¸°ë³¸ ì •ë³´</h3>
                
                <div class="stat-group">
                    <div class="stat-item">
                        <span class="stat-label">ë§¤ì¹˜ id:</span>
                        <span class="stat-value" id="match-id">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">ë§¤ì¹˜ ì¢…ë£Œ ì‹œê°:</span>
                        <span class="stat-value" id="match-end-time">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">ë§¤ì¹˜ íƒ€ì…:</span>
                        <span class="stat-value" id="game-type">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">íŒ€ íƒ€ì…:</span>
                        <span class="stat-value" id="team-type">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">ë§µ:</span>
                        <span class="stat-value" id="map-name">-</span>
                    </div>
                </div>

                <div class="stat-group">
                    <h3 style="margin-top: 20px;">êµì „ ì •ë³´ ìš”ì•½</h3>
                    <div class="stat-group-title" style="margin-top: 5px;">í”Œë ˆì´ì–´ID, (íŒ€ë²ˆí˜¸), K/D/A í‚¬ / ë°ìŠ¤ / ì–´ì‹œìŠ¤íŠ¸</div>
                    <div id="player-list" style="max-height: calc(100vh - 650px); overflow-y: auto; overflow-x: hidden; margin-bottom: 20px;"></div>
                </div>
            </div>
        </div>

        <div id="canvas-container">
                    <!-- Camera/Zoom Info Panel -->
                    <div id="camera-info">
                        <div id="camera-info-title">
                            <span>Camera Info</span>
                            <span id="camera-info-toggle">â–¼</span>
                        </div>
                        <div id="camera-info-content">
                            <div class="info-row">
                                <span class="info-label">Distance:</span>
                                <span class="info-value" id="camera-distance">-</span>
                            </div>
                            <div class="info-row">
                                <span class="info-label">Zoom:</span>
                                <span class="info-value" id="camera-zoom">-</span>
                            </div>
                            <div class="info-row">
                                <span class="info-label">Target:</span>
                                <span class="info-value" id="camera-target">-</span>
                            </div>
                            <div class="info-row">
                                <span class="info-label">Position:</span>
                                <span class="info-value" id="camera-position">-</span>
                            </div>
                            <div class="info-row">
                                <span class="info-label">Rotation:</span>
                                <span class="info-value" id="camera-rotation">-</span>
                            </div>
                            <div class="info-row">
                                <span class="info-label">Follow Mode:</span>
                                <span class="info-value" id="camera-follow">-</span>
                            </div>
                        </div>
                    </div>
            <canvas id="canvas"></canvas>
            <!-- ë¯¸ë‹ˆë§µ ì œê±° (ë©”ì¸ ë·°ê°€ 2Dì´ë¯€ë¡œ ë¶ˆí•„ìš”) -->
            <!-- <div id="minimap" style="display: none;">
                <canvas id="minimap-canvas"></canvas>
            </div> -->
            <div id="event-picker">
                <button id="reset-view">Reset View</button>
                <button id="fit-to-view">Fit to View</button>

                <span style="width:12px"></span>
                <select id="player-select" style="padding: 6px 12px; background: #2a2f3e; color: #fff; border: 1px solid #3a3f4e; border-radius: 4px; min-width: 200px;">
                    <option value="">í”Œë ˆì´ì–´ ì„ íƒ (ì´ìƒ êµ¬ê°„ ìˆ˜ / ì´ë²¤íŠ¸ ìˆ˜)</option>
                </select>
                <button id="enter-focus-btn" style="padding: 6px 12px; background: #4a90e2; color: #fff; border: none; border-radius: 4px; cursor: pointer;">Go</button>
                <button id="prev-player-tick">Prev</button>
                <button id="next-player-tick">Next</button>
                <button id="follow-toggle">Follow</button>
            </div>
            <div id="focus-controls">
                <div id="focus-mode-content" style="display: none;">
                    <div id="focus-info" style="display: flex; justify-content: space-between; align-items: center; color: #4a90e2; font-weight: bold; margin-bottom: 10px; cursor: pointer; padding: 8px; background: #1a1f2e; border-radius: 4px;">
                        <div>í¬ì»¤ìŠ¤ ëª¨ë“œ: <span id="focus-player-name"></span></div>
                        <button id="focus-toggle-btn" style="padding: 4px 12px; background: #2a2f3e; color: #8a8fa5; border: 1px solid #3a3f4e; border-radius: 4px; cursor: pointer; font-size: 12px;">ì ‘ê¸°</button>
                    </div>
                    <div id="focus-content-wrapper" style="display: block;">
                        <div id="focus-view-selector" style="display: flex; gap: 8px; margin-bottom: 15px;">
                            <button id="focus-anomalies-tab" class="focus-tab-btn" style="padding: 8px 16px; background: #2a2f3e; color: #fff; border: 1px solid #3a3f4e; border-radius: 4px; cursor: pointer;">ì£¼ìš” ì´ìƒ êµ¬ê°„ ì‹œì  ì´ë™</button>
                            <button id="focus-events-tab" class="focus-tab-btn" style="padding: 8px 16px; background: #2a2f3e; color: #fff; border: 1px solid #3a3f4e; border-radius: 4px; cursor: pointer;">ì´ë²¤íŠ¸ë³„ ì‹œì  ì´ë™</button>
                            <button id="exit-focus-btn" style="padding: 8px 16px; background: #6c757d; color: #fff; border: none; border-radius: 4px; cursor: pointer;">í¬ì»¤ìŠ¤ ëª¨ë“œ ì¢…ë£Œ</button>
                        </div>
                        <div id="focus-anomalies-list" class="focus-content-panel" style="display: none; max-height: calc(100vh - 500px); overflow-y: auto; background: #1a1f2e; border-radius: 4px; padding: 10px; margin-bottom: 20px;">
                            <!-- ì´ìƒ êµ¬ê°„ ëª©ë¡ì´ ì—¬ê¸°ì— í‘œì‹œë¨ -->
                        </div>
                        <div id="focus-events-list" class="focus-content-panel" style="display: none; max-height: 200px; overflow-y: auto; background: #1a1f2e; border-radius: 4px; padding: 10px;">
                            <!-- ì´ë²¤íŠ¸ ëª©ë¡ì´ ì—¬ê¸°ì— í‘œì‹œë¨ -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    

    <div id="bottom-panel">
        <div id="resize-handle" title="Drag to resize"></div>
        <div id="controls">
            <div class="control-group">
                <button class="play-btn" id="play-btn">â–¶</button>
                <div class="timeline" id="timeline">
                    <div class="timeline-progress" id="timeline-progress"></div>
                </div>
                <div class="time-display" id="time-display">00:00 / 00:00</div>
                <div class="speed-control">
                    <button class="speed-btn" data-speed="0.5">0.5x</button>
                    <button class="speed-btn active" data-speed="1">1x</button>
                    <button class="speed-btn" data-speed="2">2x</button>
                    <button class="speed-btn" data-speed="3">3x</button>
                </div>
            </div>
        </div>

        <div id="event-tabs">
            <button class="tab-btn active" data-tab="actions">Action Stream</button>
            <button class="tab-btn" data-tab="aim">Aim Trace</button>
        </div>

        <div id="event-log"></div>
    </div>

    <!-- Dashboard View -->
    <div id="dashboard-view" style="display: block;">
        <div id="dashboard-content"></div>
    </div>
    
    <script>
        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì¦‰ì‹œ Dashboard í‘œì‹œ ë³´ì¥ (ìµœìš°ì„  ì‹¤í–‰)
        (function() {
            function initDashboard() {
                const dashboardView = document.getElementById('dashboard-view');
                const container = document.getElementById('container');
                const bottomPanel = document.getElementById('bottom-panel');
                const topNav = document.getElementById('top-nav');
                
                // ìƒë‹¨ ë„¤ë¹„ê²Œì´ì…˜ í•­ìƒ í‘œì‹œ
                if (topNav) {
                    topNav.style.display = 'flex';
                    topNav.style.visibility = 'visible';
                }
                
                // Dashboard í‘œì‹œ
                if (dashboardView) {
                    dashboardView.style.display = 'block';
                    dashboardView.style.visibility = 'visible';
                    dashboardView.classList.remove('hidden');
                }
                
                // Container ìˆ¨ê¸°ê¸°
                if (container) {
                    container.style.display = 'none';
                    container.style.visibility = 'hidden';
                }
                
                // í•˜ë‹¨ íŒ¨ë„ ìˆ¨ê¸°ê¸°
                if (bottomPanel) {
                    bottomPanel.style.display = 'none';
                    bottomPanel.style.visibility = 'hidden';
                }
            }
            
            // ì¦‰ì‹œ ì‹¤í–‰
            initDashboard();
            
            // DOM ë¡œë“œ í›„ì—ë„ ì‹¤í–‰
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initDashboard);
            }
            
            // ì¶”ê°€ ë³´ì¥ì„ ìœ„í•´ ì•½ê°„ì˜ ì§€ì—° í›„ ì‹¤í–‰
            setTimeout(initDashboard, 100);
            
            // CombatSimulation ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ëœ í›„ Dashboard ë Œë”ë§ ë³´ì¥
            let renderAttempts = 0;
            const maxAttempts = 10;
            const checkAndRender = setInterval(() => {
                if (window.simulation && typeof window.simulation.renderDashboard === 'function') {
                    window.simulation.renderDashboard();
                    clearInterval(checkAndRender);
                } else {
                    renderAttempts++;
                    if (renderAttempts >= maxAttempts) {
                        clearInterval(checkAndRender);
                        // ìµœì†Œí•œ ê¸°ë³¸ ë‚´ìš©ì´ë¼ë„ í‘œì‹œ
                        const content = document.getElementById('dashboard-content');
                        if (content && !content.innerHTML.trim()) {
                            content.innerHTML = `
                                <h1>CSA â€” Combat Simulation Analysis</h1>
                                <p>"Follow every trace." ğŸ</p>
                                <h2>ğŸš€ ë¹ ë¥¸ ì‹œì‘</h2>
                                <ol>
                                    <li><strong>ì‹œë®¬ë ˆì´ì…˜ ë¶„ì„</strong> íƒ­ í´ë¦­</li>
                                    <li>ì¢Œì¸¡ ì‚¬ì´ë“œë°” <strong>"íŒŒì¼ ì„ íƒ"</strong> ë²„íŠ¼ í´ë¦­</li>
                                    <li>GitHub CSV íŒŒì¼ ì„ íƒ</li>
                                    <li>3D ì‹œë®¬ë ˆì´ì…˜ ìë™ ì‹œì‘</li>
                                </ol>
                            `;
                        }
                    }
                }
            }, 200);
        })();
    </script>

    <!-- GitHub CSV ì„ íƒ íŒì—… -->
    <div id="csv-popup">
        <div id="csv-popup-content">
            <h3>í˜„ì¬ ê²½ë¡œì—ì„œ í™•ì¸ë˜ëŠ” csv íŒŒì¼</h3>
            
            <div id="csv-loading" style="color: #8a8fa5;">íŒŒì¼ ëª©ë¡ ë¡œë”© ì¤‘...</div>
            <ul id="csv-file-list"></ul>
            <div style="margin-top: 15px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                <button id="csv-load-local" style="flex: 1; min-width: 120px; padding: 12px 20px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; height: 44px; line-height: 1; box-sizing: border-box; display: flex; align-items: center; justify-content: center; margin: 0;">ë¡œì»¬ íŒŒì¼ ì„ íƒ</button>
                <button id="csv-load-selected" style="flex: 1; min-width: 120px; padding: 12px 20px; background: #4a90e2; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; height: 44px; line-height: 1; box-sizing: border-box; display: flex; align-items: center; justify-content: center; margin: 0;">ì„ íƒí•œ íŒŒì¼ ë¡œë“œ</button>
                <button id="csv-popup-close" style="flex: 1; min-width: 120px; padding: 12px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; height: 44px; line-height: 1; box-sizing: border-box; display: flex; align-items: center; justify-content: center; margin: 0;">ë‹«ê¸°</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script>
        class CombatSimulation {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                
                this.data = null;
                this.currentTick = 0;
                this.isPlaying = false;
                this.playSpeed = 1;
                this.initialRenderDone = false;
                
                this.playerObjects = new Map();
                this.playerLabels = new Map();
                this.playerTrails = new Map();
                this.playerPathLines = new Map();
                this.eventMarkers = [];
                this.mapBounds = null;
                this.selectedEvent = null;
                this.focusMode = false;
                this.focusModeType = 'anomaly'; // 'anomaly' or 'kill'
                this.focusPlayerId = null;
                this.focusTimeRange = null;
                this.focusTickRange = null;
                this.baseCameraDistance = 1500;
                this.language = 'ko'; // 'ko' or 'en'
                this.currentReportWindow = null; // í˜„ì¬ ì—´ë ¤ìˆëŠ” ë³´ê³ ì„œ ì°½
                this.detectedMapName = null; // ì¶”ë¡ ëœ ë§µ ì´ë¦„
                this.mapData = null; // ë§µ ë°ì´í„° (ì™¸ë¶€ì—ì„œ ë¡œë“œ)
                this.pathLines = null; // ì£¼ìš” ê²½ë¡œ ë¼ì¸
                this.cameraRotationX = 0.3;
                this.cameraRotationY = 0;
                this.cameraDistance = 1500;
                this.coordinateScale = 1.0; // ì¢Œí‘œ ìŠ¤ì¼€ì¼ íŒ©í„° (í™”ë©´ í¬ê¸°ì— ë§ê²Œ ì¡°ì •)
                this.coordinateOffset = { x: 0, y: 0, z: 0 }; // ì¢Œí‘œ ì˜¤í”„ì…‹ (ì¤‘ì‹¬ ì´ë™)
                this.defaultTarget = { x: 0, y: 0, z: 0 }; // ìŠ¤ì¼€ì¼ ì ìš© í›„ ê¸°ë³¸ íƒ€ê²Ÿ
                this.killLabels = new Map(); // í‚¬ ë¼ë²¨ ì¶”ì  (í˜ì´ë“œì•„ì›ƒìš©)
                this.playerIndex = new Map(); // name -> [{tick, pos}]
                this.selectedPlayer = null;
                this.mapImagePlane = null; // 2D ë§µ ì´ë¯¸ì§€ í‰ë©´
                this.mapImageTexture = null; // ë§µ ì´ë¯¸ì§€ í…ìŠ¤ì²˜
                this.mapImageSettings = {
                    imagePath: 'anubis-pro-vs-matchmaking-callouts-v0-k3ix37861a1a1.webp',
                    repeatX: 1,
                    repeatY: 1,
                    offsetX: 0,
                    offsetY: 0,
                    textureRotation: 0,
                    scaleX: 1,
                    scaleZ: 1,
                    worldOffsetX: 0,
                    worldOffsetZ: 0,
                    worldOffsetY: 0,
                    worldRotation: 0
                };
                this.followPlayer = false;
                this.manualZoomInFollow = false; // Follow ëª¨ë“œì—ì„œ ìˆ˜ë™ ì¤Œ ì¡°ì • ì—¬ë¶€
                this.timeAccumulator = 0; // ì¬ìƒìš© ì‹œê°„ ëˆ„ì  ë²„í¼

                // Aim Trace / ì´ìƒ íƒì§€ìš© ì¶”ê°€ ìƒíƒœ
                this.anomalyByTick = new Map(); // tick -> { score, seqId, isAnom }
                this.anomalyBaselineP99 = 0;     // tick_anomaly_score ê¸°ì¤€ p99
                
                // window.simulationì— ì¸ìŠ¤í„´ìŠ¤ í• ë‹¹ (ë””ë²„ê¹…ìš©)
                window.simulation = this;
                
                this.init();
            }

            init() {
                this.setupScene();
                this.setupControls();
                this.setupFileInput();
                this.setupFocusButtons();
                this.setupTabs();
                this.setupResizableBottom();
                this.setupNavigation();
                // ì¹´ë©”ë¼ ì¸í¬ íŒ¨ë„ ë“œë˜ê·¸ ê¸°ëŠ¥ ì„¤ì •
                this.setupCameraInfoDrag();
                
                // ì´ˆê¸° íƒ­ì— ë§ëŠ” ë ˆì´ì•„ì›ƒ í´ë˜ìŠ¤ ì„¤ì •
                const eventLog = document.getElementById('event-log');
                const activeTab = document.querySelector('.tab-btn.active');
                if (eventLog && activeTab) {
                    const tab = activeTab.getAttribute('data-tab');
                    if (tab === 'actions') {
                        eventLog.classList.add('action-stream');
                    } else if (tab === 'aim') {
                        eventLog.classList.add('aim-trace');
                    }
                } else if (eventLog) {
                    // ê¸°ë³¸ê°’: Action Stream (ê°€ë¡œ ë ˆì´ì•„ì›ƒ)
                    eventLog.classList.add('action-stream');
                }
                // ì´ˆê¸° ë¡œë“œ ì‹œ Dashboard í‘œì‹œ
                this.showDashboard();
                
                // ë§µ ë°ì´í„° ë¡œë“œ ì œê±° (ë¶ˆí•„ìš”)
                // requestAnimationFrame ê¸°ë°˜ ë©”ì¸ ë£¨í”„ ì‹œì‘
                this.animate();
            }

            setupFileInput() {
                const selectBtn = document.getElementById('select-csv-btn');
                
                if (selectBtn) {
                    selectBtn.addEventListener('click', () => {
                        this.showCSVPopup();
                    });
                }

                // íŒì—… ë‹«ê¸° ë²„íŠ¼
                const closeBtn = document.getElementById('csv-popup-close');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => {
                        document.getElementById('csv-popup').classList.remove('active');
                    });
                }
                
                // ë¡œì»¬ íŒŒì¼ ì„ íƒ ë²„íŠ¼ (csv-load-local) ì—°ê²°
                const localBtn = document.getElementById('csv-load-local');
                if (localBtn) {
                    // ìˆ¨ê²¨ì§„ file inputì„ ë™ì ìœ¼ë¡œ ìƒì„±
                    const hiddenInput = document.createElement('input');
                    hiddenInput.type = 'file';
                    hiddenInput.accept = '.csv';
                    hiddenInput.style.display = 'none';
                    document.body.appendChild(hiddenInput);

                    hiddenInput.addEventListener('change', async (e) => {
                        const file = e.target.files && e.target.files[0];
                        if (!file) return;
                        try {
                            await this.loadCSV(file);
                            const popup = document.getElementById('csv-popup');
                            if (popup) popup.classList.remove('active');
                        } catch (err) {
                            console.error('ë¡œì»¬ CSV ë¡œë“œ ì˜¤ë¥˜:', err);
                            alert('ë¡œì»¬ CSV ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + err.message);
                        } finally {
                            // ë™ì¼ íŒŒì¼ ë‹¤ì‹œ ì„ íƒ ê°€ëŠ¥í•˜ë„ë¡ value ì´ˆê¸°í™”
                            hiddenInput.value = '';
                        }
                    });

                    localBtn.addEventListener('click', () => {
                        hiddenInput.click();
                    });
                }

                // GitHub Token ê´€ë¦¬ (ì¶”í›„ í™•ì¥ìš©)
            }

            setupFocusButtons() {
                const playerSelect = document.getElementById('player-select');
                const enterFocusBtn = document.getElementById('enter-focus-btn');
                const focusModeContent = document.getElementById('focus-mode-content');
                const exitFocusBtn = document.getElementById('exit-focus-btn');
                const focusPlayerName = document.getElementById('focus-player-name');
                const focusEventsTab = document.getElementById('focus-events-tab');
                const focusAnomaliesTab = document.getElementById('focus-anomalies-tab');
                const focusEventsList = document.getElementById('focus-events-list');
                const focusAnomaliesList = document.getElementById('focus-anomalies-list');
                const focusToggleBtn = document.getElementById('focus-toggle-btn');
                const focusContentWrapper = document.getElementById('focus-content-wrapper');
                const focusInfo = document.getElementById('focus-info');

                // ë°ì´í„° ë¡œë“œ í›„ í”Œë ˆì´ì–´ ëª©ë¡ ì±„ìš°ê¸°
                this.updateFocusPlayerList = () => {
                    if (!playerSelect || !this.data || !this.data.metadata || !this.data.metadata.players) return;
                    
                    playerSelect.innerHTML = '<option value="">í”Œë ˆì´ì–´ ì„ íƒ (ì´ìƒ êµ¬ê°„ ìˆ˜ / ì´ë²¤íŠ¸ ìˆ˜)</option>';
                    const players = Array.isArray(this.data.metadata.players) 
                        ? this.data.metadata.players 
                        : Object.keys(this.data.metadata.players || {});
                    
                    const anomalySeqs = this.data.metadata.anomalySeqs || [];
                    const events = this.data.events || [];
                    
                    players.forEach(playerId => {
                        // í•´ë‹¹ í”Œë ˆì´ì–´ì˜ ì´ìƒ êµ¬ê°„ ìˆ˜ ê³„ì‚°
                        const playerAnomalySeqs = anomalySeqs.filter(seq => {
                            if (!seq.players) return false;
                            if (typeof seq.players.has === 'function') {
                                return seq.players.has(playerId);
                            }
                            if (Array.isArray(seq.players)) {
                                return seq.players.includes(playerId);
                            }
                            return false;
                        });
                        const anomalyCount = playerAnomalySeqs.length;
                        
                        // í•´ë‹¹ í”Œë ˆì´ì–´ì˜ ì´ë²¤íŠ¸ ìˆ˜ ê³„ì‚° (attackerì¸ ì´ë²¤íŠ¸)
                        const playerEvents = events.filter(e => 
                            e.attacker && e.attacker.name === playerId &&
                            (e.event_type_lower === 'kill' || e.event_type_lower === 'hit')
                        );
                        const eventCount = playerEvents.length;
                        
                        const option = document.createElement('option');
                        option.value = playerId;
                        option.textContent = `${playerId} (${anomalyCount} / ${eventCount})`;
                        playerSelect.appendChild(option);
                    });
                };

                // í¬ì»¤ìŠ¤ ëª¨ë“œ ì§„ì…
                if (enterFocusBtn) {
                    enterFocusBtn.addEventListener('click', () => {
                        const selectedPlayerId = playerSelect?.value;
                        if (!selectedPlayerId) {
                            alert(this.language === 'ko' ? 'í”Œë ˆì´ì–´ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”' : 'Please select a player');
                            return;
                        }
                        
                        this.enterFocusMode(selectedPlayerId);
                    });
                }

                // íƒ­ ì „í™˜
                if (focusAnomaliesTab) {
                    focusAnomaliesTab.addEventListener('click', () => {
                        focusAnomaliesTab.classList.add('active');
                        focusEventsTab?.classList.remove('active');
                        focusEventsList.style.display = 'none';
                        focusAnomaliesList.style.display = 'block';
                        this.updateFocusAnomaliesList();
                    });
                }

                if (focusEventsTab) {
                    focusEventsTab.addEventListener('click', () => {
                        focusEventsTab.classList.add('active');
                        focusAnomaliesTab?.classList.remove('active');
                        focusEventsList.style.display = 'block';
                        focusAnomaliesList.style.display = 'none';
                        this.updateFocusEventsList();
                    });
                }

                // í¬ì»¤ìŠ¤ ëª¨ë“œ ì¢…ë£Œ
                if (exitFocusBtn) {
                    exitFocusBtn.addEventListener('click', () => {
                        this.exitFocusMode();
                    });
                }
                
                // í¬ì»¤ìŠ¤ ëª¨ë“œ ì„¹ì…˜ í¼ì¹˜ê¸°/ì ‘ê¸°
                const toggleFocusContent = () => {
                    if (!focusContentWrapper || !focusToggleBtn) return;
                    const isExpanded = focusContentWrapper.style.display !== 'none';
                    if (isExpanded) {
                        focusContentWrapper.style.display = 'none';
                        focusToggleBtn.textContent = 'í¼ì¹˜ê¸°';
                        focusToggleBtn.style.background = '#2a2f3e';
                        focusToggleBtn.style.color = '#8a8fa5';
                    } else {
                        focusContentWrapper.style.display = 'block';
                        focusToggleBtn.textContent = 'ì ‘ê¸°';
                        focusToggleBtn.style.background = '#4a90e2';
                        focusToggleBtn.style.color = '#fff';
                    }
                };
                
                if (focusToggleBtn) {
                    focusToggleBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleFocusContent();
                    });
                }
                
                if (focusInfo) {
                    focusInfo.addEventListener('click', (e) => {
                        // ë²„íŠ¼ í´ë¦­ì´ ì•„ë‹ ë•Œë§Œ í† ê¸€
                        if (e.target !== focusToggleBtn && !focusToggleBtn.contains(e.target)) {
                            toggleFocusContent();
                        }
                    });
                }
            }

            enterFocusMode(playerId) {
                this.focusMode = true;
                this.focusPlayerId = playerId;
                
                // UI ì—…ë°ì´íŠ¸
                const focusControls = document.getElementById('focus-controls');
                const focusModeContent = document.getElementById('focus-mode-content');
                const focusPlayerName = document.getElementById('focus-player-name');
                const focusViewSelector = document.getElementById('focus-view-selector');
                
                console.log('enterFocusMode - focusControls:', focusControls);
                console.log('enterFocusMode - focusModeContent:', focusModeContent);
                
                // focus-controls í‘œì‹œ (ì¸ë¼ì¸ ìŠ¤íƒ€ì¼ë¡œ ê°•ì œ ì„¤ì •)
                if (focusControls) {
                    focusControls.style.display = 'block';
                    focusControls.style.visibility = 'visible';
                    focusControls.classList.add('show');
                    console.log('enterFocusMode - focus-controls í‘œì‹œ ì„¤ì • ì™„ë£Œ');
                } else {
                    console.error('enterFocusMode - focus-controls ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!');
                }
                
                // focus-mode-content í‘œì‹œ
                if (focusModeContent) {
                    focusModeContent.style.display = 'block';
                    console.log('enterFocusMode - focus-mode-content í‘œì‹œ ì„¤ì • ì™„ë£Œ');
                } else {
                    console.error('enterFocusMode - focus-mode-content ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!');
                }
                
                if (focusPlayerName) focusPlayerName.textContent = playerId;
                
                // Go í´ë¦­ í›„ "ì´ìƒ êµ¬ê°„ / ì´ë²¤íŠ¸ ë³´ê¸°" ì„ íƒ í•­ëª© í‘œì‹œ
                if (focusViewSelector) focusViewSelector.style.display = 'flex';
                
                // ì´ˆê¸°ì—ëŠ” ì•„ë¬´ íƒ­ë„ ì„ íƒí•˜ì§€ ì•ŠìŒ (ì‚¬ìš©ìê°€ ì„ íƒí•˜ë„ë¡)
                const focusEventsTab = document.getElementById('focus-events-tab');
                const focusAnomaliesTab = document.getElementById('focus-anomalies-tab');
                const focusEventsList = document.getElementById('focus-events-list');
                const focusAnomaliesList = document.getElementById('focus-anomalies-list');
                
                if (focusEventsTab) focusEventsTab.classList.remove('active');
                if (focusAnomaliesTab) focusAnomaliesTab.classList.remove('active');
                if (focusEventsList) focusEventsList.style.display = 'none';
                if (focusAnomaliesList) focusAnomaliesList.style.display = 'none';
            }

            updateFocusEventsList() {
                const focusEventsList = document.getElementById('focus-events-list');
                if (!focusEventsList || !this.data || !this.data.events || !this.focusPlayerId) return;
                
                // í•´ë‹¹ í”Œë ˆì´ì–´ì˜ ì´ë²¤íŠ¸ í•„í„°ë§ (í‚¬, íˆíŠ¸ ë“±)
                const playerEvents = this.data.events.filter(e => 
                    e.attacker && e.attacker.name === this.focusPlayerId &&
                    (e.event_type_lower === 'kill' || e.event_type_lower === 'hit')
                );
                
                focusEventsList.innerHTML = '';
                
                if (playerEvents.length === 0) {
                    focusEventsList.innerHTML = '<div style="color: #8a8fa5; padding: 20px; text-align: center;">ì´ë²¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤</div>';
                    return;
                }
                
                playerEvents.forEach((event, idx) => {
                    const eventItem = document.createElement('div');
                    eventItem.style.cssText = 'padding: 10px; margin-bottom: 8px; background: #2a2f3e; border-radius: 4px; border-left: 3px solid ' + 
                        (event.event_type_lower === 'kill' ? '#ff6b6b' : '#ffa500') + ';';
                    
                    // ì´ë²¤íŠ¸ ìƒì„¸ ì •ë³´ ìƒì„± (ì´ìƒ êµ¬ê°„ í˜•ì‹)
                    const eventDetails = [];
                    // ì´ë²¤íŠ¸ ID (tickì„ IDë¡œ ì‚¬ìš©)
                    eventDetails.push(`<div><strong style="color: #fff;">ì´ë²¤íŠ¸ ID:</strong> <span style="color: #8a8fa5;">${event.tick || 'N/A'}</span></div>`);
                    // Tick ì •ë³´
                    eventDetails.push(`<div><strong style="color: #fff;">Tick:</strong> <span style="color: #8a8fa5;">${event.tick || 'N/A'}</span></div>`);
                    // ì‹œê°„ ì •ë³´
                    if (event.game_time !== undefined && event.game_time !== null) {
                        eventDetails.push(`<div><strong style="color: #fff;">ì‹œê°„:</strong> <span style="color: #8a8fa5;">${event.game_time.toFixed(3)}ì´ˆ</span></div>`);
                    }
                    // ì´ë²¤íŠ¸ íƒ€ì…
                    eventDetails.push(`<div><strong style="color: #fff;">ì´ë²¤íŠ¸ íƒ€ì…:</strong> <span style="color: #8a8fa5;">${event.event_type_lower || event.event_type || 'N/A'}</span></div>`);
                    // ê³µê²©ì ì •ë³´
                    if (event.attacker && event.attacker.name) {
                        eventDetails.push(`<div><strong style="color: #fff;">ê³µê²©ì:</strong> <span style="color: #8a8fa5;">${event.attacker.name}</span></div>`);
                    }
                    // í”¼í•´ì ì •ë³´
                    if (event.victim && event.victim.name) {
                        eventDetails.push(`<div><strong style="color: #fff;">í”¼í•´ì:</strong> <span style="color: #8a8fa5;">${event.victim.name}</span></div>`);
                    }
                    // ë¬´ê¸° ì •ë³´
                    if (event.weapon !== undefined && event.weapon !== null) {
                        let weaponName = 'N/A';
                        if (typeof event.weapon === 'object') {
                            weaponName = event.weapon.name || event.weapon.id || String(event.weapon);
                        } else {
                            weaponName = String(event.weapon);
                        }
                        eventDetails.push(`<div><strong style="color: #fff;">ë¬´ê¸°:</strong> <span style="color: #8a8fa5;">${weaponName}</span></div>`);
                    }
                    // ê±°ë¦¬ ì •ë³´
                    if (event.distance !== undefined && event.distance !== null) {
                        eventDetails.push(`<div><strong style="color: #fff;">ê±°ë¦¬:</strong> <span style="color: #8a8fa5;">${event.distance.toFixed(2)}</span></div>`);
                    }
                    // ë°ë¯¸ì§€ ì •ë³´
                    if (event.damage !== undefined && event.damage !== null) {
                        eventDetails.push(`<div><strong style="color: #fff;">ë°ë¯¸ì§€:</strong> <span style="color: #8a8fa5;">${event.damage}</span></div>`);
                    }
                    
                    eventItem.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="flex: 1;">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <strong style="color: #fff;">${event.event_type_lower === 'kill' ? 'í‚¬' : 'íˆíŠ¸'}</strong>
                                    ${event.victim && event.victim.name ? `<span style="color: #8a8fa5;">â†’ ${event.victim.name}</span>` : ''}
                                    <button class="expand-event-btn" data-event-idx="${idx}" style="padding: 4px 8px; background: #3a3f4e; color: #8a8fa5; border: 1px solid #4a4f5e; border-radius: 4px; cursor: pointer; font-size: 11px;">í¼ì¹˜ê¸°</button>
                                </div>
                                <div style="color: #6b9bd5; font-size: 12px; margin-top: 4px;">Tick: ${event.tick || 'N/A'}</div>
                            </div>
                            <button class="goto-event-btn" data-tick="${event.tick}" style="padding: 6px 12px; background: #4a90e2; color: #fff; border: none; border-radius: 4px; cursor: pointer; margin-left: 8px;">ì´ë™</button>
                        </div>
                        <div class="event-details" data-event-idx="${idx}" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid #3a3f4e;">
                            <div style="color: #8a8fa5; font-size: 11px; line-height: 1.6;">
                                ${eventDetails.length > 0 ? eventDetails.join('') : '<div style="color: #8a8fa5;">ì¶”ê°€ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.</div>'}
                            </div>
                        </div>
                    `;
                    
                    // í¼ì¹˜ê¸°/ì ‘ê¸° ë²„íŠ¼ ì´ë²¤íŠ¸
                    const expandBtn = eventItem.querySelector('.expand-event-btn');
                    const detailsDiv = eventItem.querySelector('.event-details');
                    if (expandBtn && detailsDiv) {
                        expandBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const isCurrentlyExpanded = detailsDiv.style.display !== 'none';
                            if (isCurrentlyExpanded) {
                                detailsDiv.style.display = 'none';
                                expandBtn.textContent = 'í¼ì¹˜ê¸°';
                                expandBtn.style.background = '#3a3f4e';
                                expandBtn.style.color = '#8a8fa5';
                            } else {
                                detailsDiv.style.display = 'block';
                                expandBtn.textContent = 'ì ‘ê¸°';
                                expandBtn.style.background = '#4a90e2';
                                expandBtn.style.color = '#fff';
                            }
                        });
                    }
                    
                    const gotoBtn = eventItem.querySelector('.goto-event-btn');
                    if (gotoBtn) {
                        gotoBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            this.jumpToEvent(event);
                        });
                    }
                    
                    focusEventsList.appendChild(eventItem);
                });
            }

            updateFocusAnomaliesList() {
                const focusAnomaliesList = document.getElementById('focus-anomalies-list');
                if (!focusAnomaliesList || !this.data || !this.data.metadata || !this.focusPlayerId) return;
                
                const anomalySeqs = this.data.metadata.anomalySeqs || [];
                
                // í•´ë‹¹ í”Œë ˆì´ì–´ê°€ í¬í•¨ëœ ì´ìƒ êµ¬ê°„ í•„í„°ë§
                const playerAnomalySeqs = anomalySeqs.filter(seq => {
                    if (!seq.players) return false;
                    if (typeof seq.players.has === 'function') {
                        return seq.players.has(this.focusPlayerId);
                    }
                    if (Array.isArray(seq.players)) {
                        return seq.players.includes(this.focusPlayerId);
                    }
                    return false;
                });
                
                focusAnomaliesList.innerHTML = '';
                
                if (playerAnomalySeqs.length === 0) {
                    focusAnomaliesList.innerHTML = '<div style="color: #8a8fa5; padding: 20px; text-align: center;">ì´ìƒ êµ¬ê°„ì´ ì—†ìŠµë‹ˆë‹¤</div>';
                    return;
                }
                
                // ì ìˆ˜ ê¸°ì¤€ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
                const sortedSeqs = playerAnomalySeqs.sort((a, b) => 
                    (b.maxTickScore || 0) - (a.maxTickScore || 0)
                );
                
                sortedSeqs.forEach((seq, idx) => {
                    const seqItem = document.createElement('div');
                    seqItem.className = 'anomaly-seq-item';
                    seqItem.dataset.seqIdx = idx;
                    seqItem.style.cssText = 'padding: 10px; margin-bottom: 8px; background: #2a2f3e; border-radius: 4px; border-left: 3px solid #ff6b6b;';
                    
                    // í¼ì¹˜ê¸°/ì ‘ê¸° ìƒíƒœ ê´€ë¦¬
                    const isExpanded = false;
                    
                    seqItem.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer;" class="anomaly-seq-header">
                            <div style="flex: 1;">
                                <strong style="color: #fff;">ì´ìƒ êµ¬ê°„ #${idx + 1}</strong>
                                <div style="color: #ff6b6b; font-size: 12px; margin-top: 4px; font-weight: bold;">
                                    Tick ${seq.startTick} ~ ${seq.endTick} êµ¬ê°„ì—ì„œ ì—ì„ë´‡ ì˜ì‹¬
                                </div>
                                <div style="color: #8a8fa5; font-size: 11px; margin-top: 2px;">
                                    ì ìˆ˜: ${(seq.maxTickScore || 0).toFixed(2)}
                                </div>
                            </div>
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <button class="expand-anomaly-btn" data-seq-idx="${idx}" style="padding: 4px 8px; background: #3a3f4e; color: #8a8fa5; border: 1px solid #4a4f5e; border-radius: 4px; cursor: pointer; font-size: 11px;">í¼ì¹˜ê¸°</button>
                                <button class="goto-anomaly-btn" data-start="${seq.startTick}" data-end="${seq.endTick}" style="padding: 6px 12px; background: #4a90e2; color: #fff; border: none; border-radius: 4px; cursor: pointer;">ì´ë™</button>
                            </div>
                        </div>
                        <div class="anomaly-seq-details" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid #3a3f4e;">
                            <div style="color: #8a8fa5; font-size: 11px; line-height: 1.6;">
                                <div><strong style="color: #fff;">ì‹œí€€ìŠ¤ ID:</strong> ${seq.seqId || 'N/A'}</div>
                                <div><strong style="color: #fff;">ì‹œì‘ Tick:</strong> ${seq.startTick}</div>
                                <div><strong style="color: #fff;">ì¢…ë£Œ Tick:</strong> ${seq.endTick}</div>
                                <div><strong style="color: #fff;">Anchor Tick:</strong> ${seq.anchorTick || 'N/A'}</div>
                                <div><strong style="color: #fff;">ìµœëŒ€ Tick ì ìˆ˜:</strong> ${(seq.maxTickScore || 0).toFixed(4)}</div>
                                <div><strong style="color: #fff;">ì‹œí€€ìŠ¤ ì ìˆ˜:</strong> ${(seq.seqScore || 0).toFixed(4)}</div>
                                <div><strong style="color: #fff;">í‹± ë²”ìœ„:</strong> ${seq.endTick - seq.startTick + 1} í‹±</div>
                            </div>
                        </div>
                    `;
                    
                    // í¼ì¹˜ê¸°/ì ‘ê¸° ë²„íŠ¼ ì´ë²¤íŠ¸
                    const expandBtn = seqItem.querySelector('.expand-anomaly-btn');
                    const detailsDiv = seqItem.querySelector('.anomaly-seq-details');
                    if (expandBtn && detailsDiv) {
                        expandBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const isCurrentlyExpanded = detailsDiv.style.display !== 'none';
                            if (isCurrentlyExpanded) {
                                detailsDiv.style.display = 'none';
                                expandBtn.textContent = 'í¼ì¹˜ê¸°';
                                expandBtn.style.background = '#3a3f4e';
                                expandBtn.style.color = '#8a8fa5';
                            } else {
                                detailsDiv.style.display = 'block';
                                expandBtn.textContent = 'ì ‘ê¸°';
                                expandBtn.style.background = '#4a90e2';
                                expandBtn.style.color = '#fff';
                            }
                        });
                    }
                    
                    // ì´ë™ ë²„íŠ¼ ì´ë²¤íŠ¸
                    const gotoBtn = seqItem.querySelector('.goto-anomaly-btn');
                    if (gotoBtn) {
                        gotoBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            this.jumpToAnomalySeq(seq);
                        });
                    }
                    
                    focusAnomaliesList.appendChild(seqItem);
                });
            }

            jumpToEvent(event) {
                if (!event || event.tick === undefined) return;
                
                const tickIndex = this.data.positions.findIndex(p => p.tick === event.tick);
                if (tickIndex === -1) return;
                
                this.currentTick = tickIndex;
                this.renderTick(tickIndex, 0);
                this.updateTimeDisplay();
                this.selectEvent(event);
                
                // ì´ë²¤íŠ¸ë³„ ì‹œì  ì´ë™ì€ ì¼ë°˜ ë°©ì‹ì„ ì‚¬ìš©í•˜ë„ë¡ selectedAnomalySeq ì´ˆê¸°í™”
                this.selectedAnomalySeq = null;
                
                // ì´ë²¤íŠ¸ ì£¼ë³€ ë²”ìœ„ ì„¤ì • (Â±20í‹±)
                const preContext = 20; // fire ì „ 20í‹±
                const postContext = 20; // fire í›„ 20í‹±
                const startIdx = Math.max(0, tickIndex - preContext);
                const endIdx = Math.min(this.data.positions.length - 1, tickIndex + postContext);
                this.focusTickRange = {
                    startIdx: startIdx,
                    endIdx: endIdx,
                    anchorIdx: tickIndex,
                    anchorTick: event.tick
                };
                
                // ë§µ ì¹´ë©”ë¼ë¥¼ Source(attacker)ì™€ Target(victim) ì¤‘ì‹¬ìœ¼ë¡œ ì„¤ì •
                const tickData = this.data.positions[tickIndex];
                if (tickData && tickData.players) {
                    let attackerPos = null;
                    let victimPos = null;
                    
                    // ê³µê²©ì ìœ„ì¹˜ ì°¾ê¸°
                    if (event.attacker && event.attacker.name) {
                        const attackerPlayer = tickData.players.find(p => p.name === event.attacker.name);
                        if (attackerPlayer && attackerPlayer.position && Array.isArray(attackerPlayer.position)) {
                            attackerPos = {
                                x: (attackerPlayer.position[0] - this.coordinateOffset.x) * this.coordinateScale,
                                y: (attackerPlayer.position[1] - this.coordinateOffset.y) * this.coordinateScale,
                                z: (attackerPlayer.position[2] - this.coordinateOffset.z) * this.coordinateScale
                            };
                        }
                    }
                    
                    // í”¼í•´ì ìœ„ì¹˜ ì°¾ê¸°
                    if (event.victim && event.victim.name) {
                        const victimPlayer = tickData.players.find(p => p.name === event.victim.name);
                        if (victimPlayer && victimPlayer.position && Array.isArray(victimPlayer.position)) {
                            victimPos = {
                                x: (victimPlayer.position[0] - this.coordinateOffset.x) * this.coordinateScale,
                                y: (victimPlayer.position[1] - this.coordinateOffset.y) * this.coordinateScale,
                                z: (victimPlayer.position[2] - this.coordinateOffset.z) * this.coordinateScale
                            };
                        }
                    }
                    
                    // ì¹´ë©”ë¼ íƒ€ê²Ÿ ì„¤ì • (attackerì™€ victimì˜ ì¤‘ê°„ì  ë˜ëŠ” attackerë§Œ)
                    if (attackerPos && victimPos) {
                        // Sourceì™€ Targetì˜ ì¤‘ê°„ì 
                        this.cameraTarget = {
                            x: (attackerPos.x + victimPos.x) / 2,
                            y: (attackerPos.z + victimPos.z) / 2, // Three.js Yì¶•
                            z: (attackerPos.y + victimPos.y) / 2  // Three.js Zì¶•
                        };
                        
                        // ë‘ í”Œë ˆì´ì–´ ì‚¬ì´ ê±°ë¦¬ ê³„ì‚°í•˜ì—¬ ì ì ˆí•œ ì¤Œ ê±°ë¦¬ ì„¤ì •
                        const dx = attackerPos.x - victimPos.x;
                        const dy = attackerPos.y - victimPos.y;
                        const dz = attackerPos.z - victimPos.z;
                        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        
                        // ê±°ë¦¬ì˜ 1.5ë°° ì •ë„ë¡œ ì¤Œ (ìµœëŒ€í•œ ê°€ê¹ê²Œ)
                        this.cameraDistance = Math.max(100, Math.min(1000, distance * 1.5));
                    } else if (attackerPos) {
                        // attackerë§Œ ìˆëŠ” ê²½ìš°
                        this.cameraTarget = {
                            x: attackerPos.x,
                            y: attackerPos.z,
                            z: attackerPos.y
                        };
                        const mapSize = this.mapBounds ? Math.max(this.mapBounds.width, this.mapBounds.depth) : 1000;
                        this.cameraDistance = Math.max(100, Math.min(500, mapSize * 0.05)); // ë§¤ìš° ê°€ê¹Œìš´ ê±°ë¦¬
                    }
                    
                    if (this.cameraTarget) {
                        // íŒ¨ë‹ ì˜¤í”„ì…‹ ì´ˆê¸°í™”
                        if (this.panOffset) {
                            this.panOffset.x = 0;
                            this.panOffset.y = 0;
                            this.panOffset.z = 0;
                        }
                        
                        // í”Œë ˆì´ì–´ ì„ íƒ ì—…ë°ì´íŠ¸ (attacker ìš°ì„ )
                        if (event.attacker && event.attacker.name) {
                            const select = document.getElementById('player-select');
                            if (select) {
                                select.value = event.attacker.name;
                                this.selectedPlayer = event.attacker.name;
                            }
                        }
                        
                        // ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸
                        if (this.updateCamera) {
                            this.updateCamera();
                        }
                        if (this.updateCameraToTarget) {
                            this.updateCameraToTarget();
                        }
                        
                        console.log('jumpToEvent - ì¹´ë©”ë¼ ì„¤ì •:', {
                            attacker: event.attacker?.name,
                            victim: event.victim?.name,
                            camera_target: this.cameraTarget,
                            camera_distance: this.cameraDistance
                        });
                    }
                }
                
                // Aim Trace íƒ­ í™œì„±í™” ë° ë Œë”ë§
                const aimTabBtn = document.querySelector('.tab-btn[data-tab="aim"]');
                if (aimTabBtn) {
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    aimTabBtn.classList.add('active');
                }
                this.renderAimTrace();
            }

            jumpToAnomalySeq(seq) {
                if (!seq || seq.startTick === undefined) return;
                
                // ì„ íƒëœ ì´ìƒ êµ¬ê°„ ì €ì¥
                this.selectedAnomalySeq = seq;
                
                const startTickIndex = this.data.positions.findIndex(p => p.tick >= seq.startTick);
                if (startTickIndex === -1) return;
                
                this.currentTick = startTickIndex;
                this.renderTick(startTickIndex, 0);
                this.updateTimeDisplay();
                
                // í¬ì»¤ìŠ¤ ë²”ìœ„ ì„¤ì •: ì‹¤ì œ ì´ìƒ êµ¬ê°„(startTick ~ endTick) ê¸°ì¤€ìœ¼ë¡œ padding ì¶”ê°€
                const padding = 30; // ì „í›„ 30í‹± ì¶”ê°€
                const seqStartTick = Number(seq.startTick) - padding;
                const seqEndTick = Number(seq.endTick) + padding;
                const anchorTick = seq.anchorTick || seq.startTick; // tick offset ê³„ì‚°ìš© (ì‹œê°í™” ë²”ìœ„ì™€ëŠ” ë³„ê°œ)
                
                // ì‹¤ì œ ì´ìƒ êµ¬ê°„ì˜ ì¸ë±ìŠ¤ ì°¾ê¸°
                let startIdx = 0;
                let endIdx = this.data.positions.length - 1;
                for (let i = 0; i < this.data.positions.length; i++) {
                    if (this.data.positions[i].tick >= seqStartTick) {
                        startIdx = i;
                        break;
                    }
                }
                for (let i = this.data.positions.length - 1; i >= 0; i--) {
                    if (this.data.positions[i].tick <= seqEndTick) {
                        endIdx = i;
                        break;
                    }
                }
                
                // anchorTick ì¸ë±ìŠ¤ ì°¾ê¸° (tick offset ê³„ì‚°ìš©)
                const anchorTickIndex = this.data.positions.findIndex(p => p.tick >= anchorTick);
                
                if (startIdx !== -1 && endIdx !== -1) {
                    this.focusTickRange = {
                        startIdx: startIdx,
                        endIdx: endIdx,
                        anchorIdx: anchorTickIndex !== -1 ? anchorTickIndex : startIdx,
                        anchorTick: anchorTick
                    };
                }
                
                console.log(`[ì‹œë®¬ë ˆì´ì…˜] ì´ìƒ êµ¬ê°„ ì‹œê°í™” ë²”ìœ„ ì„¤ì •:`);
                console.log(`  - ì‹¤ì œ ì´ìƒ êµ¬ê°„: ${seq.startTick} ~ ${seq.endTick} (${seq.endTick - seq.startTick + 1}í‹±)`);
                console.log(`  - ì‹œê°í™” ë²”ìœ„: ${seqStartTick} ~ ${seqEndTick} (startTick-30 ~ endTick+30, ì¸ë±ìŠ¤ ${startIdx} ~ ${endIdx})`);
                console.log(`  - anchorTick (offset ê¸°ì¤€): ${anchorTick}`);
                
                // Aim Trace íƒ­ í™œì„±í™” ë° ë Œë”ë§
                const aimTabBtn = document.querySelector('.tab-btn[data-tab="aim"]');
                if (aimTabBtn) {
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    aimTabBtn.classList.add('active');
                }
                this.renderAimTrace();
            }
            

            setupNavigation() {
                const navItems = document.querySelectorAll('.nav-item');
                navItems.forEach(item => {
                    item.addEventListener('click', () => {
                        const text = item.textContent.trim();
                        if (text === 'Info') {
                            this.showDashboard();
                        } else if (text === 'ì‹œë®¬ë ˆì´ì…˜ ë¶„ì„') {
                            this.showInvestigate();
                        } else {
                            // ë‹¤ë¥¸ íƒ­ë“¤ì€ ë‚˜ì¤‘ì— êµ¬í˜„
                            navItems.forEach(n => n.classList.remove('active'));
                            item.classList.add('active');
                        }
                    });
                });
            }

            showDashboard() {
                document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                document.querySelectorAll('.nav-item').forEach(n => {
                    if (n.textContent.trim() === 'Info') n.classList.add('active');
                });
                
                const dashboardView = document.getElementById('dashboard-view');
                const container = document.getElementById('container');
                const bottomPanel = document.getElementById('bottom-panel');
                
                if (dashboardView && container) {
                    container.style.display = 'none';
                    dashboardView.style.display = 'block';
                    dashboardView.style.visibility = 'visible';
                    dashboardView.classList.remove('hidden');
                    // í•˜ë‹¨ íŒ¨ë„ ìˆ¨ê¸°ê¸°
                    if (bottomPanel) {
                        bottomPanel.style.display = 'none';
                    }
                    // Dashboard ë Œë”ë§
                    this.renderDashboard();
                } else {
                    console.error('Dashboard view ë˜ëŠ” containerë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                }
            }

            showInvestigate() {
                document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                document.querySelectorAll('.nav-item').forEach(n => {
                    if (n.textContent.trim() === 'ì‹œë®¬ë ˆì´ì…˜ ë¶„ì„') n.classList.add('active');
                });
                
                const dashboardView = document.getElementById('dashboard-view');
                const container = document.getElementById('container');
                const bottomPanel = document.getElementById('bottom-panel');
                
                // Dashboard ìˆ¨ê¸°ê¸°
                if (dashboardView) {
                    dashboardView.style.display = 'none';
                    dashboardView.style.visibility = 'hidden';
                    dashboardView.classList.add('hidden');
                }
                
                // Container í‘œì‹œ
                if (container) {
                    container.style.display = 'flex';
                    container.style.visibility = 'visible';
                    // ê°•ì œë¡œ ë ˆì´ì•„ì›ƒ ì¬ê³„ì‚° (ì˜¤ë¥˜ ë°©ì§€)
                    try {
                        void container.offsetHeight;
                    } catch (e) {
                        // ë ˆì´ì•„ì›ƒ ì¬ê³„ì‚° ì˜¤ë¥˜ ë¬´ì‹œ
                    }
                    
                    // í•˜ë‹¨ íŒ¨ë„ ë‹¤ì‹œ í‘œì‹œ
                    if (bottomPanel) {
                        bottomPanel.style.display = 'flex';
                        bottomPanel.style.visibility = 'visible';
                    }
                    
                    // Canvas ì»¨í…Œì´ë„ˆê°€ ë³´ì´ë„ë¡ ë³´ì¥
                    const canvasContainer = document.getElementById('canvas-container');
                    if (canvasContainer) {
                        canvasContainer.style.display = 'block';
                        canvasContainer.style.visibility = 'visible';
                    }
                    
                    // í™”ë©´ì„ ë§¨ ìœ„ë¡œ ìŠ¤í¬ë¡¤
                    try {
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                        if (container && typeof container.scrollTop !== 'undefined') {
                            container.scrollTop = 0;
                        }
                    } catch (e) {
                        // ìŠ¤í¬ë¡¤ ì˜¤ë¥˜ ë¬´ì‹œ
                        console.warn('Scroll error:', e);
                    }
                    
                    // ë°ì´í„°ê°€ ì—†ì„ ë•Œ ì•ˆë‚´ ë©”ì‹œì§€ í‘œì‹œ
                    if (!this.data || !this.data.positions || this.data.positions.length === 0) {
                        // ì•ˆë‚´ ë©”ì‹œì§€ë¥¼ ìœ„í•œ ì˜¤ë²„ë ˆì´ ì¶”ê°€
                        let messageOverlay = document.getElementById('no-data-message');
                        if (!messageOverlay) {
                            messageOverlay = document.createElement('div');
                            messageOverlay.id = 'no-data-message';
                            messageOverlay.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #8a8fa5; z-index: 1000; pointer-events: none;';
                            if (canvasContainer) {
                                canvasContainer.appendChild(messageOverlay);
                            }
                        }
                        messageOverlay.innerHTML = `
                            <div style="font-size: 24px; margin-bottom: 10px;">CSV íŒŒì¼ì„ ë¨¼ì € ë¡œë“œí•´ì£¼ì„¸ìš”</div>
                            <div style="font-size: 16px;">ì¢Œì¸¡ ì‚¬ì´ë“œë°”ì˜ "íŒŒì¼ ì„ íƒ" ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”</div>
                        `;
                        messageOverlay.style.display = 'block';
                    } else {
                        // ë°ì´í„°ê°€ ìˆìœ¼ë©´ ë©”ì‹œì§€ ìˆ¨ê¹€
                        const messageOverlay = document.getElementById('no-data-message');
                        if (messageOverlay) {
                            messageOverlay.style.display = 'none';
                        }
                    }
                    
                    // Renderer í¬ê¸° ì¬ì¡°ì •
                    if (this.renderer) {
                        setTimeout(() => {
                            const width = canvasContainer ? canvasContainer.clientWidth : 800;
                            const height = canvasContainer ? canvasContainer.clientHeight : 600;
                            if (width > 0 && height > 0) {
                                this.camera.aspect = width / height;
                                this.camera.updateProjectionMatrix();
                                this.renderer.setSize(width, height);
                            }
                        }, 100);
                    } else if (this.scene) {
                        // Rendererê°€ ì—†ìœ¼ë©´ ì”¬ ì¬ì´ˆê¸°í™”
                        setTimeout(() => {
                            this.setupScene();
                        }, 100);
                    }
                }
            }

            async renderDashboard() {
                const content = document.getElementById('dashboard-content');
                if (!content) return;

                // ë¸Œëœë“œ í—¤ë” ì¶”ê°€
                const brandHeader = `
                    <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 40px; padding-bottom: 20px; border-bottom: 2px solid #2a2f3e;">
                        <img src="crumb_logo.png" alt="CRUMB Logo" onerror="this.style.display='none'" style="height: 64px; width: auto; object-fit: contain;">
                        <div>
                            <h1 style="margin: 0; font-size: 28px; color: #fff; font-weight: 600; letter-spacing: 0.5px;">CSA â€” Combat Simulation Analysis</h1>
                            <p style="margin: 8px 0 0 0; font-size: 14px; color: #8a8fa5; font-style: italic;">"Follow every trace." ğŸ</p>
                        </div>
                    </div>
                `;

                // README ë‚´ìš©ì„ HTMLë¡œ ë³€í™˜ (ì–¸ì–´ë³„)
                const readmeContents = {
                    ko: `FPS ì „íˆ¬ êµì „ ìƒí™©ì„ 3Dë¡œ ì‹œë®¬ë ˆì´ì…˜í•˜ê³  ë¶„ì„í•˜ëŠ” ì›¹ í”Œë«í¼ì…ë‹ˆë‹¤.

---

## ğŸš€ ë¹ ë¥¸ ì‹œì‘

1. **ì‹œë®¬ë ˆì´ì…˜ ë¶„ì„** íƒ­ í´ë¦­
2. ì¢Œì¸¡ ì‚¬ì´ë“œë°” **"íŒŒì¼ ì„ íƒ"** ë²„íŠ¼ í´ë¦­
3. GitHub CSV íŒŒì¼ ì„ íƒ
4. 3D ì‹œë®¬ë ˆì´ì…˜ ìë™ ì‹œì‘

---

## ğŸ¯ ì£¼ìš” ê¸°ëŠ¥

- **3D ì‹œê°í™”**: í”Œë ˆì´ì–´ ìœ„ì¹˜, í‚¬ ì´ë²¤íŠ¸, ì´ë™ ê²½ë¡œ
- **ì¸í„°ë™í‹°ë¸Œ ì»¨íŠ¸ë¡¤**: ì¹´ë©”ë¼ íšŒì „/ì¤Œ, ì¬ìƒ/ì¼ì‹œì •ì§€, ì†ë„ ì¡°ì ˆ
- **í”Œë ˆì´ì–´ ì¶”ì **: Follow ëª¨ë“œ, K/D Ratio, ì‹œì  ì´ë™
- **Aim Trace**: ì¡°ì¤€ ê¶¤ì  ì‹œê°í™”, ì—ì„ë´‡ íƒì§€

---

## ğŸ® ì»¨íŠ¸ë¡¤

| ì…ë ¥ | ë™ì‘ |
|------|------|
| ë§ˆìš°ìŠ¤ ë“œë˜ê·¸ | ì¹´ë©”ë¼ íšŒì „ |
| ë§ˆìš°ìŠ¤ íœ  | ì¤Œ ì¸/ì•„ì›ƒ |
| ì¬ìƒ ë²„íŠ¼ | ì‹œì‘/ì¼ì‹œì •ì§€ |
| íƒ€ì„ë¼ì¸ í´ë¦­ | ì‹œì  ì´ë™ |
| ì†ë„ ë²„íŠ¼ | 0.5x ~ 3x |

---

## ğŸ”§ ê¸°ìˆ  ìŠ¤íƒ

Three.js Â· PapaParse Â· ìˆœìˆ˜ JavaScript`,
                    en: `A web platform for 3D simulation and analysis of FPS combat engagement situations.

---

## ğŸš€ Quick Start

1. Click **3D Simulation Analysis** tab
2. Click **"Select File"** button in the left sidebar
3. Select GitHub CSV file
4. 3D simulation starts automatically

---

## ğŸ¯ Key Features

- **3D Visualization**: Player positions, kill events, movement paths
- **Interactive Controls**: Camera rotation/zoom, play/pause, speed adjustment
- **Player Tracking**: Follow mode, K/D Ratio, viewpoint movement
- **Aim Trace**: Aim trajectory visualization, aimbot detection

---

## ğŸ® Controls

| Input | Action |
|------|------|
| Mouse Drag | Camera Rotation |
| Mouse Wheel | Zoom In/Out |
| Play Button | Start/Pause |
| Timeline Click | Seek Position |
| Speed Button | 0.5x ~ 3x |

---

## ğŸ”§ Tech Stack

Three.js Â· PapaParse Â· Pure JavaScript`
                };
                
                const readmeContent = readmeContents[this.language] || readmeContents.ko;

                // ê°„ë‹¨í•œ ë§ˆí¬ë‹¤ìš´ íŒŒì„œ (ê¸°ë³¸ì ì¸ ë³€í™˜)
                try {
                    if (typeof this.markdownToHTML === 'function') {
                        content.innerHTML = brandHeader + this.markdownToHTML(readmeContent);
                    } else {
                        // markdownToHTMLì´ ì •ì˜ë˜ì§€ ì•Šì€ ê²½ìš° ê¸°ë³¸ HTMLë¡œ ë³€í™˜
                        console.error('markdownToHTML í•¨ìˆ˜ê°€ ì •ì˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                        content.innerHTML = brandHeader + '<pre style="white-space: pre-wrap; color: #fff;">' + readmeContent + '</pre>';
                    }
                } catch (e) {
                    console.error('renderDashboard ì—ëŸ¬:', e);
                    content.innerHTML = brandHeader + '<pre style="white-space: pre-wrap; color: #fff;">' + readmeContent + '</pre>';
                }
            }

            markdownToHTML(markdown) {
                let html = markdown;
                
                // í—¤ë”ì— ID ì¶”ê°€ë¥¼ ìœ„í•œ í—¬í¼ í•¨ìˆ˜
                const createId = (text) => {
                    return text.toLowerCase()
                        .replace(/[^\w\u3131-\u318E\uAC00-\uD7A3]+/g, '-')
                        .replace(/^-+|-+$/g, '');
                };
                
                // ë§í¬ ë³€í™˜ (í—¤ë” ë³€í™˜ ì „ì— ì²˜ë¦¬)
                html = html.replace(/\[([^\]]+)\]\(#([^\)]+)\)/g, (match, text, anchor) => {
                    return `<a href="#${anchor}" style="color: #4a90e2; text-decoration: none; border-bottom: 1px solid #4a90e2;">${text}</a>`;
                });
                
                // í—¤ë” ë³€í™˜ (ID í¬í•¨) - ìˆœì„œ ì¤‘ìš”: h4 -> h3 -> h2 -> h1
                html = html.replace(/^#### (.*$)/gim, (match, text) => {
                    const id = createId(text);
                    return `<h4 id="${id}">${text}</h4>`;
                });
                html = html.replace(/^### (.*$)/gim, (match, text) => {
                    const id = createId(text);
                    return `<h3 id="${id}">${text}</h3>`;
                });
                html = html.replace(/^## (.*$)/gim, (match, text) => {
                    const id = createId(text);
                    return `<h2 id="${id}">${text}</h2>`;
                });
                html = html.replace(/^# (.*$)/gim, (match, text) => {
                    const id = createId(text);
                    return `<h1 id="${id}">${text}</h1>`;
                });
                
                // ë³¼ë“œì²´ ë³€í™˜ (**í…ìŠ¤íŠ¸**)
                html = html.replace(/\*\*([^\*]+)\*\*/g, '<strong>$1</strong>');
                
                // ì½”ë“œ ë¸”ë¡
                html = html.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>');
                html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
                
                // ë¦¬ìŠ¤íŠ¸ ì²˜ë¦¬ - ë” ì•ˆì •ì ì¸ ë°©ë²•
                const lines = html.split('\n');
                let inList = false;
                let result = [];
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const trimmed = line.trim();
                    
                    if (trimmed.startsWith('- ')) {
                        // ë¦¬ìŠ¤íŠ¸ í•­ëª©
                        if (!inList) {
                            result.push('<ul>');
                            inList = true;
                        }
                        result.push('<li>' + trimmed.substring(2).trim() + '</li>');
                    } else {
                        // ë¦¬ìŠ¤íŠ¸ ì¢…ë£Œ
                        if (inList) {
                            result.push('</ul>');
                            inList = false;
                        }
                        // ë¹ˆ ì¤„ì´ ì•„ë‹ˆë©´ ì¶”ê°€
                        if (trimmed || i === 0 || i === lines.length - 1) {
                            result.push(line);
                        }
                    }
                }
                
                // ë§ˆì§€ë§‰ì— ì—´ë¦° ë¦¬ìŠ¤íŠ¸ ë‹«ê¸°
                if (inList) {
                    result.push('</ul>');
                }
                
                html = result.join('\n');
                
                // í…Œì´ë¸” (ê°„ë‹¨í•œ ì²˜ë¦¬)
                html = html.replace(/\|(.+)\|/g, (match) => {
                    const cells = match.split('|').filter(c => c.trim());
                    if (cells.length > 0) {
                        return '<tr>' + cells.map(c => '<td>' + c.trim() + '</td>').join('') + '</tr>';
                    }
                    return match;
                });
                
                // ë¦¬ìŠ¤íŠ¸ í•­ëª© ì‚¬ì´ì˜ ì¤„ë°”ê¿ˆ ì œê±° (ë¦¬ìŠ¤íŠ¸ ë‚´ë¶€ <br> ì œê±°)
                html = html.replace(/<\/li>\s*<br>\s*<li>/gi, '</li><li>');
                html = html.replace(/<ul>\s*<br>/gi, '<ul>');
                html = html.replace(/<br>\s*<\/ul>/gi, '</ul>');
                
                // ë‹¨ë½
                html = html.replace(/\n\n/g, '</p><p>');
                html = '<p>' + html + '</p>';
                
                // ì¤„ë°”ê¿ˆ (ë¦¬ìŠ¤íŠ¸ ë‚´ë¶€ëŠ” ì´ë¯¸ ì²˜ë¦¬ë¨)
                html = html.replace(/\n/g, '<br>');
                
                // ì•µì»¤ ë§í¬ í´ë¦­ ì‹œ Dashboardë¡œ ì´ë™í•˜ê³  ë¶€ë“œëŸ¬ìš´ ìŠ¤í¬ë¡¤
                setTimeout(() => {
                    document.querySelectorAll('#dashboard-content a[href^="#"]').forEach(link => {
                        link.addEventListener('click', (e) => {
                            e.preventDefault();
                            
                            // Dashboardê°€ ì—´ë ¤ìˆì§€ ì•Šìœ¼ë©´ Dashboardë¡œ ì´ë™
                            const dashboardView = document.getElementById('dashboard-view');
                            const container = document.getElementById('container');
                            if (dashboardView && !dashboardView.classList.contains('active')) {
                                // Info íƒ­ í™œì„±í™”
                                document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                                document.querySelectorAll('.nav-item').forEach(n => {
                                    if (n.textContent.trim() === 'Info') n.classList.add('active');
                                });
                                
                                // Dashboard ë·° í‘œì‹œ
                                if (container) {
                                    container.style.display = 'none';
                                }
                                dashboardView.classList.add('active');
                                
                                // í•˜ë‹¨ íŒ¨ë„ ìˆ¨ê¸°ê¸°
                                const bottomPanel = document.getElementById('bottom-panel');
                                if (bottomPanel) {
                                    bottomPanel.style.display = 'none';
                                }
                            }
                            
                            // í•´ë‹¹ ì„¹ì…˜ìœ¼ë¡œ ìŠ¤í¬ë¡¤
                            const targetId = link.getAttribute('href').substring(1);
                            setTimeout(() => {
                                const targetElement = document.getElementById(targetId);
                                if (targetElement) {
                                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                }
                            }, dashboardView && !dashboardView.classList.contains('active') ? 200 : 0);
                        });
                    });
                }, 100);
                
                return html;
            }

            async showCSVPopup() {
                const popup = document.getElementById('csv-popup');
                const fileList = document.getElementById('csv-file-list');
                const loading = document.getElementById('csv-loading');
                
                if (!popup || !fileList) return;
                
                popup.classList.add('active');
                fileList.innerHTML = '';
                loading.style.display = 'block';
                
                try {
                    // GitHub APIë¡œ CSV íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                    const repo = 'bangilhan/tt_combat_simulation_data';
                    const apiUrl = `https://api.github.com/repos/${repo}/contents`;
                    console.log('GitHub API í˜¸ì¶œ:', apiUrl);
                    
                    const response = await fetch(apiUrl);
                    
                    // ì‘ë‹µ ìƒíƒœ í™•ì¸
                    if (!response.ok) {
                        if (response.status === 404) {
                            loading.style.display = 'none';
                            fileList.innerHTML = `
                                <li style="color: #ff6b6b; padding: 10px;">
                                    <strong>Repositoryë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</strong><br>
                                    <small style="color: #8a8fa5;">
                                        Repository ì´ë¦„: ${repo}<br>
                                        í™•ì¸ ì‚¬í•­:<br>
                                        1. Repositoryê°€ ìƒì„±ë˜ì—ˆëŠ”ì§€ í™•ì¸<br>
                                        2. Repository ì´ë¦„ì´ ì •í™•í•œì§€ í™•ì¸<br>
                                        3. Repositoryê°€ Publicì¸ì§€ í™•ì¸ (Privateì€ ì¸ì¦ í•„ìš”)
                                    </small>
                                </li>
                            `;
                            console.error('Repositoryë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ:', response.status, response.statusText);
                            return;
                        } else if (response.status === 403) {
                            loading.style.display = 'none';
                            fileList.innerHTML = `
                                <li style="color: #ff6b6b; padding: 10px;">
                                    <strong>ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.</strong><br>
                                    <small style="color: #8a8fa5;">
                                        Repositoryê°€ Privateì´ê±°ë‚˜ API rate limitì— ë„ë‹¬í–ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                                    </small>
                                </li>
                            `;
                            console.error('ì ‘ê·¼ ê¶Œí•œ ì—†ìŒ:', response.status, response.statusText);
                            return;
                        } else {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                    }
                    
                    const files = await response.json();
                    console.log('GitHub API ì‘ë‹µ:', files);
                    
                    // ì‘ë‹µì´ ë°°ì—´ì´ ì•„ë‹Œ ê²½ìš° (ì—ëŸ¬ ë©”ì‹œì§€ ë“±)
                    if (!Array.isArray(files)) {
                        loading.style.display = 'none';
                        fileList.innerHTML = `
                            <li style="color: #ff6b6b; padding: 10px;">
                                <strong>ì˜ˆìƒì¹˜ ëª»í•œ ì‘ë‹µ:</strong><br>
                                <small style="color: #8a8fa5;">${JSON.stringify(files)}</small>
                            </li>
                        `;
                        console.error('ì˜ˆìƒì¹˜ ëª»í•œ ì‘ë‹µ í˜•ì‹:', files);
                        return;
                    }
                    
                    // CSV íŒŒì¼ë§Œ í•„í„°ë§
                    let csvFiles = files.filter(file => 
                        file.type === 'file' && file.name.endsWith('.csv')
                    );
                    
                    // tt_aimbot_detection_data.csvë¥¼ ìš°ì„ ìˆœìœ„ë¡œ ì •ë ¬
                    csvFiles.sort((a, b) => {
                        const aIsMain = a.name.includes('tt_aimbot_detection_data');
                        const bIsMain = b.name.includes('tt_aimbot_detection_data');
                        if (aIsMain && !bIsMain) return -1;
                        if (!aIsMain && bIsMain) return 1;
                        // sample íŒŒì¼ì€ ë’¤ë¡œ
                        const aIsSample = a.name.includes('sample');
                        const bIsSample = b.name.includes('sample');
                        if (aIsSample && !bIsSample) return 1;
                        if (!aIsSample && bIsSample) return -1;
                        return a.name.localeCompare(b.name);
                    });
                    
                    console.log('CSV íŒŒì¼ ìˆ˜:', csvFiles.length);
                    console.log('ì •ë ¬ëœ íŒŒì¼ ëª©ë¡:', csvFiles.map(f => f.name));
                    
                    loading.style.display = 'none';
                    
                    if (csvFiles.length === 0) {
                        if (files.length === 0) {
                            fileList.innerHTML = `
                                <li style="color: #8a8fa5; padding: 10px;">
                                    Repositoryê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.<br>
                                    <small>CSV íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.</small>
                                </li>
                            `;
                        } else {
                            fileList.innerHTML = `
                                <li style="color: #8a8fa5; padding: 10px;">
                                    CSV íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.<br>
                                    <small>Repositoryì— ${files.length}ê°œì˜ íŒŒì¼ì´ ìˆì§€ë§Œ CSV íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.</small>
                                </li>
                            `;
                        }
                        return;
                    }
                    
                    // ë‹¨ì¼ íŒŒì¼ ì„ íƒ (ë¼ë””ì˜¤ ë²„íŠ¼ ì‚¬ìš©)
                    this.selectedCSVFile = null;
                    
                    csvFiles.forEach(file => {
                        const li = document.createElement('li');
                        li.style.display = 'flex';
                        li.style.alignItems = 'center';
                        li.style.gap = '10px';
                        li.style.padding = '8px';
                        li.style.cursor = 'pointer';
                        li.style.borderRadius = '4px';
                        li.addEventListener('mouseenter', () => {
                            li.style.background = '#2a2f3e';
                        });
                        li.addEventListener('mouseleave', () => {
                            li.style.background = 'transparent';
                        });
                        
                        const radio = document.createElement('input');
                        radio.type = 'radio';
                        radio.name = 'csv-file-select';
                        radio.value = file.download_url;
                        radio.dataset.filename = file.name;
                        radio.style.cursor = 'pointer';
                        radio.addEventListener('change', (e) => {
                            if (e.target.checked) {
                                this.selectedCSVFile = file.download_url;
                            }
                        });
                        
                        const label = document.createElement('label');
                        label.textContent = file.name;
                        label.style.cursor = 'pointer';
                        label.style.flex = '1';
                        label.addEventListener('click', (e) => {
                            e.preventDefault();
                            radio.checked = true;
                            radio.dispatchEvent(new Event('change'));
                        });
                        
                        li.appendChild(radio);
                        li.appendChild(label);
                        fileList.appendChild(li);
                    });
                    
                    // ì„ íƒí•œ íŒŒì¼ ë¡œë“œ ë²„íŠ¼ ì´ë²¤íŠ¸
                    const loadBtn = document.getElementById('csv-load-selected');
                    if (loadBtn) {
                        loadBtn.onclick = () => {
                            if (!this.selectedCSVFile) {
                                alert('íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                                return;
                            }
                            this.loadSingleCSVFile(this.selectedCSVFile);
                            popup.classList.remove('active');
                        };
                    }
                } catch (error) {
                    console.error('GitHub íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨:', error);
                    loading.style.display = 'none';
                    fileList.innerHTML = `
                        <li style="color: #ff6b6b; padding: 10px;">
                            <strong>ì˜¤ë¥˜ ë°œìƒ:</strong><br>
                            <small style="color: #8a8fa5;">${error.message || error}</small><br>
                            <small style="color: #8a8fa5; margin-top: 5px; display: block;">
                                ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ í™•ì¸í•˜ê±°ë‚˜ ë¸Œë¼ìš°ì € ì½˜ì†”ì„ í™•ì¸í•´ì£¼ì„¸ìš”.
                            </small>
                        </li>
                    `;
                }
            }
            
            async loadSingleCSVFile(fileUrl) {
                const loading = document.getElementById('loading');
                const selectedFile = document.getElementById('selected-file');
                
                if (!fileUrl) {
                    alert('íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                    return;
                }
                
                if (loading) {
                    loading.style.display = 'block';
                    loading.innerHTML = 'GitHubì—ì„œ CSV íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì¤‘...';
                }
                
                try {
                    const response = await fetch(fileUrl);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const text = await response.text();
                    const filename = fileUrl.split('/').pop() || 'unknown.csv';
                    const blob = new Blob([text], { type: 'text/csv' });
                    const file = new File([blob], filename, { type: 'text/csv' });
                    
                    if (selectedFile) {
                        selectedFile.textContent = filename;
                    }
                    
                    await this.loadCSV(file);
                } catch (error) {
                    console.error('CSV íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨:', error);
                    if (loading) {
                        loading.innerHTML = 'ì˜¤ë¥˜: ' + error.message;
                    }
                    alert('CSV íŒŒì¼ì„ ë‹¤ìš´ë¡œë“œí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                }
            }
            
            async loadMultipleCSVFiles() {
                const loading = document.getElementById('loading');
                const selectedFile = document.getElementById('selected-file');
                
                if (!this.selectedCSVFiles || this.selectedCSVFiles.size === 0) {
                    alert('íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                    return;
                }
                
                const fileUrls = Array.from(this.selectedCSVFiles);
                const fileCount = fileUrls.length;
                
                if (loading) {
                    loading.style.display = 'block';
                    loading.innerHTML = `GitHubì—ì„œ ${fileCount}ê°œ CSV íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì¤‘...`;
                }
                
                if (selectedFile) {
                    selectedFile.textContent = `${fileCount}ê°œ íŒŒì¼ ì„ íƒë¨`;
                }
                
                try {
                    // ë‹¨ì¼ íŒŒì¼ì¸ ê²½ìš° ë³‘í•© ì—†ì´ ì§ì ‘ ë¡œë“œ
                    if (fileCount === 1) {
                        const url = fileUrls[0];
                        const response = await fetch(url);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const text = await response.text();
                        const filename = url.split('/').pop() || 'unknown.csv';
                        const blob = new Blob([text], { type: 'text/csv' });
                        const file = new File([blob], filename, { type: 'text/csv' });
                        
                        await this.loadCSV(file);
                        return;
                    }
                    
                    // ì—¬ëŸ¬ íŒŒì¼ì¸ ê²½ìš°ì—ë§Œ ë³‘í•©
                    // ëª¨ë“  íŒŒì¼ì„ ë³‘ë ¬ë¡œ ë‹¤ìš´ë¡œë“œ
                    const filePromises = fileUrls.map(async (url) => {
                        const response = await fetch(url);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const text = await response.text();
                        const filename = url.split('/').pop() || 'unknown.csv';
                        const blob = new Blob([text], { type: 'text/csv' });
                        return new File([blob], filename, { type: 'text/csv' });
                    });
                    
                    const files = await Promise.all(filePromises);
                    
                    // ëª¨ë“  íŒŒì¼ì˜ ë°ì´í„°ë¥¼ ë³‘í•©
                    await this.loadAndMergeMultipleCSV(files);
                } catch (error) {
                    console.error('CSV íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨:', error);
                    if (loading) {
                        loading.innerHTML = 'ì˜¤ë¥˜: ' + error.message;
                    }
                    alert('CSV íŒŒì¼ì„ ë‹¤ìš´ë¡œë“œí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                }
            }
            
            async loadAndMergeMultipleCSV(files) {
                const loading = document.getElementById('loading');
                const allRows = [];
                
                try {
                    // ëª¨ë“  íŒŒì¼ì„ ìˆœì°¨ì ìœ¼ë¡œ íŒŒì‹±
                    for (let i = 0; i < files.length; i++) {
                        if (loading) {
                            loading.innerHTML = `íŒŒì¼ íŒŒì‹± ì¤‘... (${i + 1}/${files.length})`;
                        }
                        
                        const file = files[i];
                        const rows = await new Promise((resolve, reject) => {
                            Papa.parse(file, {
                                header: true,
                                skipEmptyLines: true,
                                complete: (results) => {
                                    resolve(results.data);
                                },
                                error: (error) => {
                                    reject(error);
                                }
                            });
                        });
                        
                        // ìŠ¤í”„ë ˆë“œ ì—°ì‚°ì ëŒ€ì‹  ì§ì ‘ ë£¨í”„ë¡œ ì¶”ê°€ (ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš° ë°©ì§€)
                        for (let j = 0; j < rows.length; j++) {
                            allRows.push(rows[j]);
                        }
                    }
                    
                    if (loading) {
                        loading.innerHTML = 'ë°ì´í„° ë³‘í•© ë° ì²˜ë¦¬ ì¤‘...';
                    }
                    
                    // ëª¨ë“  ë°ì´í„°ë¥¼ ë³‘í•©í•˜ì—¬ ì²˜ë¦¬
                    await this.processData(allRows);
                } catch (error) {
                    console.error('CSV íŒŒì¼ ë³‘í•© ì‹¤íŒ¨:', error);
                    if (loading) {
                        loading.innerHTML = 'ì˜¤ë¥˜: ' + error.message;
                    }
                    alert('CSV íŒŒì¼ì„ ì²˜ë¦¬í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                }
            }

            async loadCSVFromGitHub(url, filename) {
                const loading = document.getElementById('loading');
                const selectedFile = document.getElementById('selected-file');
                
                if (loading) {
                    loading.style.display = 'block';
                    loading.innerHTML = 'GitHubì—ì„œ CSV íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì¤‘...';
                }
                
                if (selectedFile) {
                    selectedFile.textContent = filename;
                }
                
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const text = await response.text();
                    
                    // í…ìŠ¤íŠ¸ë¥¼ Blobìœ¼ë¡œ ë³€í™˜í•˜ì—¬ File ê°ì²´ì²˜ëŸ¼ ì‚¬ìš©
                    const blob = new Blob([text], { type: 'text/csv' });
                    const file = new File([blob], filename, { type: 'text/csv' });
                    
                    await this.loadCSV(file);
                } catch (error) {
                    console.error('CSV íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨:', error);
                    if (loading) {
                        loading.innerHTML = 'ì˜¤ë¥˜: ' + error.message;
                    }
                    alert('CSV íŒŒì¼ì„ ë‹¤ìš´ë¡œë“œí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                }
            }

            setupTabs() {
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        // íƒ­ ì „í™˜
                        const tab = btn.getAttribute('data-tab');
                        const eventLog = document.getElementById('event-log');
                        
                        if (tab === 'aim') {
                            // Aim Trace íƒ­: ì„¸ë¡œ ë ˆì´ì•„ì›ƒ
                            if (eventLog) {
                                eventLog.classList.remove('action-stream');
                                eventLog.classList.add('aim-trace');
                            }
                            this.renderAimTrace();
                            // Aim Trace ì„¹ì…˜ì´ ë³´ì´ë„ë¡ ìë™ ìŠ¤í¬ë¡¤
                            setTimeout(() => {
                                if (eventLog) {
                                    eventLog.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                                }
                            }, 100);
                        } else if (tab === 'actions') {
                            // Action Stream íƒ­: ì„¸ë¡œ ë ˆì´ì•„ì›ƒ
                            if (eventLog) {
                                eventLog.classList.remove('aim-trace');
                                eventLog.classList.add('action-stream');
                            }
                            this.updateEventLog();
                        }
                    });
                });

                // í¬ì»¤ìŠ¤ ëª¨ë“œ ì¢…ë£Œ ë²„íŠ¼
                document.getElementById('exit-focus-btn').addEventListener('click', () => {
                    this.exitFocusMode();
                });
                
                // ë³´ê³ ì„œ ìƒì„± íƒ­
                document.getElementById('report-tab').addEventListener('click', () => {
                    // í¬ì»¤ìŠ¤ ëª¨ë“œ í”Œë ˆì´ì–´ë¥¼ ìµœìš°ì„ ìœ¼ë¡œ ì‚¬ìš©
                    const playerName = this.focusPlayerId || this.selectedPlayer || 
                                    (this.selectedEvent && this.selectedEvent.attacker && this.selectedEvent.attacker.name) || 
                                    ((this.data && this.data.metadata && this.data.metadata.players && this.data.metadata.players[0]) || null);
                    console.log('[Report] í”Œë ˆì´ì–´ ì„ íƒ:', {
                        focusPlayerId: this.focusPlayerId,
                        selectedPlayer: this.selectedPlayer,
                        selectedEventAttacker: this.selectedEvent?.attacker?.name,
                        firstPlayer: this.data?.metadata?.players?.[0],
                        finalPlayerName: playerName
                    });
                    if (playerName) {
                        this.generateReport(playerName);
                    } else {
                        alert(this.language === 'ko' ? 'ë¨¼ì € í”Œë ˆì´ì–´ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”' : 'Please select a player first');
                    }
                });
                
                // ì–¸ì–´ ì „í™˜ ë²„íŠ¼
                document.getElementById('lang-toggle').addEventListener('click', () => {
                    this.language = this.language === 'ko' ? 'en' : 'ko';
                    this.updateLanguage();
                });
                
                // ì–¸ì–´ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
                this.updateLanguage = () => {
                    const langToggle = document.getElementById('lang-toggle');
                    langToggle.textContent = this.language === 'ko' ? 'ğŸŒ EN' : 'ğŸŒ KO';
                    
                    // UI í…ìŠ¤íŠ¸ ì •ì˜
                    const uiTexts = {
                        ko: {
                            navInfo: 'Info',
                            navSimulation: 'ì‹œë®¬ë ˆì´ì…˜ ë¶„ì„',
                            navReport: 'ë¶„ì„ ë³´ê³ ì„œ',
                            fileLoad: 'íŒŒì¼ ë¡œë“œ',
                            selectFile: 'íŒŒì¼ ì„ íƒ',
                            noFileSelected: 'ì„ íƒëœ íŒŒì¼ ì—†ìŒ',
                            processing: 'CSV íŒŒì¼ ì²˜ë¦¬ ì¤‘...',
                            statistics: 'í†µê³„',
                            title: 'ì œëª©',
                            name: 'ì´ë¦„',
                            game: 'ê²Œì„',
                            server: 'ì„œë²„',
                            gameMode: 'ê²Œì„ ëª¨ë“œ',
                            startTime: 'ì‹œì‘ ì‹œê°„',
                            length: 'ê¸¸ì´',
                            players: 'í”Œë ˆì´ì–´',
                            match: 'ë§¤ì¹˜',
                            matchStartTime: 'ë§¤ì¹˜ ì‹œì‘ ì‹œê°„',
                            matchLength: 'ë§¤ì¹˜ ê¸¸ì´',
                            matchMode: 'ë§¤ì¹˜ ëª¨ë“œ',
                            mapName: 'ë§µ ì´ë¦„',
                            totalEvents: 'ì´ ì´ë²¤íŠ¸',
                            mapBounds: 'ë§µ ê²½ê³„',
                            calculating: 'ê³„ì‚° ì¤‘...',
                            mapRendering: 'ë§µ ë Œë”ë§ ì •ë³´',
                            currentMap: 'í˜„ì¬ ë§µ',
                            note: 'ì°¸ê³ ',
                            mapGeometry: 'ë§µ ì§€ì˜¤ë©”íŠ¸ë¦¬',
                            mapApi: 'ì™¸ë¶€ ë§µ ë°ì´í„°',
                            kdRatio: 'K/D ë¹„ìœ¨',
                            kdDesc: 'K/D: í‚¬ / ë°ìŠ¤ - í´ë¦­í•˜ì—¬ í•„í„°ë§',
                            killEvents: 'í‚¬ ì´ë²¤íŠ¸ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤',
                            go: 'ì´ë™',
                            resetView: 'ë·° ì´ˆê¸°í™”',
                            prev: 'ì´ì „',
                            next: 'ë‹¤ìŒ',
                            follow: 'ë”°ë¼ê°€ê¸°',
                            focusMode: 'í¬ì»¤ìŠ¤ ëª¨ë“œ: ì´ë²¤íŠ¸ ì„ íƒë¨',
                            exitFocus: 'í¬ì»¤ìŠ¤ ëª¨ë“œ ì¢…ë£Œ',
                            actionStream: 'ì•¡ì…˜ ìŠ¤íŠ¸ë¦¼',
                            aimTrace: 'ì—ì„ íŠ¸ë ˆì´ìŠ¤'
                        },
                        en: {
                            navInfo: 'Info',
                            navSimulation: '3D Simulation Analysis',
                            navReport: 'Analysis Report',
                            fileLoad: 'File Load',
                            selectFile: 'Select File',
                            noFileSelected: 'No file selected',
                            processing: 'Processing CSV file...',
                            statistics: 'Statistics',
                            title: 'Title',
                            name: 'Name',
                            game: 'Game',
                            server: 'Server',
                            gameMode: 'Game Mode',
                            startTime: 'Start Time',
                            length: 'Length',
                            players: 'Players',
                            match: 'Match',
                            matchStartTime: 'Match Start Time',
                            matchLength: 'Match Length',
                            matchMode: 'Match Mode',
                            mapName: 'Map Name',
                            totalEvents: 'Total Events',
                            mapBounds: 'Map Bounds',
                            calculating: 'Calculating...',
                            mapRendering: 'Map Rendering Info',
                            currentMap: 'Current Map',
                            note: 'Note',
                            mapGeometry: 'Map Geometry',
                            mapApi: 'External Map Data',
                            kdRatio: 'K/D Ratio',
                            kdDesc: 'K/D: Kills / Deaths - Click to filter',
                            killEvents: 'Kill events will appear here',
                            go: 'Go',
                            resetView: 'Reset View',
                            prev: 'Prev',
                            next: 'Next',
                            follow: 'Follow',
                            focusMode: 'Focus Mode: Event selected',
                            exitFocus: 'Exit Focus Mode',
                            actionStream: 'Action Stream',
                            aimTrace: 'Aim Trace'
                        }
                    };
                    
                    const t = uiTexts[this.language];
                    
                    // ë„¤ë¹„ê²Œì´ì…˜ ë©”ë‰´ ì—…ë°ì´íŠ¸
                    const navItems = document.querySelectorAll('.nav-item');
                    navItems.forEach(item => {
                        const text = item.textContent.trim();
                        if (text.includes('Info') || item.classList.contains('active') && item.previousElementSibling && item.previousElementSibling.id === 'brand-logo') {
                            // InfoëŠ” ê·¸ëŒ€ë¡œ
                        } else if (text.includes('3D') || text.includes('ì‹œë®¬ë ˆì´ì…˜')) {
                            item.textContent = t.navSimulation;
                        } else if (text.includes('ë¶„ì„ ë³´ê³ ì„œ') || text.includes('Analysis Report')) {
                            item.textContent = t.navReport;
                        }
                    });
                    
                    // ì‚¬ì´ë“œë°” ì—…ë°ì´íŠ¸
                    const sidebarSections = document.querySelectorAll('.sidebar-section h3');
                    sidebarSections.forEach(h3 => {
                        if (h3.textContent.includes('File Load') || h3.textContent.includes('íŒŒì¼ ë¡œë“œ')) {
                            h3.textContent = t.fileLoad;
                        } else if (h3.textContent.includes('Statistics') || h3.textContent.includes('í†µê³„')) {
                            h3.textContent = t.statistics;
                        }
                    });
                    
                    // íŒŒì¼ ì„ íƒ ë²„íŠ¼
                    const selectBtn = document.getElementById('select-csv-btn');
                    if (selectBtn) selectBtn.textContent = t.selectFile;
                    
                    // ì„ íƒëœ íŒŒì¼ ì—†ìŒ
                    const selectedFile = document.getElementById('selected-file');
                    if (selectedFile && selectedFile.textContent.includes('ì„ íƒëœ íŒŒì¼ ì—†ìŒ') || selectedFile.textContent.includes('No file selected')) {
                        if (selectedFile.textContent === 'ì„ íƒëœ íŒŒì¼ ì—†ìŒ' || selectedFile.textContent === 'No file selected') {
                            selectedFile.textContent = t.noFileSelected;
                        }
                    }
                    
                    // ì²˜ë¦¬ ì¤‘
                    const loading = document.getElementById('loading');
                    if (loading) loading.textContent = t.processing;
                    
                    // Statistics ì„¹ì…˜ ì—…ë°ì´íŠ¸
                    const statLabels = document.querySelectorAll('.stat-label');
                    statLabels.forEach(label => {
                        const text = label.textContent.trim();
                        if (text.includes('Name:')) label.textContent = t.name + ':';
                        else if (text.includes('Server:')) label.textContent = t.server + ':';
                        else if (text.includes('Game Mode:')) label.textContent = t.gameMode + ':';
                        else if (text.includes('Start time:')) label.textContent = t.startTime + ':';
                        else if (text.includes('Length:')) label.textContent = t.length + ':';
                        else if (text.includes('Players:')) label.textContent = t.players + ':';
                        else if (text.includes('Match Start Time:')) label.textContent = t.matchStartTime + ':';
                        else if (text.includes('Match Length:')) label.textContent = t.matchLength + ':';
                        else if (text.includes('Match Mode:')) label.textContent = t.matchMode + ':';
                        else if (text.includes('Map Name:')) label.textContent = t.mapName + ':';
                        else if (text.includes('Total Events:')) label.textContent = t.totalEvents + ':';
                    });
                    
                    const statTitles = document.querySelectorAll('.stat-group-title');
                    statTitles.forEach(title => {
                        const text = title.textContent.trim();
                        if (text.includes('Title')) title.textContent = t.title;
                        else if (text.includes('Game')) title.textContent = t.game;
                        else if (text.includes('Match')) title.textContent = t.match;
                        else if (text.includes('Players') || text.includes('K/D')) title.textContent = t.players + ' (' + t.kdRatio + ')';
                        else if (text.includes('Map Bounds') || text.includes('ë§µ ê²½ê³„')) title.textContent = t.mapBounds;
                    });
                    
                    // K/D ì„¤ëª…
                    const kdDesc = document.querySelector('.stat-group-title')?.nextElementSibling;
                    if (kdDesc && kdDesc.style && (kdDesc.textContent.includes('K/D') || kdDesc.textContent.includes('í‚¬'))) {
                        kdDesc.textContent = t.kdDesc;
                    }
                    
                    // ë§µ ì •ë³´ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
                    const mapRenderingLabel = document.getElementById('map-rendering-label');
                    if (mapRenderingLabel) {
                        mapRenderingLabel.textContent = t.mapRendering + ':';
                    }
                    
                    const currentMapText = document.getElementById('current-map-text');
                    const detectedMapNameElement = document.getElementById('detected-map-name');
                    if (currentMapText && detectedMapNameElement) {
                        const mapName = this.data?.metadata?.mapName || this.detectedMapName || 'Unknown';
                        const source = this.detectedMapName ? (this.language === 'ko' ? '(ìœ„ì¹˜ ê¸°ë°˜ ì¶”ë¡ )' : '(Location-based inference)') : 
                                      (this.language === 'ko' ? '(ë°ì´í„° ê¸°ë°˜)' : '(Data-based)');
                        currentMapText.innerHTML = t.currentMap + ': <span id="detected-map-name">' + mapName + ' ' + source + '</span>';
                    } else if (currentMapText) {
                        // fallback
                        const mapName = this.data?.metadata?.mapName || this.detectedMapName || 'Unknown';
                        currentMapText.textContent = t.currentMap + ': ' + mapName;
                    }
                    
                    const mapGeometryText = document.getElementById('map-geometry-text');
                    if (mapGeometryText) {
                        if (this.language === 'ko') {
                            mapGeometryText.textContent = 'ë§µ ì§€ì˜¤ë©”íŠ¸ë¦¬ ë°ì´í„°ëŠ” CS2 ê²Œì„ íŒŒì¼(.bsp)ì—ì„œ ì¶”ì¶œí•˜ê±°ë‚˜';
                        } else {
                            mapGeometryText.textContent = 'Map geometry data must be extracted from CS2 game files (.bsp) or';
                        }
                    }
                    
                    const mapApiText = document.getElementById('map-api-text');
                    if (mapApiText) {
                        if (this.language === 'ko') {
                            mapApiText.textContent = 'ì™¸ë¶€ ë§µ ë°ì´í„° APIë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.';
                        } else {
                            mapApiText.textContent = 'use an external map data API.';
                        }
                    }
                    
                    const mapNoteText = document.getElementById('map-note-text');
                    if (mapNoteText) {
                        if (this.language === 'ko') {
                            mapNoteText.textContent = 'ì°¸ê³ : í˜„ì¬ëŠ” í”Œë ˆì´ì–´ ìœ„ì¹˜ ê¸°ë°˜ ê²½ê³„ë§Œ í‘œì‹œë©ë‹ˆë‹¤.';
                        } else {
                            mapNoteText.textContent = 'Note: Currently only player position-based boundaries are displayed.';
                        }
                    }
                    
                    // Map Bounds í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
                    // í”Œë ˆì´ì–´ ì„ íƒ ë“œë¡­ë‹¤ìš´ ì—…ë°ì´íŠ¸
                    const playerSelect = document.getElementById('player-select');
                    if (playerSelect && playerSelect.options[0]) {
                        playerSelect.options[0].text = 'í”Œë ˆì´ì–´ ì„ íƒ (ì´ìƒ êµ¬ê°„ ìˆ˜ / ì´ë²¤íŠ¸ ìˆ˜)';
                    }
                    
                    const resetBtn = document.getElementById('reset-view');
                    if (resetBtn) resetBtn.textContent = t.resetView;
                    
                    const prevBtn = document.getElementById('prev-player-tick');
                    if (prevBtn) prevBtn.textContent = t.prev;
                    
                    const nextBtn = document.getElementById('next-player-tick');
                    if (nextBtn) nextBtn.textContent = t.next;
                    
                    const followBtn = document.getElementById('follow-toggle');
                    if (followBtn) followBtn.textContent = t.follow;
                    
                    const exitFocusBtn = document.getElementById('exit-focus-btn');
                    if (exitFocusBtn) exitFocusBtn.textContent = t.exitFocus;
                    
                    const focusInfo = document.getElementById('focus-info');
                    if (focusInfo) focusInfo.textContent = t.focusMode;
                    
                    // í•˜ë‹¨ íŒ¨ë„ íƒ­ ì—…ë°ì´íŠ¸
                    const tabBtns = document.querySelectorAll('.tab-btn');
                    tabBtns.forEach(btn => {
                        const text = btn.textContent.trim();
                        if (text.includes('Action Stream') || text.includes('ì•¡ì…˜ ìŠ¤íŠ¸ë¦¼')) {
                            btn.textContent = t.actionStream;
                        } else if (text.includes('Aim Trace') || text.includes('ì—ì„ íŠ¸ë ˆì´ìŠ¤')) {
                            btn.textContent = t.aimTrace;
                        }
                    });
                    
                    // Dashboard/Info íƒ­ ë‚´ìš© ì—…ë°ì´íŠ¸
                    if (document.getElementById('dashboard-view') && !document.getElementById('dashboard-view').classList.contains('hidden')) {
                        this.renderDashboard();
                    }
                    
                    // ë³´ê³ ì„œê°€ ì—´ë ¤ìˆìœ¼ë©´ ì–¸ì–´ ë³€ê²½ í›„ ì¬ìƒì„±
                    if (this.currentReportWindow && !this.currentReportWindow.closed) {
                        const playerName = this.selectedPlayer || (this.selectedEvent && this.selectedEvent.attacker && this.selectedEvent.attacker.name) || 
                                        ((this.data && this.data.metadata && this.data.metadata.players && this.data.metadata.players[0]) || null);
                        if (playerName) {
                            this.currentReportWindow.close();
                            // this.generateReport(playerName);
                        }
                    }
                };
            }

            async loadCSV(file) {
                const loading = document.getElementById('loading');
                if (loading) {
                    loading.style.display = 'block';
                    loading.innerHTML = 'Parsing CSV file...';
                }
                
                return new Promise((resolve) => {
                    try {
                        // PapaParse ë¡œë“œ í™•ì¸
                        if (typeof Papa === 'undefined' || !Papa || !Papa.parse) {
                            console.error('PapaParseê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                            if (loading) loading.innerHTML = 'Error: CSV parser not loaded. ë„¤íŠ¸ì›Œí¬ë¥¼ í™•ì¸í•˜ê³  ìƒˆë¡œê³ ì¹¨(Ctrl+F5) í•´ì£¼ì„¸ìš”.';
                            resolve();
                            return;
                        }
                        Papa.parse(file, {
                            header: true,
                            skipEmptyLines: true,
                            complete: async (results) => {
                                console.log('=== CSV íŒŒì‹± ì™„ë£Œ ===');
                                console.log('íŒŒì¼ëª…:', file.name);
                                console.log('íŒŒì¼ í¬ê¸°:', file.size, 'bytes');
                                console.log('ì´ í–‰ ìˆ˜:', results.data.length);
                                console.log('CSV í—¤ë”:', results.meta.fields);
                                
                                // ì²« ë²ˆì§¸ í–‰ ìƒ˜í”Œ ì¶œë ¥
                                if (results.data.length > 0) {
                                    console.log('ì²« ë²ˆì§¸ í–‰ ìƒ˜í”Œ:', results.data[0]);
                                    console.log('ë§ˆì§€ë§‰ í–‰ ìƒ˜í”Œ:', results.data[results.data.length - 1]);
                                }
                                
                                // í•„ìˆ˜ ì»¬ëŸ¼ í™•ì¸ (df_ui ê¸°ì¤€: tick, timestamp, player_id)
                                const requiredFields = ['tick', 'timestamp', 'player_id'];
                                const missingFields = requiredFields.filter(field => !results.meta.fields.includes(field));
                                if (missingFields.length > 0) {
                                    console.warn('âš ï¸ ëˆ„ë½ëœ í•„ìˆ˜ ì»¬ëŸ¼:', missingFields);
                                    console.log('ì‚¬ìš© ê°€ëŠ¥í•œ ì»¬ëŸ¼:', results.meta.fields);
                                } else {
                                    console.log('âœ… í•„ìˆ˜ ì»¬ëŸ¼ ëª¨ë‘ ì¡´ì¬');
                                }
                                
                                if (!results || !results.data || results.data.length === 0) {
                                    console.error('âŒ CSV íŒŒì‹± ê²°ê³¼ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤');
                                    alert('CSV íŒŒì¼ì— ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                                    if (loading) loading.style.display = 'none';
                                    resolve();
                                    return;
                                }
                                
                                if (loading) loading.innerHTML = 'Processing data... 0%';
                                try {
                                    await this.processData(results.data);
                                    console.log('âœ… ë°ì´í„° ì²˜ë¦¬ ì™„ë£Œ');
                                } catch (procError) {
                                    console.error('âŒ processData ì˜¤ë¥˜:', procError);
                                    console.error('ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤:', procError.stack);
                                    alert('ë°ì´í„° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: ' + procError.message);
                                }
                                if (loading) loading.style.display = 'none';
                                resolve();
                            },
                            error: (error) => {
                                console.error('CSV íŒŒì‹± ì˜¤ë¥˜:', error);
                                if (loading) loading.style.display = 'none';
                                alert('CSV íŒŒì¼ì„ ì½ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                                resolve();
                            }
                        });
                    } catch (error) {
                        console.error('loadCSV ì˜¤ë¥˜:', error);
                        if (loading) loading.style.display = 'none';
                        alert('íŒŒì¼ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                        resolve();
                    }
                });
            }

            async processData(rows) {
                try {
                    console.log('=== processData ì‹œì‘ ===');
                    console.log('ì´ í–‰ ìˆ˜:', rows.length);
                    if (!rows || rows.length === 0) {
                        console.error('âŒ ë°ì´í„°ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤');
                        alert('CSV íŒŒì¼ì— ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                        return;
                    }
                    
                    // ì²« ë²ˆì§¸ í–‰ êµ¬ì¡° í™•ì¸
                    if (rows[0]) {
                        console.log('ì²« ë²ˆì§¸ í–‰ í‚¤:', Object.keys(rows[0]));
                        console.log('ì²« ë²ˆì§¸ í–‰ ê°’:', rows[0]);
                    }
                    
                    const positions = [];
                    const events = [];
                    const aimIndex = new Map(); // name -> [{yaw,pitch,time,type}]
                    
                    // match_id ì¶”ì¶œ (ì²« ë²ˆì§¸ í–‰ì—ì„œ)
                    let matchId = null;
                    if (rows.length > 0 && rows[0].match_id !== undefined) {
                        matchId = rows[0].match_id !== null ? String(rows[0].match_id).trim() : null;
                    }
                    
                    // ë‚˜ì¤‘ì— ì¡°ì¸ë  ë°ì´í„°ë¥¼ ì €ì¥í•  ë§µ (player_id -> metadata)
                    // CSVì— ì§ì ‘ í¬í•¨ë˜ì–´ ìˆì„ ìˆ˜ë„ ìˆê³ , ë‚˜ì¤‘ì— ì¡°ì¸ë  ìˆ˜ë„ ìˆìŒ
                    const playerJoinData = new Map(); // player_id -> {team, map, os, input_device, character}
                    // anomaly sequence ì§‘ê³„ìš© (seq_id -> info)
                    const anomalySeqMap = new Map();
                    const anomalyByTick = new Map();
                    const allAnomalyScores = [];
                    
                    // ë§µ ê²½ê³„ ì¶”ì ìš© (ë³„ë„ ë°°ì—´ ì—†ì´ ì§ì ‘ ê³„ì‚°)
                    let minX = Infinity, maxX = -Infinity;
                    let minY = Infinity, maxY = -Infinity;
                    let minZ = Infinity, maxZ = -Infinity;
                    
                    // ì „ì—­ tick ì¬êµ¬ì„±ìš© (df_uiì˜ global_tick ì‚¬ìš©)
                    const tickMap = new Map(); // globalTick -> { tick, game_time, players: [] }
                    let baseTimestampMs = null;
                    
                    const totalRows = rows.length;
                    const chunkSize = 1000; // ì²­í¬ ë‹¨ìœ„ë¡œ ì²˜ë¦¬í•˜ì—¬ UI ì°¨ë‹¨ ë°©ì§€
                    
                    // ì§„í–‰ ìƒí™© í‘œì‹œ
                    const loading = document.getElementById('loading');
                    const updateProgress = (progress) => {
                        if (loading) {
                            loading.style.display = 'block';
                            loading.innerHTML = 'Processing data... ' + Math.round(progress) + '%';
                        }
                    };
                    
                    // ì²­í¬ ë‹¨ìœ„ ì²˜ë¦¬ (ë¹„ë™ê¸°ë¡œ UI ë¸”ë¡œí‚¹ ë°©ì§€)
                    for (let chunkStart = 0; chunkStart < totalRows; chunkStart += chunkSize) {
                        const chunkEnd = Math.min(chunkStart + chunkSize, totalRows);
                        const chunk = rows.slice(chunkStart, chunkEnd);
                        
                        // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
                        updateProgress((chunkStart / totalRows) * 100);
                        
                        // ê° ì²­í¬ë¥¼ ë™ê¸°ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ë˜, í° ì²­í¬ëŠ” ë‚˜ëˆ ì„œ ì²˜ë¦¬
                        for (let i = 0; i < chunk.length; i++) {
                            const row = chunk[i];
                            
                            // timestampë¥¼ msë¡œ ë³€í™˜
                            // df_ui í˜•ì‹: "YYYY-MM-DD HH:mm:ss.SSS" ë˜ëŠ” ms ìˆ«ì ë‘˜ ë‹¤ ì§€ì›
                            let timestampMs = 0;
                            if (row.timestamp !== undefined && row.timestamp !== null) {
                                const tsStr = String(row.timestamp).trim();
                                if (tsStr !== '') {
                                    const numeric = Number(tsStr);
                                    if (!Number.isNaN(numeric) && numeric > 0) {
                                        // ì´ë¯¸ ms ìˆ«ìì¼ ê²½ìš°
                                        timestampMs = numeric;
                                    } else {
                                        // ë‚ ì§œ ë¬¸ìì—´ì¼ ê²½ìš°
                                        const d = new Date(tsStr.replace(' ', 'T') + 'Z'); // UTCë¡œ ê°€ì •
                                        const t = d.getTime();
                                        if (!Number.isNaN(t)) {
                                            timestampMs = t;
                                        }
                                    }
                                }
                            }
                            if (timestampMs <= 0) continue;
                            
                            if (baseTimestampMs === null) baseTimestampMs = timestampMs;
                            
                            // df_mock_20260129ì—ì„œ ì œê³µí•˜ëŠ” global_tick_id ì‚¬ìš©
                            const globalTickStr = row.global_tick_id !== undefined && row.global_tick_id !== null
                                ? String(row.global_tick_id).trim()
                                : null;
                            if (!globalTickStr || globalTickStr === '') continue;
                            const globalTick = parseInt(globalTickStr);
                            if (!Number.isFinite(globalTick) || Number.isNaN(globalTick)) continue;
                            
                            const gameTime = (timestampMs - baseTimestampMs) / 1000;
                            // ì „ì—­ tickì„ ì´í›„ ë¡œì§ì—ì„œ tickìœ¼ë¡œ ì‚¬ìš©
                            const tick = globalTick;
                            
                            // í”Œë ˆì´ì–´ ìœ„ì¹˜ ë°ì´í„° ì²˜ë¦¬ (ìƒˆ ìŠ¤í‚¤ë§ˆ: player_id, X, Y, Z)
                            const x = row.X !== undefined && row.X !== null ? String(row.X).trim() : null;
                            const y = row.Y !== undefined && row.Y !== null ? String(row.Y).trim() : null;
                            const z = row.Z !== undefined && row.Z !== null ? String(row.Z).trim() : null;
                            let playerId = row.player_id !== undefined && row.player_id !== null ? String(row.player_id).trim() : null;
                            
                            // player_id ì •ê·œí™”: "60587.0" ê°™ì€ ê°’ì€ "60587"ë¡œ ë³€í™˜
                            if (playerId && playerId !== '') {
                                const numericId = Number(playerId);
                                if (!Number.isNaN(numericId)) {
                                    playerId = String(parseInt(numericId));
                                }
                            }
                            
                            if (x && y && z && playerId && playerId !== '') {
                                // ì´ globalTickì— í•´ë‹¹í•˜ëŠ” tickData ê°€ì ¸ì˜¤ê±°ë‚˜ ìƒˆë¡œ ìƒì„±
                                let tickData = tickMap.get(globalTick);
                                if (!tickData) {
                                    tickData = { 
                                        tick: globalTick,
                                        game_time: gameTime,
                                        players: []
                                    };
                                    tickMap.set(globalTick, tickData);
                                }
                                const posX = parseFloat(x);
                                const posY = parseFloat(y);
                                const posZ = parseFloat(z);
                                
                                if (!Number.isNaN(posX) && !Number.isNaN(posY) && !Number.isNaN(posZ)) {
                                // ë§µ ê²½ê³„ ì§ì ‘ ì—…ë°ì´íŠ¸
                                if (posX < minX) minX = posX;
                                if (posX > maxX) maxX = posX;
                                if (posY < minY) minY = posY;
                                if (posY > maxY) maxY = posY;
                                if (posZ < minZ) minZ = posZ;
                                if (posZ > maxZ) maxZ = posZ;
                                
                                tickData.players = tickData.players || [];
                                
                                // yaw, pitch ì •ë³´ ìˆ˜ì§‘
                                // ìš°ì„ ìˆœìœ„ 1: df_uiì˜ aim_x, aim_y, aim_z ê¸°ë°˜ ê³„ì‚°
                                // ìš°ì„ ìˆœìœ„ 2: ê¸°ì¡´ yaw/pitch ì»¬ëŸ¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©
                                let yaw = null;
                                let pitch = null;
                                
                                const aimXStr = row.aim_x !== undefined && row.aim_x !== null ? String(row.aim_x).trim() : null;
                                const aimYStr = row.aim_y !== undefined && row.aim_y !== null ? String(row.aim_y).trim() : null;
                                const aimZStr = row.aim_z !== undefined && row.aim_z !== null ? String(row.aim_z).trim() : null;
                                
                                const aimX = aimXStr && aimXStr !== '' ? parseFloat(aimXStr) : null;
                                const aimY = aimYStr && aimYStr !== '' ? parseFloat(aimYStr) : null;
                                const aimZ = aimZStr && aimZStr !== '' ? parseFloat(aimZStr) : null;
                                
                                if (aimX !== null && !Number.isNaN(aimX) &&
                                    aimY !== null && !Number.isNaN(aimY)) {
                                    // ì˜µì…˜ A: aim_x, aim_y, aim_z â†’ yaw/pitch ë³€í™˜
                                    // yaw = atan2(aim_y, aim_x), pitch = asin(aim_z)
                                    const yawRad = Math.atan2(aimY, aimX);
                                    const pitchRad = (aimZ !== null && !Number.isNaN(aimZ)) ? Math.asin(Math.max(-1, Math.min(1, aimZ))) : 0;
                                    
                                    yaw = yawRad * 180 / Math.PI;
                                    pitch = pitchRad * 180 / Math.PI;
                                } else {
                                const yawStr = row.yaw !== undefined && row.yaw !== null ? String(row.yaw).trim() : null;
                                const pitchStr = row.pitch !== undefined && row.pitch !== null ? String(row.pitch).trim() : null;
                                    yaw = yawStr && yawStr !== '' ? parseFloat(yawStr) : null;
                                    pitch = pitchStr && pitchStr !== '' ? parseFloat(pitchStr) : null;
                                }
                                
                                // health ì •ë³´
                                const health = row.health !== undefined && row.health !== null ? parseInt(String(row.health)) : 100;
                                
                                // weapon ì •ë³´ (equipped_weapon_id ë˜ëŠ” event_src_id)
                                const weaponId = row.equipped_weapon_id !== undefined && row.equipped_weapon_id !== null ? 
                                    parseInt(String(row.equipped_weapon_id)) : 
                                    (row.event_src_id !== undefined && row.event_src_id !== null ? parseInt(String(row.event_src_id)) : null);
                                
                                // ì¡°ì¸ ë°ì´í„° í™•ì¸ (CSVì— ì§ì ‘ í¬í•¨ë˜ì–´ ìˆê±°ë‚˜ ë‚˜ì¤‘ì— ì¡°ì¸ë  ìˆ˜ ìˆìŒ)
                                let joinData = playerJoinData.get(playerId);
                                if (!joinData) {
                                    // CSVì—ì„œ ì§ì ‘ ì½ì„ ìˆ˜ ìˆëŠ” ê²½ìš° (ë‚˜ì¤‘ì— ì»¬ëŸ¼ ì¶”ê°€ ì˜ˆì •)
                                    joinData = {
                                        team: row.team || row.team_name || '',
                                        map: row.map || row.map_name || null,
                                        os: row.os || row.os_type || null,
                                        input_device: row.input_device || row.input_device_type || null,
                                        character: row.character || row.character_name || null
                                    };
                                    playerJoinData.set(playerId, joinData);
                                }
                                
                                tickData.players.push({
                                    name: playerId, // player_idë¥¼ nameìœ¼ë¡œ ì‚¬ìš©
                                    team: joinData.team || '', // ì¡°ì¸ëœ íŒ€ ì •ë³´
                                    position: [posX, posZ, posY], // Three.js ì¢Œí‘œê³„: X, Z, Y
                                    health: !Number.isNaN(health) ? health : 100,
                                    round: 1, // ìƒˆ ë°ì´í„°ì—ëŠ” round ì •ë³´ê°€ ì—†ìŒ
                                    weapon: !Number.isNaN(weaponId) ? weaponId : null,
                                    yaw: !Number.isNaN(yaw) ? yaw : null,
                                    pitch: !Number.isNaN(pitch) ? pitch : null,
                                    // ë‚˜ì¤‘ì— ì¡°ì¸ë  ì •ë³´ë“¤
                                    map: joinData.map || null,
                                    os: joinData.os || null,
                                    input_device: joinData.input_device || null,
                                    character: joinData.character || null
                                });
                            }
                        }

                            // ì´ìƒ êµ¬ê°„ ì •ë³´ ìˆ˜ì§‘ (ìƒˆ ìŠ¤í‚¤ë§ˆ: anomaly_anchor_tick, anomaly_tick_offset, tick_pred_error, is_anomalous_tick)
                            const anchorTickStr = row.anomaly_anchor_tick !== undefined && row.anomaly_anchor_tick !== null
                                ? String(row.anomaly_anchor_tick).trim()
                                : null;
                            const offsetTickStr = row.anomaly_tick_offset !== undefined && row.anomaly_tick_offset !== null
                                ? String(row.anomaly_tick_offset).trim()
                                : null;
                            
                            // is_anomalous_tick: bool íƒ€ì…
                            const isAnomFlag = row.is_anomalous_tick !== undefined && row.is_anomalous_tick !== null
                                ? (typeof row.is_anomalous_tick === 'boolean' ? row.is_anomalous_tick : (String(row.is_anomalous_tick).toLowerCase() === 'true' || String(row.is_anomalous_tick) === '1'))
                                : false;
                            
                            // tick_pred_error: tick ë‹¨ìœ„ ì´ìƒ ì ìˆ˜
                            const scoreVal = row.tick_pred_error !== undefined && row.tick_pred_error !== null && String(row.tick_pred_error).trim() !== ''
                                ? parseFloat(String(row.tick_pred_error))
                                : 0;

                            // anomaly sequence ì‹ë³„: ê°™ì€ anomaly_anchor_tickì„ ê°€ì§„ í–‰ë“¤ì„ í•˜ë‚˜ì˜ sequenceë¡œ ê·¸ë£¹í™”
                            // sequence IDëŠ” anchor_tick ê°’ ì‚¬ìš© (ë˜ëŠ” anchor_tick + player_id ì¡°í•©)
                            const anchorTick = anchorTickStr && anchorTickStr !== '' ? parseInt(anchorTickStr) : null;
                            const offsetTick = offsetTickStr && offsetTickStr !== '' ? parseInt(offsetTickStr) : null;
                            
                            // sequence ID ìƒì„±: anchor_tickì´ ìˆìœ¼ë©´ ê·¸ê²ƒì„ ì‚¬ìš©, ì—†ìœ¼ë©´ null
                            const seqId = anchorTick !== null && !Number.isNaN(anchorTick) ? anchorTick : null;

                            // tick ë‹¨ìœ„ ì´ìƒ ì •ë³´ ì €ì¥ (Aim Traceìš©)
                            if (!Number.isNaN(scoreVal) && scoreVal > 0) {
                                allAnomalyScores.push(scoreVal);
                            }
                            const existingTickAnom = anomalyByTick.get(tick);
                            if (!existingTickAnom || scoreVal > existingTickAnom.score) {
                                anomalyByTick.set(tick, {
                                    score: scoreVal,
                                    seqId: seqId,
                                    isAnom: isAnomFlag
                                });
                            }
                            if (seqId !== null && !Number.isNaN(seqId) && seqId > 0) {
                                let info = anomalySeqMap.get(seqId);
                                if (!info) {
                                    info = {
                                        seqId,
                                        anchorTick: anchorTick, // ê¸°ì¤€ fire tick
                                        startTick: tick,
                                        endTick: tick,
                                        maxTickScore: scoreVal,
                                        hasAnomalousFlag: isAnomFlag,
                                        // ì´ë²¤íŠ¸ ì—°ê´€ ì •ë³´ ë° í”Œë ˆì´ì–´ ì—°ê´€ ì •ë³´
                                        killCount: 0,
                                        hitCount: 0,
                                        fireCount: 0,
                                        players: new Set()
                                    };
                                    anomalySeqMap.set(seqId, info);
                                } else {
                                    if (tick < info.startTick) info.startTick = tick;
                                    if (tick > info.endTick) info.endTick = tick;
                                    if (scoreVal > info.maxTickScore) info.maxTickScore = scoreVal;
                                    if (isAnomFlag) info.hasAnomalousFlag = true;
                                }

                                // ì´ tickì— ì°¸ì—¬í•œ player_idë¥¼ ì‹œí€€ìŠ¤ì— ì—°ê²° (í”Œë ˆì´ì–´ë³„ ì´ìƒ êµ¬ê°„ ë¶„ì„ìš©)
                                if (playerId) {
                                    info.players.add(playerId);
                            }
                        }
                        
                            // ì´ë²¤íŠ¸ ì²˜ë¦¬ (ìƒˆ ìŠ¤í‚¤ë§ˆ: event_type, event_src_player_id, event_trg_player_id)
                            const eventType = row.event_type !== undefined && row.event_type !== null ? parseInt(String(row.event_type)) : null;
                            if (!Number.isNaN(eventType) && eventType > 0) {
                                // event_type: 1:fire, 2:hit, 3:kill
                                let eventTypeStr = '';
                                if (eventType === 1) eventTypeStr = 'fire';
                                else if (eventType === 2) eventTypeStr = 'hit';
                                else if (eventType === 3) eventTypeStr = 'kill';
                                
                                if (eventTypeStr) {
                                    let attackerId = row.event_src_player_id !== undefined && row.event_src_player_id !== null ? 
                                        String(row.event_src_player_id).trim() : null;
                                    let victimId = row.event_trg_player_id !== undefined && row.event_trg_player_id !== null ? 
                                        String(row.event_trg_player_id).trim() : null;

                                    // ID ì •ê·œí™”: "60587.0" â†’ "60587"
                                    if (attackerId && attackerId !== '') {
                                        const numAtt = Number(attackerId);
                                        if (!Number.isNaN(numAtt)) attackerId = String(parseInt(numAtt));
                                    }
                                    if (victimId && victimId !== '') {
                                        const numVic = Number(victimId);
                                        if (!Number.isNaN(numVic)) victimId = String(parseInt(numVic));
                                    }
                                    
                                    // í‚¬ ì´ë²¤íŠ¸ ì¤‘ë³µ ì²´í¬ (ìµœê·¼ ì´ë²¤íŠ¸ë§Œ í™•ì¸í•˜ì—¬ ì„±ëŠ¥ ê°œì„ )
                                    let shouldAddEvent = true;
                                    if (eventType === 3 && attackerId && victimId) {
                                        // ìµœê·¼ 10ê°œ ì´ë²¤íŠ¸ë§Œ í™•ì¸ (ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš° ë°©ì§€)
                                        const recentEvents = events.slice(-10);
                                        const existingKill = recentEvents.find(e => 
                                            e.tick === tick && 
                                            e.event_type_lower === 'kill' &&
                                            e.attacker && e.attacker.name === attackerId &&
                                            e.victim && e.victim.name === victimId
                                        );
                                        if (existingKill) {
                                            shouldAddEvent = false;
                                        }
                                    }
                                    
                                    if (shouldAddEvent) {
                                        // ê³µê²©ì/í”¼í•´ì ìœ„ì¹˜ ì°¾ê¸° (ê°™ì€ global tickì˜ í”Œë ˆì´ì–´ ë°ì´í„°ì—ì„œ)
                                        const tickDataForEvent = tickMap.get(tick);
                                        const playersThisTick = tickDataForEvent && Array.isArray(tickDataForEvent.players)
                                            ? tickDataForEvent.players
                                            : [];
                                        
                                        let attackerPos = [null, null, null];
                                        if (attackerId && playersThisTick.length > 0) {
                                            const attackerPlayer = playersThisTick.find(p => p.name === attackerId);
                                            if (attackerPlayer && attackerPlayer.position) {
                                                attackerPos = attackerPlayer.position;
                                            }
                                        }
                                        
                                        let victimPos = [null, null, null];
                                        if (victimId && playersThisTick.length > 0) {
                                            const victimPlayer = playersThisTick.find(p => p.name === victimId);
                                            if (victimPlayer && victimPlayer.position) {
                                                victimPos = victimPlayer.position;
                                            }
                                        }
                                        
                                        // weapon ì •ë³´
                                        const eventWeaponId = row.event_src_id !== undefined && row.event_src_id !== null ? 
                                            parseInt(String(row.event_src_id)) : null;
                                        
                                        // headshot ì •ë³´
                                        const headshot = row.head_shot_yn !== undefined && row.head_shot_yn !== null ? 
                                            (parseInt(String(row.head_shot_yn)) === 1) : false;
                                        
                                        events.push({
                                            tick: tick,
                                            game_time: gameTime,
                                            event_type: eventTypeStr,
                                            event_type_lower: eventTypeStr.toLowerCase(),
                                            attacker: {
                                                name: attackerId,
                                                team: '',
                                                position: attackerPos,
                                                weapon: !Number.isNaN(eventWeaponId) ? eventWeaponId : null
                                            },
                                            victim: {
                                                name: victimId,
                                                team: '',
                                                position: victimPos
                                            },
                                            weapon: !Number.isNaN(eventWeaponId) ? eventWeaponId : null,
                                            headshot: headshot
                                        });
                                        
                                        // í‚¬ ì´ë²¤íŠ¸ì˜ ê³µê²©ì Aim ë°ì´í„° ìˆ˜ì§‘ ë° anomaly seq ì—°ê´€ ì¹´ìš´íŠ¸
                                        if (eventType === 3 && attackerId) {
                                            // ì´ globalTickì— ëŒ€í•´ aimIndexì— kill í¬ì¸íŠ¸ ì¶”ê°€ (ìœ„ì¹˜/ê°ë„ëŠ” tickMapì— ì €ì¥ëœ í”Œë ˆì´ì–´ ê¸°ì¤€)
                                            const attackerPlayer = playersThisTick.find(p => p.name === attackerId);
                                            if (attackerPlayer && attackerPlayer.yaw !== null && attackerPlayer.pitch !== null) {
                                                if (!aimIndex.has(attackerId)) aimIndex.set(attackerId, []);
                                                const aimArray = aimIndex.get(attackerId);
                                                // ìµœê·¼ 10ê°œë§Œ í™•ì¸í•˜ì—¬ ì„±ëŠ¥ ê°œì„ 
                                                const recentAims = aimArray.slice(-10);
                                                const existingKill = recentAims.find(a => 
                                                    a.type === 'kill' && a.tick === tick && Math.abs(a.time - gameTime) < 0.01
                                                );
                                                if (!existingKill) {
                                                    aimArray.push({ 
                                                        yaw: attackerPlayer.yaw, 
                                                        pitch: attackerPlayer.pitch, 
                                                        time: gameTime, 
                                                        tick: tick, 
                                                        type: 'kill',
                                                        _temp: true
                                                    });
                                                }
                                            }

                                            // anomaly seq ì—°ê´€ ì¹´ìš´íŠ¸ ì—…ë°ì´íŠ¸ (ìƒˆ ìŠ¤í‚¤ë§ˆ: anomaly_anchor_tick ê¸°ë°˜)
                                            const anchorTickStrForEvent = row.anomaly_anchor_tick !== undefined && row.anomaly_anchor_tick !== null
                                                ? String(row.anomaly_anchor_tick).trim()
                                                : null;
                                            const seqIdForEvent = anchorTickStrForEvent && anchorTickStrForEvent !== '' ? parseInt(anchorTickStrForEvent) : null;
                                            if (seqIdForEvent !== null && !Number.isNaN(seqIdForEvent) && seqIdForEvent > 0) {
                                                const info = anomalySeqMap.get(seqIdForEvent);
                                                if (info) {
                                                    if (eventType === 3) info.killCount++;
                                                    if (eventType === 2) info.hitCount++;
                                                    if (eventType === 1) info.fireCount++;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        // ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸ ë° UI ì°¨ë‹¨ ë°©ì§€
                        updateProgress((chunkEnd / totalRows) * 100);
                        await new Promise(resolve => setTimeout(resolve, 0)); // ë‹¤ìŒ ì´ë²¤íŠ¸ ë£¨í”„ë¡œ
                    }
                    
                    // tickMapì„ ì •ë ¬ëœ positions ë°°ì—´ë¡œ ë³€í™˜
                    const sortedTicks = Array.from(tickMap.keys()).sort((a, b) => a - b);
                    for (let i = 0; i < sortedTicks.length; i++) {
                        const t = sortedTicks[i];
                        const td = tickMap.get(t);
                        if (td && td.players && td.players.length > 0) {
                            positions.push(td);
                        }
                    }
                    
                    console.log('ë°ì´í„° ì²˜ë¦¬ ì™„ë£Œ - Positions:', positions.length, 'ê°œ í‹±');
                    if (positions.length > 0) {
                        console.log('ì²« ë²ˆì§¸ í‹± ìƒ˜í”Œ:', {
                            tick: positions[0].tick,
                            game_time: positions[0].game_time,
                            players_count: positions[0].players.length,
                            first_player: positions[0].players[0] ? {
                                name: positions[0].players[0].name,
                                position: positions[0].players[0].position
                            } : null
                        });
                    }
                    
                    // ë§µ ê²½ê³„ ê³„ì‚° (ì´ë¯¸ ê³„ì‚°ë¨)
                    let detectedMapName = null;
                    if (minX !== Infinity && maxX !== -Infinity) {
                        // ì‹¤ì œ í”Œë ˆì´ì–´ ê²½ë¡œ ì˜ì—­ì„ ê²½ê³„ë¡œ ì‚¬ìš© (ì „ì²´ ë§µì´ ì•„ë‹Œ)
                        // ë‚˜ì¤‘ì— renderAllPlayerPathsì—ì„œ ì‹¤ì œ ê²½ë¡œ ê²½ê³„ë¥¼ ê³„ì‚°í•˜ì—¬ ì—…ë°ì´íŠ¸
                        this.mapBounds = {
                            minX: minX,
                            maxX: maxX,
                            minY: minY,
                            maxY: maxY,
                            minZ: minZ,
                            maxZ: maxZ,
                            centerX: (minX + maxX) / 2,
                            centerY: (minY + maxY) / 2,
                            centerZ: (minZ + maxZ) / 2,
                            width: maxX - minX,
                            height: maxY - minY,
                            depth: maxZ - minZ,
                            // ì‹¤ì œ ê²½ë¡œ ê²½ê³„ (ë‚˜ì¤‘ì— ì—…ë°ì´íŠ¸ë¨)
                            pathMinX: minX,
                            pathMaxX: maxX,
                            pathMinY: minY,
                            pathMaxY: maxY,
                            pathMinZ: minZ,
                            pathMaxZ: maxZ
                        };
                        
                        // í”Œë ˆì´ì–´ ìœ„ì¹˜ ë²”ìœ„ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë§µ ì¶”ë¡ 
                        detectedMapName = this.detectMapFromBounds(this.mapBounds);
                    }
                    
                    // CSV íŒŒì¼ëª…ì—ì„œ ë§µ ì´ë¦„ ì¶”ì¶œ ì‹œë„
                    const fileName = document.getElementById('selected-file')?.textContent || '';
                    let mapNameFromFile = null;
                    if (fileName && fileName !== 'ì„ íƒëœ íŒŒì¼ ì—†ìŒ' && fileName !== 'No file selected') {
                        // íŒŒì¼ëª…ì—ì„œ ë§µ ì´ë¦„ íŒ¨í„´ ì°¾ê¸° (ì˜ˆ: anubis, dust2, inferno ë“±)
                        const mapPatterns = [
                            'anubis', 'dust2', 'dust_2', 'inferno', 'mirage', 'overpass', 
                            'nuke', 'vertigo', 'ancient', 'cache', 'train', 'cobblestone'
                        ];
                        const fileNameLower = fileName.toLowerCase();
                        for (const map of mapPatterns) {
                            if (fileNameLower.includes(map)) {
                                mapNameFromFile = map.charAt(0).toUpperCase() + map.slice(1).replace('_', '');
                                break;
                            }
                        }
                    }
                    
                    // ìµœì¢… ë§µ ì´ë¦„ ê²°ì • (íŒŒì¼ëª… ìš°ì„ , ì—†ìœ¼ë©´ ìœ„ì¹˜ ê¸°ë°˜ ì¶”ë¡ )
                    const finalMapName = mapNameFromFile || detectedMapName || 'Unknown';
                    this.detectedMapName = finalMapName;
                    
                    const gameTimes = positions.map(p => p.game_time).filter(t => t);
                    const ticks = positions.map(p => p.tick).filter(t => t);
                    const players = new Set();
                    const playerStats = new Map();
                    const playerIndex = new Map();
                    
                    // í”Œë ˆì´ì–´ ì¸ë±ìŠ¤ ë° Aim ë°ì´í„° ìˆ˜ì§‘ (ìµœì í™” - forEach ëŒ€ì‹  for ë£¨í”„)
                    for (let i = 0; i < positions.length; i++) {
                        const p = positions[i];
                        for (let j = 0; j < p.players.length; j++) {
                            const pl = p.players[j];
                            if (pl.name) {
                                players.add(pl.name);
                                if (!playerStats.has(pl.name)) {
                                    // í”Œë ˆì´ì–´ í†µê³„ ì´ˆê¸°í™” (ë‚˜ì¤‘ì— ì¡°ì¸ë  ì •ë³´ë“¤ í¬í•¨)
                                    playerStats.set(pl.name, { 
                                        kills: 0, 
                                        deaths: 0, 
                                        team: pl.team || '',
                                        map: pl.map || null,
                                        os: pl.os || null,
                                        input_device: pl.input_device || null,
                                        character: pl.character || null
                                    });
                                } else {
                                    // ì´ë¯¸ ìˆëŠ” ê²½ìš°ì—ë„ ì¶”ê°€ ì •ë³´ ì—…ë°ì´íŠ¸ (ì²« ë²ˆì§¸ë¡œ ë°œê²¬ëœ ê°’ ì‚¬ìš©)
                                    const stats = playerStats.get(pl.name);
                                    if (!stats.map && pl.map) stats.map = pl.map;
                                    if (!stats.os && pl.os) stats.os = pl.os;
                                    if (!stats.input_device && pl.input_device) stats.input_device = pl.input_device;
                                    if (!stats.character && pl.character) stats.character = pl.character;
                                }
                                if (!playerIndex.has(pl.name)) playerIndex.set(pl.name, []);
                                playerIndex.get(pl.name).push({ tick: p.tick, time: p.game_time, position: pl.position });
                                
                                // Aim ë°ì´í„° ìˆ˜ì§‘ (ëª¨ë“  í‹±ì—ì„œ yaw/pitch)
                                if (pl.yaw !== null && pl.yaw !== undefined && 
                                    pl.pitch !== null && pl.pitch !== undefined) {
                                    if (!aimIndex.has(pl.name)) aimIndex.set(pl.name, []);
                                    aimIndex.get(pl.name).push({ 
                                        yaw: pl.yaw, 
                                        pitch: pl.pitch, 
                                        time: p.game_time, 
                                        tick: p.tick,
                                        type: 'move' 
                                    });
                                }
                            }
                        }
                    }
                    
                    // Kill ì´ë²¤íŠ¸ì˜ aim ë°ì´í„°ë¥¼ move ë°ì´í„°ì™€ ë³‘í•© (ì¼ê´„ ì²˜ë¦¬ - forEach ëŒ€ì‹  for ë£¨í”„)
                    for (const [name, arr] of aimIndex.entries()) {
                        const kills = [];
                        const moves = [];
                        // filter ëŒ€ì‹  ì§ì ‘ ë£¨í”„ë¡œ ë¶„ë¥˜
                        for (let i = 0; i < arr.length; i++) {
                            const a = arr[i];
                            if (a.type === 'kill' && a._temp) {
                                kills.push(a);
                            } else if (a.type === 'move') {
                                moves.push(a);
                            }
                        }
                        
                        // kill íƒ€ì…ì„ ê°™ì€ ì‹œê°„/í‹±ì˜ moveì— ë³‘í•©
                        for (let i = 0; i < kills.length; i++) {
                            const kill = kills[i];
                            let existing = null;
                            for (let j = 0; j < moves.length; j++) {
                                const m = moves[j];
                                if (Math.abs(m.time - kill.time) < 0.01 && m.tick === kill.tick) {
                                    existing = m;
                                    break;
                                }
                            }
                            if (existing) {
                                existing.type = 'kill';
                            }
                        }
                        
                        // ì„ì‹œ kill í•­ëª© ì œê±° (ë³‘í•©ëœ ê²ƒë§Œ ë‚¨ê¹€) - ìŠ¤í”„ë ˆë“œ ì—°ì‚°ì ì œê±°
                        const unmergedKills = [];
                        for (let i = 0; i < kills.length; i++) {
                            const k = kills[i];
                            let exists = false;
                            for (let j = 0; j < moves.length; j++) {
                                const m = moves[j];
                                if (Math.abs(m.time - k.time) < 0.01 && m.tick === k.tick) {
                                    exists = true;
                                    break;
                                }
                            }
                            if (!exists) {
                                unmergedKills.push(k);
                            }
                        }
                        // ìŠ¤í”„ë ˆë“œ ì—°ì‚°ì ëŒ€ì‹  ì§ì ‘ í• ë‹¹
                        arr.length = 0;
                        for (let i = 0; i < moves.length; i++) {
                            arr.push(moves[i]);
                        }
                        for (let i = 0; i < unmergedKills.length; i++) {
                            // _temp ì œê±°í•˜ê³  typeë§Œ 'kill'ë¡œ ìœ ì§€
                            const kill = unmergedKills[i];
                            delete kill._temp;
                            arr.push(kill);
                        }
                    }
                    
                    // events ë°°ì—´ ìˆœíšŒ (forEach ëŒ€ì‹  for ë£¨í”„)
                    // K/D ë¹„ìœ¨ ê³„ì‚°: event_type === 3 (kill)ë§Œ í¬í•¨
                    for (let i = 0; i < events.length; i++) {
                        const e = events[i];
                        // event_typeì´ 3ì¸ ê²½ìš°ë§Œ killë¡œ ê°„ì£¼ (hit ì´ë²¤íŠ¸ ì œì™¸)
                        if (e.event_type === 'kill' || e.event_type_lower === 'kill') {
                            if (e.attacker && e.attacker.name) {
                                const stats = playerStats.get(e.attacker.name);
                                if (stats) stats.kills++;
                            }
                            if (e.victim && e.victim.name) {
                                const stats = playerStats.get(e.victim.name);
                                if (stats) stats.deaths++;
                            }
                        }
                    }
                    
                    // í”Œë ˆì´ì–´ë³„ ì¶”ê°€ ë©”íƒ€ë°ì´í„° ìˆ˜ì§‘ (OS, ì…ë ¥ ë””ë°”ì´ìŠ¤, ìºë¦­í„° ë“±)
                    const playerMetadata = new Map();
                    positions.forEach(p => {
                        p.players.forEach(pl => {
                            if (pl.name && !playerMetadata.has(pl.name)) {
                                playerMetadata.set(pl.name, {
                                    team: pl.team || '',
                                    map: pl.map || null,
                                    os: pl.os || null,
                                    input_device: pl.input_device || null,
                                    character: pl.character || null
                                });
                            }
                        });
                    });
                    
                    // ê³ ìœ í•œ íŒ€ ëª©ë¡ ìˆ˜ì§‘
                    const uniqueTeams = new Set();
                    playerStats.forEach(stats => {
                        if (stats.team) uniqueTeams.add(stats.team);
                    });
                    
                    // ê³ ìœ í•œ ë§µ ëª©ë¡ ìˆ˜ì§‘
                    const uniqueMaps = new Set();
                    playerMetadata.forEach(meta => {
                        if (meta.map) uniqueMaps.add(meta.map);
                    });
                    if (this.detectedMapName) uniqueMaps.add(this.detectedMapName);
                    
                    this.data = {
                        metadata: {
                            total_ticks: positions.length,
                            total_events: events.length,
                            time_range: {
                                min: gameTimes.length ? Math.min(...gameTimes) : 0,
                                max: gameTimes.length ? Math.max(...gameTimes) : 0
                            },
                            tick_range: {
                                min: ticks.length ? Math.min(...ticks) : 0,
                                max: ticks.length ? Math.max(...ticks) : 0
                            },
                            players: Array.from(players).sort(),
                            playerStats: Object.fromEntries(playerStats),
                            playerMetadata: Object.fromEntries(playerMetadata), // ì¶”ê°€ ë©”íƒ€ë°ì´í„°
                            teams: Array.from(uniqueTeams).length > 0 ? Array.from(uniqueTeams) : ['CT', 'TERRORIST'], // ë™ì  íŒ€ ëª©ë¡
                            maps: Array.from(uniqueMaps), // ë§µ ëª©ë¡
                            mapName: this.detectedMapName || 'Unknown',
                            // ë‚˜ì¤‘ì— ì¡°ì¸ë  ì •ë³´ë“¤ì„ ìœ„í•œ êµ¬ì¡°
                            matchInfo: {
                                match_id: matchId, // CSVì—ì„œ ì¶”ì¶œí•œ match_id
                                os_distribution: {}, // OSë³„ ë¶„í¬
                                input_device_distribution: {}, // ì…ë ¥ ë””ë°”ì´ìŠ¤ë³„ ë¶„í¬
                                character_distribution: {} // ìºë¦­í„°ë³„ ë¶„í¬
                            },
                            anomalySeqs: [] // ì´ìƒ êµ¬ê°„ ìš”ì•½
                        },
                        positions: positions,
                        events: events
                    };

                    // anomalySeqMapì„ ë°°ì—´ë¡œ ë³€í™˜ (seq_score ë˜ëŠ” maxTickScore ê¸°ì¤€ ë‚´ë¦¼ì°¨ìˆœ)
                    const anomalySeqs = Array.from(anomalySeqMap.values()).sort((a, b) => {
                        const scoreA = a.seqScore || a.maxTickScore || 0;
                        const scoreB = b.seqScore || b.maxTickScore || 0;
                        return scoreB - scoreA;
                    });
                    this.data.metadata.anomalySeqs = anomalySeqs;

                    // tick_anomaly_scoreì˜ p99(baseline) ê³„ì‚°
                    let baselineP99 = 0;
                    const scores = allAnomalyScores.filter(s => Number.isFinite(s) && s > 0).sort((a, b) => a - b);
                    if (scores.length > 0) {
                        const idx = Math.max(0, Math.floor(scores.length * 0.99) - 1);
                        baselineP99 = scores[idx];
                    }
                    this.anomalyBaselineP99 = baselineP99;
                    this.anomalyByTick = anomalyByTick;
                    this.data.metadata.anomalyBaselineP99 = baselineP99;
                    
                    // OS, ì…ë ¥ ë””ë°”ì´ìŠ¤, ìºë¦­í„° ë¶„í¬ ê³„ì‚°
                    playerMetadata.forEach(meta => {
                        if (meta.os) {
                            this.data.metadata.matchInfo.os_distribution[meta.os] = 
                                (this.data.metadata.matchInfo.os_distribution[meta.os] || 0) + 1;
                        }
                        if (meta.input_device) {
                            this.data.metadata.matchInfo.input_device_distribution[meta.input_device] = 
                                (this.data.metadata.matchInfo.input_device_distribution[meta.input_device] || 0) + 1;
                        }
                        if (meta.character) {
                            this.data.metadata.matchInfo.character_distribution[meta.character] = 
                                (this.data.metadata.matchInfo.character_distribution[meta.character] || 0) + 1;
                        }
                    });
                    this.playerIndex = playerIndex;
                    // aimIndex ì •ë ¬ (ì‹œê°„ìˆœ)
                    aimIndex.forEach((arr, name) => {
                        arr.sort((a, b) => a.time - b.time);
                    });
                    this.aimIndex = aimIndex;
                    
                    // window.simulationì— ì¸ìŠ¤í„´ìŠ¤ í• ë‹¹ (ë””ë²„ê¹…ìš©)
                    window.simulation = this;
                    
                    console.log('=== ë°ì´í„° ì²˜ë¦¬ ì™„ë£Œ ===');
                    console.log('âœ… Positions ìˆ˜:', positions.length);
                    console.log('âœ… Events ìˆ˜:', events.length);
                    console.log('âœ… í”Œë ˆì´ì–´ ìˆ˜:', this.data.metadata.players.length);
                    console.log('âœ… ì‹œê°„ ë²”ìœ„:', 
                        this.formatTime(this.data.metadata.time_range.min), 
                        '~', 
                        this.formatTime(this.data.metadata.time_range.max));
                    
                    // í¬ì»¤ìŠ¤ ëª¨ë“œ í”Œë ˆì´ì–´ ëª©ë¡ ì—…ë°ì´íŠ¸
                    if (typeof this.updateFocusPlayerList === 'function') {
                        this.updateFocusPlayerList();
                    }
                    
                    console.log('âœ… Tick ë²”ìœ„:', 
                        this.data.metadata.tick_range.min, 
                        '~', 
                        this.data.metadata.tick_range.max);
                    console.log('âœ… í”Œë ˆì´ì–´ ëª©ë¡:', this.data.metadata.players);
                    console.log('âœ… Match ID:', matchId);
                    console.log('âœ… ë§µ ê²½ê³„:', this.mapBounds);
                    console.log('âœ… ë§µ ì´ë¦„:', this.data.metadata.mapName);
                    console.log('âœ… íŒ€ ëª©ë¡:', this.data.metadata.teams);
                    console.log('âœ… ì „ì²´ ë©”íƒ€ë°ì´í„°:', this.data.metadata);
                    
                    if (positions.length === 0) {
                        console.error('âŒ Positionsê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤. ë°ì´í„° í¬ë§·ì„ í™•ì¸í•˜ì„¸ìš”.');
                        alert('ë°ì´í„°ë¥¼ ì²˜ë¦¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. CSV íŒŒì¼ í¬ë§·ì„ í™•ì¸í•˜ì„¸ìš”.');
                        return;
                    }
                    
                    if (events.length === 0) {
                        console.warn('âš ï¸ Eventsê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤. ì´ë²¤íŠ¸ ë°ì´í„°ê°€ ì—†ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                    }
                    
                    console.log('âœ… íŒŒì‹± í…ŒìŠ¤íŠ¸ ì™„ë£Œ - ëª¨ë“  ë°ì´í„°ê°€ ì •ìƒì ìœ¼ë¡œ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤!');

                    // ì´ˆê¸° ìƒíƒœ: í¬ì»¤ìŠ¤ ëª¨ë“œ OFF, ê¸€ë¡œë²Œ íƒ€ì„ë¼ì¸ 0ì´ˆë¶€í„° ì‹œì‘
                    this.focusMode = false;
                    this.focusTickRange = null;
                    this.focusTimeRange = null;
                    this.focusModeType = 'anomaly';
                    this.currentTick = 0;
                    this.playSpeed = 1;
                    
                    this.updateUI();
                    this.setupMapBounds();
                    // setupMapBounds() ì´í›„ì— ê²½ë¡œ ë Œë”ë§ (baseCameraDistance ì„¤ì • í›„)
                    this.analyzeAndRenderPaths();
                    
                    // í¬ì»¤ìŠ¤ ëª¨ë“œ í”Œë ˆì´ì–´ ëª©ë¡ ì—…ë°ì´íŠ¸ (ë¨¼ì € ì‹¤í–‰)
                    if (typeof this.updateFocusPlayerList === 'function') {
                        this.updateFocusPlayerList();
                    }
                    
                    // íŠ¹ì • í”Œë ˆì´ì–´ ì‹œì  ë³´ê¸°ìš© í”Œë ˆì´ì–´ ì„ íƒ (ë³„ë„ ê¸°ëŠ¥)
                    this.populatePlayerPicker();
                    
                    // íŒŒì¼ ë¡œë“œ í›„ ì‹œë®¬ë ˆì´ì…˜ ë¶„ì„ íƒ­ìœ¼ë¡œ ìë™ ì „í™˜
                    this.showInvestigate();
                    
                    // ì‹œë®¬ë ˆì´ì…˜ ë Œë”ë§ ì´ˆê¸°í™”
                    setTimeout(() => {
                        console.log('=== ì´ˆê¸° ë Œë”ë§ ì‹œì‘ ===');
                        console.log('Positions ìˆ˜:', this.data.positions.length);
                        console.log('ì²« ë²ˆì§¸ í‹± ë°ì´í„°:', this.data.positions[0]);
                        console.log('ì²« ë²ˆì§¸ í‹± í”Œë ˆì´ì–´ ìˆ˜:', this.data.positions[0]?.players?.length || 0);
                        console.log('ë§µ ê²½ê³„:', this.mapBounds);
                        console.log('ì¹´ë©”ë¼ ìœ„ì¹˜:', { x: this.camera.position.x, y: this.camera.position.y, z: this.camera.position.z });
                        console.log('ì”¬ ì˜¤ë¸Œì íŠ¸ ìˆ˜:', this.scene.children.length);
                        
                        // ë¨¼ì € ì „ì²´ í”Œë ˆì´ì–´ ê²½ë¡œ ë²”ìœ„ë¥¼ ê³„ì‚°í•´ì„œ ìŠ¤ì¼€ì¼ë§ ì„¤ì •
                        this.calculateFullMapBoundsAndScale();
                        
                        // ê·¸ ë‹¤ìŒ ëª¨ë“  í”Œë ˆì´ì–´ì˜ ê²½ë¡œë¥¼ ë¼ì¸ìœ¼ë¡œ ê·¸ë ¤ì„œ ì‹œê°í™”
                        this.renderAllPlayerPaths();
                        
                        // ê·¸ ë‹¤ìŒ ìºë¦­í„° ë Œë”ë§
                        this.renderTick(0);
                        
                        // ê²½ë¡œ ë Œë”ë§ í›„ ì „ì²´ ë§µ ë²”ìœ„ì— ë§ê²Œ ì¹´ë©”ë¼ ì„¤ì •
                        setTimeout(() => {
                            if (this.mapBounds && this.mapBounds.fullPathWidth) {
                                // ì „ì²´ ë§µ ë²”ìœ„ë¥¼ ì‚¬ìš©í•´ì„œ ì¹´ë©”ë¼ ì„¤ì •
                                const container = document.getElementById('canvas-container');
                                const screenWidth = container ? container.clientWidth : 800;
                                const screenHeight = container ? container.clientHeight : 600;
                                const screenMinDim = Math.min(screenWidth, screenHeight);
                                
                                // ìŠ¤ì¼€ì¼ë§ëœ ì¢Œí‘œ ë²”ìœ„ë¡œ ì¹´ë©”ë¼ ê±°ë¦¬ ê³„ì‚°
                                const scaledWidth = this.mapBounds.fullPathWidth * this.coordinateScale;
                                const scaledHeight = this.mapBounds.fullPathHeight * this.coordinateScale;
                                const scaledDepth = this.mapBounds.fullPathDepth * this.coordinateScale;
                                
                                const fov = this.camera.fov * (Math.PI / 180);
                                const aspect = screenWidth / screenHeight;
                                
                                // ìŠ¤ì¼€ì¼ë§ëœ ë²”ìœ„ë¡œ ê±°ë¦¬ ê³„ì‚° (3D ë·°ì´ë¯€ë¡œ ë†’ì´ë„ ê³ ë ¤)
                                const distanceX = (scaledWidth / 2) / Math.tan(fov / 2) / aspect;
                                const distanceZ = (scaledDepth / 2) / Math.tan(fov / 2);
                                const distanceY = (scaledHeight / 2) / Math.tan(fov / 2);
                                const calculatedDistance = Math.max(distanceX, distanceZ, distanceY) * 1.2; // 20% ì—¬ìœ  ê³µê°„
                                
                                // ì¹´ë©”ë¼ ê±°ë¦¬ ì„¤ì •
                                this.cameraDistance = Math.max(200, Math.min(calculatedDistance, screenMinDim * 2.0));
                                
                                console.log('ì´ˆê¸° ì¹´ë©”ë¼ ê±°ë¦¬ ì„¤ì • (ì „ì²´ ë§µ ë²”ìœ„):', {
                                    originalRange: `X: ${this.mapBounds.fullPathWidth.toFixed(2)}, Y: ${this.mapBounds.fullPathHeight.toFixed(2)}, Z: ${this.mapBounds.fullPathDepth.toFixed(2)}`,
                                    scaledRange: `${scaledWidth.toFixed(2)} x ${scaledHeight.toFixed(2)} x ${scaledDepth.toFixed(2)}`,
                                    screenSize: `${screenWidth}x${screenHeight}`,
                                    finalDistance: this.cameraDistance.toFixed(2)
                                });
                                
                                // íŒ¨ë‹ ì˜¤í”„ì…‹ ì´ˆê¸°í™”
                                if (this.panOffset) {
                                    this.panOffset.x = 0;
                                    this.panOffset.y = 0;
                                    this.panOffset.z = 0;
                                }
                                
                                // ì¹´ë©”ë¼ ê°ë„ë¥¼ ìœ„ì—ì„œ ë‚´ë ¤ë‹¤ë³´ëŠ” ê°ë„ë¡œ ì„¤ì •
                                this.cameraRotationX = 0.3; // ì•½ê°„ ê¸°ìš¸ì„
                                this.cameraRotationY = 0;
                                
                                // ìŠ¤ì¼€ì¼/ì˜¤í”„ì…‹ ë³€ê²½ì„ ë©”ì‹œì— ì¦‰ì‹œ ë°˜ì˜
                                this.renderTick(this.currentTick || 0);
                                this.updateCamera();
                            } else {
                                // í”Œë ˆì´ì–´ ìœ„ì¹˜ê°€ ì—†ìœ¼ë©´ ê¸°ì¡´ Fit to View ì‚¬ìš©
                                this.fitToView();
                            }
                        }, 300);
                        
                        console.log('ë Œë”ë§ í›„ ì”¬ ì˜¤ë¸Œì íŠ¸ ìˆ˜:', this.scene.children.length);
                        console.log('í”Œë ˆì´ì–´ ì˜¤ë¸Œì íŠ¸ ìˆ˜:', this.playerObjects.size);
                        console.log('í”Œë ˆì´ì–´ ë¼ë²¨ ìˆ˜:', this.playerLabels.size);
                        
                        // ì²« ë²ˆì§¸ í”Œë ˆì´ì–´ ìœ„ì¹˜ í™•ì¸
                        if (this.data.positions[0] && this.data.positions[0].players.length > 0) {
                            const firstPlayer = this.data.positions[0].players[0];
                            const mesh = this.playerObjects.get(firstPlayer.name);
                            console.log('ì²« ë²ˆì§¸ í”Œë ˆì´ì–´ ìµœì¢… í™•ì¸:', {
                                name: firstPlayer.name,
                                position: firstPlayer.position,
                                mesh_exists: !!mesh,
                                mesh_position: mesh ? { x: mesh.position.x, y: mesh.position.y, z: mesh.position.z } : null
                            });
                        }
                        
                        // renderer í¬ê¸° ì¬ì¡°ì • (containerê°€ ìˆ¨ê²¨ì ¸ ìˆì„ ìˆ˜ ìˆìŒ)
                        const container = document.getElementById('canvas-container');
                        if (container && this.renderer) {
                            const width = container.clientWidth;
                            const height = container.clientHeight;
                            if (width > 0 && height > 0) {
                                this.camera.aspect = width / height;
                                this.camera.updateProjectionMatrix();
                                this.renderer.setSize(width, height);
                                console.log('Renderer í¬ê¸° ì„¤ì •:', width, 'x', height);
                            }
                        }
                    }, 100);
                } catch (error) {
                    console.error('processData ì˜¤ë¥˜:', error);
                    alert('ë°ì´í„° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                    const loading = document.getElementById('loading');
                    if (loading) loading.style.display = 'none';
                }
            }
            
            /**
             * ë‚˜ì¤‘ì— ì¡°ì¸ë  ë°ì´í„°ë¥¼ ì¶”ê°€í•˜ëŠ” í•¨ìˆ˜
             * @param {Object} joinData - player_idë¥¼ í‚¤ë¡œ í•˜ëŠ” ì¡°ì¸ ë°ì´í„° ê°ì²´
             * @example
             * enrichPlayerData({
             *   "-479": { team: "Team A", os: "Windows", input_device: "keyboard_mouse", character: "Character1" },
             *   "-481": { team: "Team B", os: "Mac", input_device: "console", character: "Character2" }
             * })
             */
            enrichPlayerData(joinData) {
                if (!this.data || !joinData) return;
                
                console.log('í”Œë ˆì´ì–´ ë°ì´í„° ì¡°ì¸ ì‹œì‘:', joinData);
                
                // ê° í‹±ì˜ í”Œë ˆì´ì–´ ë°ì´í„° ì—…ë°ì´íŠ¸
                this.data.positions.forEach(tickData => {
                    tickData.players.forEach(player => {
                        const joinInfo = joinData[player.name];
                        if (joinInfo) {
                            if (joinInfo.team !== undefined) player.team = joinInfo.team;
                            if (joinInfo.map !== undefined) player.map = joinInfo.map;
                            if (joinInfo.os !== undefined) player.os = joinInfo.os;
                            if (joinInfo.input_device !== undefined) player.input_device = joinInfo.input_device;
                            if (joinInfo.character !== undefined) player.character = joinInfo.character;
                        }
                    });
                });
                
                // ë©”íƒ€ë°ì´í„° ì—…ë°ì´íŠ¸
                Object.keys(joinData).forEach(playerId => {
                    if (this.data.metadata.playerMetadata[playerId]) {
                        Object.assign(this.data.metadata.playerMetadata[playerId], joinData[playerId]);
                    } else {
                        this.data.metadata.playerMetadata[playerId] = joinData[playerId];
                    }
                    
                    // playerStatsë„ ì—…ë°ì´íŠ¸
                    if (this.data.metadata.playerStats[playerId]) {
                        if (joinData[playerId].team !== undefined) {
                            this.data.metadata.playerStats[playerId].team = joinData[playerId].team;
                        }
                    }
                });
                
                // íŒ€ ëª©ë¡ ì¬ìˆ˜ì§‘
                const uniqueTeams = new Set();
                Object.values(this.data.metadata.playerStats).forEach(stats => {
                    if (stats.team) uniqueTeams.add(stats.team);
                });
                this.data.metadata.teams = Array.from(uniqueTeams).length > 0 ? Array.from(uniqueTeams) : ['CT', 'TERRORIST'];
                
                // ë§µ ëª©ë¡ ì¬ìˆ˜ì§‘
                const uniqueMaps = new Set();
                Object.values(this.data.metadata.playerMetadata).forEach(meta => {
                    if (meta.map) uniqueMaps.add(meta.map);
                });
                if (this.detectedMapName) uniqueMaps.add(this.detectedMapName);
                this.data.metadata.maps = Array.from(uniqueMaps);
                
                // ë¶„í¬ ì¬ê³„ì‚°
                this.recalculateDistributions();
                
                // UI ì—…ë°ì´íŠ¸
                this.updateUI();
                this.populatePlayerPicker();
                
                console.log('í”Œë ˆì´ì–´ ë°ì´í„° ì¡°ì¸ ì™„ë£Œ');
            }
            
            /**
             * OS, ì…ë ¥ ë””ë°”ì´ìŠ¤, ìºë¦­í„° ë¶„í¬ë¥¼ ì¬ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜
             */
            recalculateDistributions() {
                if (!this.data) return;
                
                const osDist = {};
                const inputDeviceDist = {};
                const characterDist = {};
                
                Object.values(this.data.metadata.playerMetadata).forEach(meta => {
                    if (meta.os) {
                        osDist[meta.os] = (osDist[meta.os] || 0) + 1;
                    }
                    if (meta.input_device) {
                        inputDeviceDist[meta.input_device] = (inputDeviceDist[meta.input_device] || 0) + 1;
                    }
                    if (meta.character) {
                        characterDist[meta.character] = (characterDist[meta.character] || 0) + 1;
                    }
                });
                
                this.data.metadata.matchInfo.os_distribution = osDist;
                this.data.metadata.matchInfo.input_device_distribution = inputDeviceDist;
                this.data.metadata.matchInfo.character_distribution = characterDist;
                
                console.log('ë¶„í¬ ì¬ê³„ì‚° ì™„ë£Œ:', {
                    os: osDist,
                    input_device: inputDeviceDist,
                    character: characterDist
                });
            }

            renderAimTrace() {
                const container = document.getElementById('event-log');
                container.innerHTML = '';
                
                // Focus ëª¨ë“œê°€ ì•„ë‹ˆë©´ ë©”ì‹œì§€ í‘œì‹œ
                if (!this.focusMode || !this.focusTickRange) {
                    const msgDiv = document.createElement('div');
                    msgDiv.style.cssText = 'padding: 40px; text-align: center; color: #8a8fa5; font-size: 16px;';
                    msgDiv.innerHTML = 'Aim TraceëŠ” Focus ëª¨ë“œì—ì„œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br>ì´ìƒ êµ¬ê°„ ë˜ëŠ” í‚¬ ì´ë²¤íŠ¸ë¥¼ ì„ íƒí•˜ì—¬ Focus ëª¨ë“œë¥¼ í™œì„±í™”í•˜ì„¸ìš”.';
                    container.appendChild(msgDiv);
                    return;
                }
                
                // ì´ìƒ êµ¬ê°„ ì„ íƒ ì‹œ ìƒˆë¡œìš´ ì‹œê°í™” ë°©ì‹ ì‚¬ìš©
                if (this.selectedAnomalySeq && this.focusTickRange.anchorTick) {
                    this.renderAimTraceContextView(container);
                    return;
                }
                
                // ê¸°ì¡´ ë°©ì‹ (ì´ë²¤íŠ¸ ì„ íƒ ì‹œ)
                const canvas = document.createElement('canvas');
                canvas.width = container.clientWidth - 20;
                canvas.height = container.clientHeight - 20;
                canvas.style.background = '#0a0e15';
                canvas.style.border = '1px solid #2a2f3e';
                container.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                const W = canvas.width;
                const H = canvas.height;

                // ì„ íƒëœ í”Œë ˆì´ì–´ ìš°ì„ ìˆœìœ„: focusPlayerId -> selectedEvent.attacker -> selectedPlayer -> ì²« ë²ˆì§¸
                let name = null;
                if (this.focusMode && this.focusPlayerId) {
                    // í¬ì»¤ìŠ¤ ëª¨ë“œì¼ ë•ŒëŠ” focusPlayerIdë¥¼ ìš°ì„  ì‚¬ìš©
                    name = this.focusPlayerId;
                    console.log('Aim Trace - í¬ì»¤ìŠ¤ ëª¨ë“œ: í”Œë ˆì´ì–´', name, 'ì˜ aim trace í‘œì‹œ');
                } else if (this.focusMode && this.selectedEvent && this.selectedEvent.attacker && this.selectedEvent.attacker.name) {
                    // í¬ì»¤ìŠ¤ ëª¨ë“œì¼ ë•ŒëŠ” ê³µê²©ìë¥¼ í‘œì‹œ
                    name = this.selectedEvent.attacker.name;
                    console.log('Aim Trace - í¬ì»¤ìŠ¤ ëª¨ë“œ: ê³µê²©ì', name, 'ì˜ aim trace í‘œì‹œ');
                } else if (this.selectedEvent && this.selectedEvent.attacker && this.selectedEvent.attacker.name) {
                    name = this.selectedEvent.attacker.name;
                } else {
                    name = this.selectedPlayer || ((this.data && this.data.metadata && this.data.metadata.players && this.data.metadata.players[0]) || null);
                }
                
                // ì‹¤ì œ ë°ì´í„°ì—ì„œ Aim ì •ë³´ ìˆ˜ì§‘
                let samples = [];
                if (name && this.data) {
                    console.log('Aim Trace - í”Œë ˆì´ì–´:', name);
                    
                    // í¬ì»¤ìŠ¤ ëª¨ë“œì¼ ë•ŒëŠ” í‹± ì¸ë±ìŠ¤ ë²”ìœ„ë¡œ ì§ì ‘ ìˆ˜ì§‘ (ëª¨ë“  ë°ì´í„° í¬ì¸íŠ¸, ìƒëµ ì—†ì´)
                    if (this.focusMode && this.focusTickRange) {
                        console.log('Aim Trace - í¬ì»¤ìŠ¤ ëª¨ë“œ: í‹± ë²”ìœ„', this.focusTickRange.startIdx, '-', this.focusTickRange.endIdx, 'ì´', (this.focusTickRange.endIdx - this.focusTickRange.startIdx + 1), 'í‹±');
                        let foundCount = 0;
                        let missingCount = 0;
                        
                        // ëª¨ë“  í‹±ì„ ìˆœíšŒí•˜ë©´ì„œ ì‹¤ì œ ë°ì´í„°ê°€ ìˆëŠ” í‹±ë§Œ ìˆ˜ì§‘ (ëª¨ë“  í¬ì¸íŠ¸ í‘œì‹œ, ì¤‘ë³µ ì œê±° ì—†ìŒ)
                        for (let idx = this.focusTickRange.startIdx; idx <= this.focusTickRange.endIdx; idx++) {
                            const pos = this.data.positions[idx];
                            if (pos) {
                                const player = pos.players.find(p => p.name === name);
                                if (player) {
                                    const yaw = player.yaw;
                                    const pitch = player.pitch;
                                    
                                    // ì‹¤ì œ ë°ì´í„°ê°€ ìˆëŠ” ê²½ìš°ë§Œ ì¶”ê°€
                                    if (yaw !== null && yaw !== undefined && !Number.isNaN(yaw) &&
                                        pitch !== null && pitch !== undefined && !Number.isNaN(pitch)) {
                                        // yaw/pitchë¥¼ aim_x, aim_yë¡œ ë³€í™˜
                                        const yawRad = yaw * Math.PI / 180;
                                        const pitchRad = pitch * Math.PI / 180;
                                        const aim_x = Math.cos(pitchRad) * Math.cos(yawRad);
                                        const aim_y = Math.cos(pitchRad) * Math.sin(yawRad);
                                        
                                        samples.push({
                                            aim_x: aim_x,
                                            aim_y: aim_y,
                                            yaw: yaw,
                                            pitch: pitch,
                                            time: pos.game_time,
                                            tick: pos.tick,
                                            tickIdx: idx,
                                            type: 'move'
                                        });
                                        foundCount++;
                                    } else {
                                        missingCount++;
                                    }
                                } else {
                                    missingCount++;
                                }
                            }
                        }
                        console.log('Aim Trace - í¬ì»¤ìŠ¤ ëª¨ë“œ ìˆ˜ì§‘:', foundCount, 'ìƒ˜í”Œ, ì—†ìŒ:', missingCount, '/ ì „ì²´ í‹±:', (this.focusTickRange.endIdx - this.focusTickRange.startIdx + 1));
                        console.log('Aim Trace - í¬ì»¤ìŠ¤ ëª¨ë“œ ë²”ìœ„:', this.focusTickRange.startIdx, '~', this.focusTickRange.endIdx, 'í‹±');
                    } else {
                        // ì¼ë°˜ ëª¨ë“œ: ì „ì²´ positionsì—ì„œ ìˆ˜ì§‘ (ëª¨ë“  í¬ì¸íŠ¸ í‘œì‹œ)
                        let foundCount = 0;
                        let missingCount = 0;
                        this.data.positions.forEach(pos => {
                            const player = pos.players.find(p => p.name === name);
                            if (player) {
                                const yaw = player.yaw;
                                const pitch = player.pitch;
                                if (yaw !== null && yaw !== undefined && !Number.isNaN(yaw) &&
                                    pitch !== null && pitch !== undefined && !Number.isNaN(pitch)) {
                                    // yaw/pitchë¥¼ aim_x, aim_yë¡œ ë³€í™˜
                                    const yawRad = yaw * Math.PI / 180;
                                    const pitchRad = pitch * Math.PI / 180;
                                    const aim_x = Math.cos(pitchRad) * Math.cos(yawRad);
                                    const aim_y = Math.cos(pitchRad) * Math.sin(yawRad);
                                    
                                    samples.push({
                                        aim_x: aim_x,
                                        aim_y: aim_y,
                                        yaw: yaw,
                                        pitch: pitch,
                                        time: pos.game_time,
                                        tick: pos.tick,
                                        type: 'move'
                                    });
                                    foundCount++;
                                } else {
                                    missingCount++;
                                }
                            } else {
                                missingCount++;
                            }
                        });
                        console.log('Aim Trace - ì¼ë°˜ ëª¨ë“œ ìˆ˜ì§‘:', foundCount, 'ìƒ˜í”Œ, ì—†ìŒ:', missingCount, '/ ì „ì²´:', this.data.positions.length);
                    }
                    
                    // ì´ë²¤íŠ¸ ì •ë³´ ìˆ˜ì§‘ (fire, hit, kill)
                    if (this.focusMode && this.focusTickRange && this.data.events) {
                        const startT = this.data.positions[this.focusTickRange.startIdx].game_time;
                        const endT = this.data.positions[this.focusTickRange.endIdx].game_time;
                        const startTick = this.data.positions[this.focusTickRange.startIdx].tick;
                        const endTick = this.data.positions[this.focusTickRange.endIdx].tick;
                        
                        // í¬ì»¤ìŠ¤ ë²”ìœ„ ë‚´ì˜ ì´ë²¤íŠ¸ í•„í„°ë§ (tick ê¸°ì¤€ìœ¼ë¡œë„ í™•ì¸)
                        const rangeEvents = this.data.events.filter(e => 
                            e.attacker && e.attacker.name === name &&
                            e.tick >= startTick && e.tick <= endTick &&
                            (e.event_type_lower === 'fire' || e.event_type_lower === 'hit' || e.event_type_lower === 'kill')
                        );
                        
                        console.log('Aim Trace - ë²”ìœ„ ë‚´ ì´ë²¤íŠ¸ ìˆ˜:', rangeEvents.length, 'ë²”ìœ„:', startTick, '-', endTick);
                        
                        rangeEvents.forEach(event => {
                            // ì´ë²¤íŠ¸ í‹±ì—ì„œ í”Œë ˆì´ì–´ ë°ì´í„° ì°¾ê¸°
                            const eventTickIdx = this.data.positions.findIndex(p => p.tick === event.tick);
                            if (eventTickIdx !== -1) {
                                const pos = this.data.positions[eventTickIdx];
                                const player = pos.players.find(p => p.name === name);
                                if (player && player.yaw !== null && player.pitch !== null && 
                                    !Number.isNaN(player.yaw) && !Number.isNaN(player.pitch)) {
                                    // yaw/pitchë¥¼ aim_x, aim_yë¡œ ë³€í™˜
                                    const yawRad = player.yaw * Math.PI / 180;
                                    const pitchRad = player.pitch * Math.PI / 180;
                                    const aim_x = Math.cos(pitchRad) * Math.cos(yawRad);
                                    const aim_y = Math.cos(pitchRad) * Math.sin(yawRad);
                                    
                                    const existing = samples.find(s => s.tick === event.tick);
                                    if (existing) {
                                        existing.type = event.event_type_lower;
                                        existing.eventType = event.event_type_lower;
                                        existing.event = event;
                                    } else {
                                        samples.push({
                                            aim_x: aim_x,
                                            aim_y: aim_y,
                                            yaw: player.yaw,
                                            pitch: player.pitch,
                                            time: pos.game_time,
                                            tick: pos.tick,
                                            tickIdx: eventTickIdx,
                                            type: event.event_type_lower,
                                            eventType: event.event_type_lower,
                                            event: event
                                        });
                                    }
                                } else {
                                    console.warn('Aim Trace - ì´ë²¤íŠ¸ í‹±ì— í”Œë ˆì´ì–´ ë°ì´í„° ì—†ìŒ:', event.event_type_lower, 'tick:', event.tick);
                                }
                            } else {
                                console.warn('Aim Trace - ì´ë²¤íŠ¸ í‹±ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ:', event.event_type_lower, 'tick:', event.tick);
                            }
                        });
                        
                        // selectedEventê°€ ìˆìœ¼ë©´ ëª…ì‹œì ìœ¼ë¡œ ì¶”ê°€ (ë²”ìœ„ ë°–ì´ì–´ë„)
                        if (this.selectedEvent && this.selectedEvent.attacker && this.selectedEvent.attacker.name === name) {
                            const selectedTickIdx = this.data.positions.findIndex(p => p.tick === this.selectedEvent.tick);
                            if (selectedTickIdx !== -1) {
                                const pos = this.data.positions[selectedTickIdx];
                                const player = pos.players.find(p => p.name === name);
                                if (player && player.yaw !== null && player.pitch !== null && 
                                    !Number.isNaN(player.yaw) && !Number.isNaN(player.pitch)) {
                                    const yawRad = player.yaw * Math.PI / 180;
                                    const pitchRad = player.pitch * Math.PI / 180;
                                    const aim_x = Math.cos(pitchRad) * Math.cos(yawRad);
                                    const aim_y = Math.cos(pitchRad) * Math.sin(yawRad);
                                    
                                    const existing = samples.find(s => s.tick === this.selectedEvent.tick);
                                    if (existing) {
                                        existing.type = this.selectedEvent.event_type_lower || 'fire';
                                        existing.eventType = this.selectedEvent.event_type_lower || 'fire';
                                        existing.event = this.selectedEvent;
                                    } else {
                                        samples.push({
                                            aim_x: aim_x,
                                            aim_y: aim_y,
                                            yaw: player.yaw,
                                            pitch: player.pitch,
                                            time: pos.game_time,
                                            tick: pos.tick,
                                            tickIdx: selectedTickIdx,
                                            type: this.selectedEvent.event_type_lower || 'fire',
                                            eventType: this.selectedEvent.event_type_lower || 'fire',
                                            event: this.selectedEvent
                                        });
                                    }
                                    console.log('Aim Trace - selectedEvent ì¶”ê°€:', this.selectedEvent.event_type_lower, 'tick:', this.selectedEvent.tick);
                                }
                            }
                        }
                    }
                    
                    samples.sort((a, b) => a.time - b.time);
                    console.log('Aim Trace - ìµœì¢… ìƒ˜í”Œ ìˆ˜:', samples.length);
                    
                    // ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ê²½ê³ 
                    if (samples.length === 0) {
                        console.warn('Aim Trace - ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. í”Œë ˆì´ì–´:', name);
                    }
                } else {
                    console.warn('Aim Trace - í”Œë ˆì´ì–´ ì´ë¦„ ë˜ëŠ” ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                }

                // í˜„ì¬ ì¬ìƒ êµ¬ê°„ - í¬ì»¤ìŠ¤ ëª¨ë“œì¼ ë•ŒëŠ” í¬ì»¤ìŠ¤ ë²”ìœ„ ì‚¬ìš© (tick ê¸°ì¤€)
                let tStart, tEnd;
                let tickStart, tickEnd;
                if (this.focusMode && this.focusTickRange) {
                    const startIdx = this.focusTickRange.startIdx;
                    const endIdx = this.focusTickRange.endIdx;
                    const startPos = this.data.positions[startIdx];
                    const endPos = this.data.positions[endIdx];
                    tStart = startPos.game_time;
                    tEnd = endPos.game_time;
                    tickStart = startPos.tick;
                    tickEnd = endPos.tick;
                    console.log('Aim Trace - í¬ì»¤ìŠ¤ ëª¨ë“œ ë²”ìœ„ (tick):', tickStart, '-', tickEnd);
                } else {
                    // ì´ í•¨ìˆ˜ëŠ” ë³´í†µ í¬ì»¤ìŠ¤ ëª¨ë“œì—ì„œë§Œ í˜¸ì¶œë˜ì§€ë§Œ, ì•ˆì „ì¥ì¹˜ë¡œ ì „ì²´ ë²”ìœ„ ì‚¬ìš©
                    const first = this.data.positions[0];
                    const last = this.data.positions[this.data.positions.length - 1];
                    tStart = first.game_time;
                    tEnd = last.game_time;
                    tickStart = first.tick;
                    tickEnd = last.tick;
                }
                const currentTime = (this.data.positions[this.currentTick] && this.data.positions[this.currentTick].game_time != null)
                    ? this.data.positions[this.currentTick].game_time
                    : tStart;
                
                // í¬ì»¤ìŠ¤ ëª¨ë“œ: ì „ì²´ samples ì‚¬ìš© (í•„í„°ë§ì€ tick ë²”ìœ„ë¡œ ì´ë¯¸ ì œí•œë¨)
                let windowSamples = samples;
                
                console.log('Aim Trace - ìœˆë„ìš° ìƒ˜í”Œ ìˆ˜:', windowSamples.length, 'tick ë²”ìœ„:', tickStart, '-', tickEnd);
                console.log('Aim Trace - ìƒ˜í”Œ aim_x ë²”ìœ„:', windowSamples.length > 0 ? [Math.min(...windowSamples.map(s => s.aim_x)).toFixed(4), Math.max(...windowSamples.map(s => s.aim_x)).toFixed(4)] : 'ì—†ìŒ');
                console.log('Aim Trace - ìƒ˜í”Œ aim_y ë²”ìœ„:', windowSamples.length > 0 ? [Math.min(...windowSamples.map(s => s.aim_y)).toFixed(4), Math.max(...windowSamples.map(s => s.aim_y)).toFixed(4)] : 'ì—†ìŒ');
                
                // ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ë©”ì‹œì§€ í‘œì‹œ
                if (samples.length === 0) {
                    ctx.fillStyle = '#8a8fa5';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('No aim data available for ' + (name || 'selected player'), W/2, H/2);
                    ctx.textAlign = 'left';
                    return;
                }
                
                if (windowSamples.length === 0) {
                    ctx.fillStyle = '#8a8fa5';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('No data in current time window', W/2, H/2);
                    ctx.textAlign = 'left';
                    return;
                }

                // ì‹¤ì œ ë°ì´í„° ë²”ìœ„ ê³„ì‚° (ë™ì  ìŠ¤ì¼€ì¼ë§) - Xì¶•: aim_x, Yì¶•: aim_y
                const aimXs = windowSamples.map(s => s.aim_x).filter(v => !Number.isNaN(v) && v !== null && v !== undefined);
                const aimYs = windowSamples.map(s => s.aim_y).filter(v => !Number.isNaN(v) && v !== null && v !== undefined);
                
                let xMin, xMax, yMin, yMax;
                if (aimXs.length > 0) {
                    const xMinVal = Math.min(...aimXs);
                    const xMaxVal = Math.max(...aimXs);
                    const xRange = xMaxVal - xMinVal;
                    const xPadding = Math.max(xRange * 0.1, 0.01);
                    xMin = xMinVal - xPadding;
                    xMax = xMaxVal + xPadding;
                } else {
                    xMin = -1;
                    xMax = 1;
                }
                
                if (aimYs.length > 0) {
                    const yMinVal = Math.min(...aimYs);
                    const yMaxVal = Math.max(...aimYs);
                    const yRange = yMaxVal - yMinVal;
                    const yPadding = Math.max(yRange * 0.1, 0.01);
                    yMin = yMinVal - yPadding;
                    yMax = yMaxVal + yPadding;
                } else {
                    yMin = -1;
                    yMax = 1;
                }
                
                console.log('Aim Trace - ì¢Œí‘œ ë²”ìœ„:', {aim_x: [xMin.toFixed(4), xMax.toFixed(4)], aim_y: [yMin.toFixed(4), yMax.toFixed(4)]});
                
                const pad = 40;
                
                function xScale(v){ 
                    if (xMax === xMin) return W / 2;
                    return pad + (v - xMin) / (xMax - xMin) * (W - 2*pad); 
                }
                function yScale(v){ 
                    if (yMax === yMin) return H / 2;
                    return H - (pad + (v - yMin) / (yMax - yMin) * (H - 2*pad)); 
                }

                // ë°°ê²½ ê·¸ë¦¬ë“œ (aim_x/aim_y ë²”ìœ„ì— ë§ì¶°)
                ctx.strokeStyle = '#2a2f3e'; ctx.lineWidth = 1;
                const xRange = xMax - xMin;
                const yRange = yMax - yMin;
                const gridStepX = Math.max(xRange / 20, 0.01);
                const gridStepY = Math.max(yRange / 15, 0.01);
                
                for (let x = Math.floor(xMin / gridStepX) * gridStepX; x <= xMax; x += gridStepX) {
                    const sx = xScale(x);
                    if (sx >= pad && sx <= W - pad) {
                        ctx.beginPath(); ctx.moveTo(sx, pad); ctx.lineTo(sx, H - pad); ctx.stroke();
                    }
                }
                for (let y = Math.floor(yMin / gridStepY) * gridStepY; y <= yMax; y += gridStepY) {
                    const sy = yScale(y);
                    if (sy >= pad && sy <= H - pad) {
                        ctx.beginPath(); ctx.moveTo(pad, sy); ctx.lineTo(W - pad, sy); ctx.stroke();
                    }
                }
                
                // ì¶• ë¼ë²¨ (ë²”ìœ„ í‘œì‹œ)
                ctx.fillStyle = '#8a8fa5'; ctx.font = '12px Arial';
                ctx.fillText(`aim_x [${xMin.toFixed(4)} ~ ${xMax.toFixed(4)}]`, W/2 - 100, H-10);
                ctx.save(); ctx.translate(10, H/2); ctx.rotate(-Math.PI/2); 
                ctx.fillText(`aim_y [${yMin.toFixed(4)} ~ ${yMax.toFixed(4)}]`, 0, 0); ctx.restore();

                // ëª¨ë“  í¬ì¸íŠ¸ í‘œì‹œ (ìƒëµ ì—†ì´ ëª¨ë“  ë°ì´í„° í¬ì¸íŠ¸)
                console.log('Aim Trace - ë Œë”ë§í•  í¬ì¸íŠ¸ ìˆ˜:', windowSamples.length);
                
                // ê²½ë¡œ ì—°ê²°ì„  (ê¸°ë³¸ íšŒìƒ‰, Layer 1) - ëª¨ë“  í¬ì¸íŠ¸ ì—°ê²°
                if (windowSamples.length > 1){
                    ctx.beginPath();
                    ctx.strokeStyle = '#5a637a'; ctx.lineWidth = 1.5;
                    let firstPoint = true;
                    for (let i = 0; i < windowSamples.length; i++) {
                        const s = windowSamples[i];
                        const x = xScale(s.aim_x);
                        const y = yScale(s.aim_y);
                        if (firstPoint) {
                            ctx.moveTo(x, y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                }
                
                // í¬ì¸íŠ¸ ë Œë”ë§ (ëª¨ë“  í¬ì¸íŠ¸ í‘œì‹œ)
                if (windowSamples.length === 0) {
                    console.warn('Aim Trace - ë Œë”ë§í•  í¬ì¸íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.');
                } else {
                    console.log('Aim Trace - ë Œë”ë§ ì‹œì‘: í¬ì¸íŠ¸', windowSamples.length, 'ê°œ');
                }
                
                // Layer 2 - í¬ì¸íŠ¸ ë Œë”ë§ (ê¸°ë³¸ ì  + ì´ë²¤íŠ¸ í¬ì¸íŠ¸ ê°•ì¡°)
                windowSamples.forEach((s, idx) => {
                    const x = xScale(s.aim_x);
                    const y = yScale(s.aim_y);
                    
                    // ìº”ë²„ìŠ¤ ë²”ìœ„ ì²´í¬
                    if (x < 0 || x > W || y < 0 || y > H) {
                        return; // ë²”ìœ„ë¥¼ ë²—ì–´ë‚œ í¬ì¸íŠ¸ëŠ” ìŠ¤í‚µ
                    }
                    
                    if (s.type === 'kill') {
                        // Kill ì‹œì : ì§„ë¹¨ê°• í° ì› + í…Œë‘ë¦¬
                        ctx.fillStyle = '#cc0000';
                        ctx.beginPath(); ctx.arc(x, y, 8, 0, Math.PI*2); ctx.fill();
                        ctx.strokeStyle = '#ff3333'; ctx.lineWidth = 3; ctx.stroke();
                    } else if (s.type === 'hit') {
                        // Hit ì‹œì : ì£¼í™©ìƒ‰ ì›
                        ctx.fillStyle = '#ffa500';
                        ctx.beginPath(); ctx.arc(x, y, 6, 0, Math.PI*2); ctx.fill();
                    } else if (s.type === 'fire') {
                        // Fire ì‹œì : í°ìƒ‰ ì›
                        ctx.fillStyle = '#dddddd';
                        ctx.beginPath(); ctx.arc(x, y, 5, 0, Math.PI*2); ctx.fill();
                    } else {
                        // ì¼ë°˜ ì´ë™ í¬ì¸íŠ¸: ì‘ì€ íšŒìƒ‰ ì  (ëª¨ë‘ í‘œì‹œ)
                        ctx.fillStyle = '#8a8fa5';
                        ctx.beginPath(); ctx.arc(x, y, 2, 0, Math.PI*2); ctx.fill();
                    }
                });

                // í˜„ì¬ ì‹œì  í‘œì‹œ (íŒŒë‘ í° ì )
                const currentTickIdx = this.currentTick;
                const currentPos = this.data.positions[currentTickIdx];
                if (currentPos) {
                    const currentPlayer = currentPos.players.find(p => p.name === name);
                    if (currentPlayer && currentPlayer.yaw !== null && currentPlayer.pitch !== null && 
                        !Number.isNaN(currentPlayer.yaw) && !Number.isNaN(currentPlayer.pitch)) {
                        const yawRad = currentPlayer.yaw * Math.PI / 180;
                        const pitchRad = currentPlayer.pitch * Math.PI / 180;
                        const curr_aim_x = Math.cos(pitchRad) * Math.cos(yawRad);
                        const curr_aim_y = Math.cos(pitchRad) * Math.sin(yawRad);
                        
                        const cx = xScale(curr_aim_x);
                        const cy = yScale(curr_aim_y);
                        ctx.fillStyle = '#4a90e2';
                        ctx.beginPath(); ctx.arc(cx, cy, 6, 0, Math.PI*2); ctx.fill();
                        ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 2; ctx.stroke();
                    }
                }

                // ì´ë²¤íŠ¸ í…ìŠ¤íŠ¸ í‘œì‹œ (ì  ìœ„ì—)
                windowSamples.forEach(s => {
                    // eventType ë˜ëŠ” typeì´ ìˆê³ , fire/hit/kill ì¤‘ í•˜ë‚˜ë©´ í‘œì‹œ
                    const eventType = s.eventType || s.type;
                    if (eventType && (eventType === 'fire' || eventType === 'hit' || eventType === 'kill')) {
                        const x = xScale(s.aim_x);
                        const y = yScale(s.aim_y);
                        
                        // ìº”ë²„ìŠ¤ ë²”ìœ„ ì²´í¬
                        if (x < 0 || x > W || y < 0 || y > H) return;
                        
                        let color = '#ffffff';
                        if (eventType === 'kill') color = '#ff3333';
                        else if (eventType === 'hit') color = '#ffa500';
                        else if (eventType === 'fire') color = '#dddddd';
                        
                        ctx.fillStyle = color;
                        ctx.font = 'bold 11px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(eventType.toUpperCase(), x, y - 15);
                        ctx.textAlign = 'left';
                    }
                });

                // ë²”ë¡€
                const legend = [
                    {label:'Current', color:'#4a90e2'},
                    {label:'Fire', color:'#dddddd'},
                    {label:'Hit', color:'#ffa500'},
                    {label:'Kill', color:'#ff3333'}
                ];
                let lx = pad, ly = pad-12;
                legend.forEach(l =>{
                    ctx.fillStyle = l.color; ctx.beginPath(); ctx.arc(lx,ly,4,0,Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#8a8fa5'; ctx.fillText(l.label, lx+10, ly+4);
                    lx += 80;
                });

                // ì œëª© ë° ê¸°ë³¸ êµì „ ì •ë³´ (ì™¼ìª½ ìƒë‹¨)
                ctx.fillStyle = '#ffffff';
                ctx.font = '14px Arial';
                
                const playerIdText = name || 'N/A';
                let attackerText = '-';
                let weaponText = '-';
                let distanceText = '-';
                let victimText = '-';
                
                // í‚¬ ì´ë²¤íŠ¸ê°€ ìˆìœ¼ë©´ ë¬´ê¸° ì •ë³´ ë° êµì „ ê±°ë¦¬ ê³„ì‚°
                if (this.selectedEvent && this.selectedEvent.attacker && this.selectedEvent.victim) {
                    // ê³µê²©ì ì •ë³´
                    if (this.selectedEvent.attacker.name) {
                        attackerText = this.selectedEvent.attacker.name;
                    }
                    
                    // ë¬´ê¸° ì •ë³´
                    if (this.selectedEvent.weapon) {
                        weaponText = String(this.selectedEvent.weapon);
                    }
                    
                    // í”¼í•´ì ì •ë³´
                    if (this.selectedEvent.victim && this.selectedEvent.victim.name) {
                        victimText = this.selectedEvent.victim.name;
                    }
                    
                    const attackerPos = this.selectedEvent.attacker.position;
                    const victimPos = this.selectedEvent.victim.position;
                    if (attackerPos && victimPos && attackerPos[0] !== null && victimPos[0] !== null) {
                        // 3D ìœ í´ë¦¬ë“œ ê±°ë¦¬ ê³„ì‚° (position: [X, Z, Y])
                        const dx = attackerPos[0] - victimPos[0];
                        const dy = attackerPos[1] - victimPos[1];
                        const dz = attackerPos[2] - victimPos[2];
                        const distanceUnits = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        distanceText = `${distanceUnits.toFixed(1)} units`;
                    }
                }
                
                // ìƒë‹¨ ë¼ë²¨: í”Œë ˆì´ì–´ IDì™€ í‚¬ ì´ë²¤íŠ¸ ìš”ì•½ í•œ ì¤„ë¡œ í‘œì‹œ
                const titleText = `í”Œë ˆì´ì–´ ID: ${playerIdText} (ê³µê²©ì: ${attackerText} / ì‚¬ìš© ë¬´ê¸°: ${weaponText} / í”¼í•´ì: ${victimText} / êµì „ ê±°ë¦¬: ${distanceText})`;
                ctx.fillText(titleText, pad, 20);
                
                // ë§ˆìš°ìŠ¤ íœ ë¡œ bottom-panel ë†’ì´ ì¡°ì ˆ (Ctrl í‚¤ ëˆ„ë¥´ê³  ìˆì„ ë•Œ)
                this.setupAimTraceWheelResize(container);
            }

            renderAimTraceContextView(container) {
                // ì´ìƒ êµ¬ê°„ ì„ íƒ ì‹œ ìƒˆë¡œìš´ Context View ì‹œê°í™”
                if (!this.selectedAnomalySeq || !this.focusTickRange || !this.focusPlayerId) {
                    const msgDiv = document.createElement('div');
                    msgDiv.style.cssText = 'padding: 40px; text-align: center; color: #8a8fa5; font-size: 16px;';
                    msgDiv.innerHTML = 'ì´ìƒ êµ¬ê°„ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.';
                    container.appendChild(msgDiv);
                    return;
                }

                const playerId = this.focusPlayerId;
                const anchorTick = this.focusTickRange.anchorTick;
                const startIdx = this.focusTickRange.startIdx;
                const endIdx = this.focusTickRange.endIdx;
                const anchorIdx = this.focusTickRange.anchorIdx;

                // ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ ì„¤ì • (ìœ ë™ì  í¬ê¸°, ìŠ¤í¬ë¡¤ ê°€ëŠ¥, ì¤‘ì•™ ì •ë ¬)
                const fixedSize = 600; // 1:1 ë¹„ìœ¨ ê³ ì • í¬ê¸°
                // containerì˜ ë¶€ëª¨(#event-log) í¬ê¸°ì— ë§ì¶° ìœ ë™ì ìœ¼ë¡œ ì¡°ì •, ì¤‘ì•™ ì •ë ¬
                container.style.cssText = `display: flex; gap: 20px; padding: 10px; background: #0a0e15; overflow: auto; min-width: ${fixedSize * 2 + 60}px; min-height: ${fixedSize + 60}px; width: 100%; height: 100%; justify-content: center; align-items: center;`;
                
                // ìŠ¤í¬ë¡¤ ê°€ëŠ¥í•˜ë„ë¡ wheel ì´ë²¤íŠ¸ ì²˜ë¦¬ (Ctrl í‚¤ê°€ ì•„ë‹ ë•Œë§Œ ìŠ¤í¬ë¡¤ í—ˆìš©)
                container.addEventListener('wheel', (e) => {
                    // Ctrl í‚¤ë¥¼ ëˆ„ë¥´ê³  ìˆì„ ë•ŒëŠ” panel ë†’ì´ ì¡°ì ˆì„ ìœ„í•´ preventDefault í˜¸ì¶œí•˜ì§€ ì•ŠìŒ (setupAimTraceWheelResizeì—ì„œ ì²˜ë¦¬)
                    // Ctrl í‚¤ê°€ ì•„ë‹ ë•ŒëŠ” container ë‚´ë¶€ì—ì„œ ìŠ¤í¬ë¡¤ì´ ê°€ëŠ¥í•˜ë„ë¡ ê¸°ë³¸ ë™ì‘ í—ˆìš©
                }, { passive: true });
                
                // ì™¼ìª½: 2D Context View (aim_x vs aim_y) - 1:1 ë¹„ìœ¨ ê³ ì •
                const wrapper2D = document.createElement('div');
                wrapper2D.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 8px;';
                
                const title2D = document.createElement('div');
                title2D.textContent = '2D ì—ì„ ì¶”ì ';
                title2D.style.cssText = 'color: #ffffff; font-size: 16px; font-weight: bold; font-family: Arial, sans-serif;';
                wrapper2D.appendChild(title2D);
                
                const canvas2D = document.createElement('canvas');
                canvas2D.width = fixedSize;
                canvas2D.height = fixedSize;
                canvas2D.style.width = fixedSize + 'px';
                canvas2D.style.height = fixedSize + 'px';
                canvas2D.style.background = '#0a0e15';
                canvas2D.style.border = '1px solid #2a2f3e';
                canvas2D.style.flexShrink = '0';
                wrapper2D.appendChild(canvas2D);
                container.appendChild(wrapper2D);
                
                // ì˜¤ë¥¸ìª½: 1D Timeline View (tick offset vs tick_pred_error) - 1:1 ë¹„ìœ¨ ê³ ì •
                const wrapper1D = document.createElement('div');
                wrapper1D.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 8px;';
                
                const title1D = document.createElement('div');
                // í”Œë ˆì´ì–´ ì´ë¦„ ê°€ì ¸ì˜¤ê¸°
                const playerName = playerId || this.selectedPlayer || (this.data && this.data.metadata && this.data.metadata.players && this.data.metadata.players[0]) || 'í”Œë ˆì´ì–´';
                title1D.textContent = `ì •ìƒ ìœ ì € í‰ê·  VS ${playerName}ì˜ ì˜ˆì¸¡ ì˜¤ì°¨ ë¹„êµ`;
                title1D.style.cssText = 'color: #ffffff; font-size: 16px; font-weight: bold; font-family: Arial, sans-serif;';
                wrapper1D.appendChild(title1D);
                
                const canvas1D = document.createElement('canvas');
                canvas1D.width = fixedSize;
                canvas1D.height = fixedSize;
                canvas1D.style.width = fixedSize + 'px';
                canvas1D.style.height = fixedSize + 'px';
                canvas1D.style.background = '#0a0e15';
                canvas1D.style.border = '1px solid #2a2f3e';
                canvas1D.style.flexShrink = '0';
                wrapper1D.appendChild(canvas1D);
                container.appendChild(wrapper1D);

                const ctx2D = canvas2D.getContext('2d');
                const ctx1D = canvas1D.getContext('2d');
                const W2D = canvas2D.width;
                const H2D = canvas2D.height;
                const W1D = canvas1D.width;
                const H1D = canvas1D.height;

                // ë°ì´í„° ìˆ˜ì§‘: anchor tick ê¸°ì¤€ìœ¼ë¡œ pre-fire, anomaly, post-fire êµ¬ë¶„
                const samples = [];
                let lastStableBeforeSnap = null;
                let fireTickData = null;

                for (let idx = startIdx; idx <= endIdx; idx++) {
                    const pos = this.data.positions[idx];
                    if (!pos) continue;
                    
                    const player = pos.players.find(p => p.name === playerId);
                    if (!player) continue;

                    // yaw, pitchë¥¼ aim_x, aim_yë¡œ ë³€í™˜
                    const yawRad = (player.yaw || 0) * Math.PI / 180;
                    const pitchRad = (player.pitch || 0) * Math.PI / 180;
                    const aim_x = Math.cos(pitchRad) * Math.cos(yawRad);
                    const aim_y = Math.cos(pitchRad) * Math.sin(yawRad);

                    // tick_pred_error, is_anomalous_tick ì •ë³´ ê°€ì ¸ì˜¤ê¸° (dfì—ì„œ ê·¸ëŒ€ë¡œ ì‚¬ìš©, ê°€ê³µ ì—†ìŒ)
                    const tickAnom = this.anomalyByTick ? this.anomalyByTick.get(pos.tick) : null;
                    const tick_pred_error = tickAnom ? tickAnom.score : 0; // dfì˜ tick_pred_error ê·¸ëŒ€ë¡œ ì‚¬ìš©
                    const is_anomalous_tick = tickAnom ? tickAnom.isAnom : false;

                    // xì¶•: segment_tick_id - anchor_tick (fire ê¸°ì¤€ ìƒëŒ€ ì‹œê°„)
                    // í˜„ì¬ tickì´ segment_tick_idì™€ ë™ì¼í•œ ì˜ë¯¸ë¡œ ì‚¬ìš©ë¨
                    const tickOffset = pos.tick - anchorTick; // segment_tick_id - anchor_tick
                    
                    // ì´ë²¤íŠ¸ íƒ€ì… í™•ì¸ (fire, hit, kill)
                    let eventType = null;
                    if (this.data && this.data.events) {
                        const event = this.data.events.find(e => 
                            e.tick === pos.tick && 
                            e.attacker && e.attacker.name === playerId
                        );
                        if (event) {
                            if (event.event_type_lower === 'kill') eventType = 'kill';
                            else if (event.event_type_lower === 'hit') eventType = 'hit';
                            else if (event.event_type_lower === 'fire') eventType = 'fire';
                        }
                    }
                    
                    // fire tick í™•ì¸ (anchor tick ë˜ëŠ” ì´ë²¤íŠ¸)
                    const isFireTick = pos.tick === anchorTick || eventType === 'fire';
                    if (isFireTick) {
                        fireTickData = { aim_x, aim_y, tick: pos.tick, tickOffset, eventType: eventType || 'fire' };
                    }

                    // snap ì§ì „ ë§ˆì§€ë§‰ stable tick ì°¾ê¸°
                    if (tickOffset < 0 && !is_anomalous_tick) {
                        lastStableBeforeSnap = { aim_x, aim_y, tick: pos.tick, tickOffset };
                    }

                    samples.push({
                        aim_x,
                        aim_y,
                        tick: pos.tick,
                        tickOffset,
                        tick_pred_error,
                        is_anomalous_tick,
                        isFireTick,
                        eventType
                    });
                }

                if (samples.length === 0) {
                    ctx2D.fillStyle = '#8a8fa5';
                    ctx2D.font = '16px Arial';
                    ctx2D.textAlign = 'center';
                    ctx2D.fillText('ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.', W2D/2, H2D/2);
                    return;
                }

                // 2D Context View ë Œë”ë§
                // fire ê¸°ì¤€ìœ¼ë¡œ ì¶• ê³ ì • (íŒŒì´ì¬ ì½”ë“œ ì°¸ê³ )
                const pad = 50;
                const fireX = fireTickData ? fireTickData.aim_x : samples[Math.floor(samples.length / 2)].aim_x;
                const fireY = fireTickData ? fireTickData.aim_y : samples[Math.floor(samples.length / 2)].aim_y;
                
                // fire ê¸°ì¤€ìœ¼ë¡œ ìµœëŒ€ ê±°ë¦¬ ê³„ì‚°
                const maxDist = Math.max(
                    ...samples.map(s => Math.max(
                        Math.abs(s.aim_x - fireX),
                        Math.abs(s.aim_y - fireY)
                    ))
                );
                const r = maxDist * 1.3 || 1; // íŒŒì´ì¬ ì½”ë“œì™€ ë™ì¼í•œ 1.3 ë°°ìœ¨
                
                const xMin = fireX - r;
                const xMax = fireX + r;
                const yMin = fireY - r;
                const yMax = fireY + r;
                const xRange = xMax - xMin || 1;
                const yRange = yMax - yMin || 1;

                // 2D Context View ë²”ìœ„ ì¶œë ¥
                console.log('=== 2D Context View (aim_x vs aim_y) ë²”ìœ„ ===');
                console.log('Xì¶• (aim_x):', xMin.toFixed(6), '~', xMax.toFixed(6), '(ë²”ìœ„:', xRange.toFixed(6), ')');
                console.log('Yì¶• (aim_y):', yMin.toFixed(6), '~', yMax.toFixed(6), '(ë²”ìœ„:', yRange.toFixed(6), ')');
                console.log('Fire ê¸°ì¤€ì :', { fireX: fireX.toFixed(6), fireY: fireY.toFixed(6) });
                console.log('ë°˜ì§€ë¦„ r:', r.toFixed(6));

                function xScale2D(x) { return pad + (x - xMin) / xRange * (W2D - 2*pad); }
                function yScale2D(y) { return H2D - (pad + (y - yMin) / yRange * (H2D - 2*pad)); }

                // ë°°ê²½ ê·¸ë¦¬ë“œ
                ctx2D.strokeStyle = '#2a2f3e';
                ctx2D.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    const x = pad + (W2D - 2*pad) * i / 10;
                    ctx2D.beginPath();
                    ctx2D.moveTo(x, pad);
                    ctx2D.lineTo(x, H2D - pad);
                    ctx2D.stroke();
                }
                for (let i = 0; i <= 10; i++) {
                    const y = pad + (H2D - 2*pad) * i / 10;
                    ctx2D.beginPath();
                    ctx2D.moveTo(pad, y);
                    ctx2D.lineTo(W2D - pad, y);
                    ctx2D.stroke();
                }

                // ëª¨ë“  ìƒ˜í”Œì„ tickOffset ìˆœì„œëŒ€ë¡œ ì •ë ¬
                samples.sort((a, b) => a.tickOffset - b.tickOffset);
                
                // êµ¬ê°„ ì •ì˜ (íŒŒì´ì¬ ì½”ë“œ ì°¸ê³ )
                const preStable = samples.filter(s => s.tickOffset <= -6);
                const preAnom = samples.filter(s => s.tickOffset >= -5 && s.tickOffset <= -1);
                const postStable = samples.filter(s => s.tickOffset >= 1);
                const lastPreStable = samples.filter(s => s.tickOffset >= -8 && s.tickOffset <= -6);
                
                // ì „ì²´ ì¡°ì¤€ ê¶¤ì ì„ ì„ ìœ¼ë¡œ ì—°ê²° (ì‹œê°„ ìˆœì„œëŒ€ë¡œ) - íŒŒì´ì¬ ì½”ë“œ: lightgray
                if (samples.length > 1) {
                    ctx2D.strokeStyle = 'rgba(211, 211, 211, 0.8)'; // lightgray
                    ctx2D.lineWidth = 1;
                    ctx2D.beginPath();
                    ctx2D.moveTo(xScale2D(samples[0].aim_x), yScale2D(samples[0].aim_y));
                    for (let i = 1; i < samples.length; i++) {
                        ctx2D.lineTo(xScale2D(samples[i].aim_x), yScale2D(samples[i].aim_y));
                    }
                    ctx2D.stroke();
                }
                
                // pre-fire stable (íŒŒì´ì¬: #444444, alpha=0.25, s=16)
                preStable.forEach(s => {
                    ctx2D.fillStyle = 'rgba(68, 68, 68, 0.25)'; // #444444
                    ctx2D.beginPath();
                    ctx2D.arc(xScale2D(s.aim_x), yScale2D(s.aim_y), 4, 0, Math.PI*2);
                    ctx2D.fill();
                });

                // post-fire stable (íŒŒì´ì¬: #6baed6, alpha=0.35, s=16)
                postStable.forEach(s => {
                    ctx2D.fillStyle = 'rgba(107, 174, 214, 0.35)'; // #6baed6
                    ctx2D.beginPath();
                    ctx2D.arc(xScale2D(s.aim_x), yScale2D(s.aim_y), 4, 0, Math.PI*2);
                    ctx2D.fill();
                });

                // pre-fire snap (anomaly) ì—°ê²°ì„  (íŒŒì´ì¬: red, linewidth=3)
                for (let i = 0; i < samples.length - 1; i++) {
                    if (samples[i].is_anomalous_tick && samples[i+1].is_anomalous_tick) {
                        ctx2D.strokeStyle = '#ff0000';
                        ctx2D.lineWidth = 3;
                        ctx2D.beginPath();
                        ctx2D.moveTo(xScale2D(samples[i].aim_x), yScale2D(samples[i].aim_y));
                        ctx2D.lineTo(xScale2D(samples[i+1].aim_x), yScale2D(samples[i+1].aim_y));
                        ctx2D.stroke();
                    }
                }
                
                // pre-fire snap (anomaly) ì  (íŒŒì´ì¬: red, alpha=1.0, s=36)
                preAnom.forEach(s => {
                    ctx2D.fillStyle = '#ff0000';
                    ctx2D.beginPath();
                    ctx2D.arc(xScale2D(s.aim_x), yScale2D(s.aim_y), 6, 0, Math.PI*2);
                    ctx2D.fill();
                });

                // fire tick (X ë§ˆì»¤) + ì´ë²¤íŠ¸ íƒ€ì… í‘œì‹œ - íŒŒì´ì¬ ì½”ë“œì™€ ë™ì¼: blue
                if (fireTickData) {
                    ctx2D.strokeStyle = '#0000ff'; // blue (íŒŒì´ì¬ ì½”ë“œì™€ ë™ì¼)
                    ctx2D.lineWidth = 3;
                    const fx = xScale2D(fireTickData.aim_x);
                    const fy = yScale2D(fireTickData.aim_y);
                    ctx2D.beginPath();
                    ctx2D.moveTo(fx - 10, fy - 10);
                    ctx2D.lineTo(fx + 10, fy + 10);
                    ctx2D.moveTo(fx - 10, fy + 10);
                    ctx2D.lineTo(fx + 10, fy - 10);
                    ctx2D.stroke();
                    
                    // ì´ë²¤íŠ¸ íƒ€ì… ë¼ë²¨ í‘œì‹œ
                    const eventLabel = fireTickData.eventType || 'fire';
                    ctx2D.fillStyle = '#0000ff'; // blue (íŒŒì´ì¬ ì½”ë“œì™€ ë™ì¼)
                    ctx2D.font = 'bold 12px Arial';
                    ctx2D.textAlign = 'center';
                    ctx2D.fillText(eventLabel.toUpperCase(), fx, fy - 15);
                }
                
                // ë‹¤ë¥¸ ì´ë²¤íŠ¸ íƒ€ì… í‘œì‹œ (hit, kill)
                samples.forEach(s => {
                    if (s.eventType && s.eventType !== 'fire') {
                        const ex = xScale2D(s.aim_x);
                        const ey = yScale2D(s.aim_y);
                        let color = '#ffa500'; // hit ê¸°ë³¸ ìƒ‰ìƒ
                        if (s.eventType === 'kill') color = '#ff3333';
                        
                        ctx2D.fillStyle = color;
                        ctx2D.beginPath();
                        ctx2D.arc(ex, ey, 5, 0, Math.PI*2);
                        ctx2D.fill();
                        
                        ctx2D.fillStyle = color;
                        ctx2D.font = 'bold 11px Arial';
                        ctx2D.textAlign = 'center';
                        ctx2D.fillText(s.eventType.toUpperCase(), ex, ey - 12);
                    }
                });

                // snap ì§ì „ ë§ˆì§€ë§‰ stable tick (ê²€ì€ í…Œë‘ë¦¬ ì›)
                if (lastStableBeforeSnap) {
                    ctx2D.fillStyle = '#ffffff';
                    ctx2D.beginPath();
                    ctx2D.arc(xScale2D(lastStableBeforeSnap.aim_x), yScale2D(lastStableBeforeSnap.aim_y), 5, 0, Math.PI*2);
                    ctx2D.fill();
                    ctx2D.strokeStyle = '#000000';
                    ctx2D.lineWidth = 2;
                    ctx2D.stroke();
                }

                // ì¶• ë¼ë²¨
                ctx2D.fillStyle = '#8a8fa5';
                ctx2D.font = '12px Arial';
                ctx2D.textAlign = 'center';
                ctx2D.fillText('aim_x', W2D/2, H2D - 10);
                ctx2D.save();
                ctx2D.translate(10, H2D/2);
                ctx2D.rotate(-Math.PI/2);
                ctx2D.fillText('aim_y', 0, 0);
                ctx2D.restore();

                // 1D Timeline View ë Œë”ë§
                // xì¶•: segment_tick_id - anchor_tick (fire ê¸°ì¤€ ìƒëŒ€ ì‹œê°„, ê°€ê³µ ì—†ìŒ)
                // yì¶•: tick_pred_error (dfì—ì„œ ê·¸ëŒ€ë¡œ ì‚¬ìš©, ê°€ê³µ ì—†ìŒ)
                const tickOffsets = samples.map(s => s.tickOffset); // segment_tick_id - anchor_tick
                const errors = samples.map(s => s.tick_pred_error); // dfì˜ tick_pred_error ê·¸ëŒ€ë¡œ
                const offsetMin = Math.min(...tickOffsets);
                const offsetMax = Math.max(...tickOffsets);
                
                // ì‹¤ì œ tick_pred_error ê°’ ë²”ìœ„ ê³„ì‚°
                const actualErrorMin = errors.length > 0 ? Math.min(...errors) : 0;
                const actualErrorMax = errors.length > 0 ? Math.max(...errors) : 1;
                const actualErrorRange = actualErrorMax - actualErrorMin;
                
                // buffer ì¶”ê°€: ì‹¤ì œ ìµœëŒ€ê°’ì˜ 20% ë˜ëŠ” ìµœì†Œ 0.01 ì¶”ê°€í•˜ì—¬ ì´ìƒ ì ìˆ˜ê°€ ì˜ ë³´ì´ë„ë¡
                const errorBuffer = Math.max(actualErrorRange * 0.2, actualErrorMax * 0.1, 0.01);
                const errorMin = Math.max(0, actualErrorMin - errorBuffer * 0.1); // ìµœì†Œê°’ë„ ì•½ê°„ì˜ buffer (0 ì´í•˜ë¡œëŠ” ì•ˆ ê°€ë„ë¡)
                const errorMax = actualErrorMax + errorBuffer;
                const errorRange = errorMax - errorMin || 1; // 0ìœ¼ë¡œ ë‚˜ëˆ„ê¸° ë°©ì§€
                
                // ì •ìƒ ìœ ì €ì˜ error í‰ê· ê°’ (ëª©ì—… ë°ì´í„°)
                // ì¼ë°˜ì ìœ¼ë¡œ ì •ìƒ ìœ ì €ëŠ” tick_pred_errorê°€ ë§¤ìš° ì‘ìŒ (ì˜ˆ: 0.001 ~ 0.005 ë²”ìœ„)
                // ì‹¤ì œ ë°ì´í„°ì˜ í‰ê· ê°’ì„ ê³„ì‚°í•˜ë˜, ì´ìƒ êµ¬ê°„ì„ ì œì™¸í•œ ê°’ë“¤ì˜ í‰ê·  ì‚¬ìš©
                const normalSamples = samples.filter(s => !s.is_anomalous_tick);
                const normalErrors = normalSamples.map(s => s.tick_pred_error);
                const normalUserAvgError = normalErrors.length > 0 
                    ? normalErrors.reduce((sum, e) => sum + e, 0) / normalErrors.length 
                    : (actualErrorMax * 0.1); // ê¸°ë³¸ê°’: ìµœëŒ€ê°’ì˜ 10%
                
                console.log('ì •ìƒ ìœ ì € í‰ê·  error:', normalUserAvgError.toFixed(6), '(ì •ìƒ ìƒ˜í”Œ ìˆ˜:', normalErrors.length, ')');

                // 1D Timeline View ë²”ìœ„ ì¶œë ¥
                console.log('=== 1D Timeline View (tick offset vs tick_pred_error) ë²”ìœ„ ===');
                console.log('Xì¶• (tick offset):', offsetMin, '~', offsetMax, '(ë²”ìœ„:', (offsetMax - offsetMin), ')');
                console.log('Yì¶• (tick_pred_error):', errorMin.toFixed(6), '~', errorMax.toFixed(6), '(ë²”ìœ„:', errorRange.toFixed(6), ')');
                console.log('ì‹¤ì œ tick_pred_error ê°’ ë²”ìœ„:', actualErrorMin.toFixed(6), '~', actualErrorMax.toFixed(6));
                console.log('Buffer:', errorBuffer.toFixed(6));
                console.log('ì´ìƒ êµ¬ê°„ tick_pred_error ê°’ë“¤:', samples.filter(s => s.is_anomalous_tick).map(s => s.tick_pred_error));
                console.log('ìº”ë²„ìŠ¤ í¬ê¸°:', { W1D, H1D, pad });

                function xScale1D(offset) { return pad + (offset - offsetMin) / (offsetMax - offsetMin || 1) * (W1D - 2*pad); }
                function yScale1D(error) { 
                    // errorMin ~ errorMax ë²”ìœ„ë¥¼ pad ~ (H1D - pad)ë¡œ ë§¤í•‘
                    const normalized = (error - errorMin) / errorRange;
                    return H1D - (pad + normalized * (H1D - 2*pad)); 
                }

                // ë°°ê²½ ê·¸ë¦¬ë“œ
                ctx1D.strokeStyle = '#2a2f3e';
                ctx1D.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    const x = pad + (W1D - 2*pad) * i / 10;
                    ctx1D.beginPath();
                    ctx1D.moveTo(x, pad);
                    ctx1D.lineTo(x, H1D - pad);
                    ctx1D.stroke();
                }
                for (let i = 0; i <= 10; i++) {
                    const y = pad + (H1D - 2*pad) * i / 10;
                    ctx1D.beginPath();
                    ctx1D.moveTo(pad, y);
                    ctx1D.lineTo(W1D - pad, y);
                    ctx1D.stroke();
                }

                // ì´ìƒ êµ¬ê°„ì„ ë¹¨ê°„ìƒ‰ ë°°ê²½ìœ¼ë¡œ ì¹ í•˜ê¸° (ì—°ì†ëœ anomaly tick êµ¬ê°„)
                let anomalyStartIdx = null;
                for (let i = 0; i < samples.length; i++) {
                    const s = samples[i];
                    if (s.is_anomalous_tick) {
                        if (anomalyStartIdx === null) {
                            anomalyStartIdx = i;
                        }
                    } else {
                        if (anomalyStartIdx !== null) {
                            // ì—°ì†ëœ ì´ìƒ êµ¬ê°„ì„ ë¹¨ê°„ìƒ‰ ë°°ê²½ìœ¼ë¡œ ì¹ í•˜ê¸°
                            const startX = xScale1D(samples[anomalyStartIdx].tickOffset);
                            const endX = xScale1D(samples[i - 1].tickOffset);
                            ctx1D.fillStyle = 'rgba(255, 0, 0, 0.15)'; // ë°˜íˆ¬ëª… ë¹¨ê°„ìƒ‰
                            ctx1D.fillRect(startX, pad, endX - startX, H1D - 2*pad);
                            anomalyStartIdx = null;
                        }
                    }
                }
                // ë§ˆì§€ë§‰ê¹Œì§€ ì´ìƒ êµ¬ê°„ì¸ ê²½ìš°
                if (anomalyStartIdx !== null) {
                    const startX = xScale1D(samples[anomalyStartIdx].tickOffset);
                    const endX = xScale1D(samples[samples.length - 1].tickOffset);
                    ctx1D.fillStyle = 'rgba(255, 0, 0, 0.15)'; // ë°˜íˆ¬ëª… ë¹¨ê°„ìƒ‰
                    ctx1D.fillRect(startX, pad, endX - startX, H1D - 2*pad);
                }

                // ì „ì²´ tick_pred_errorë¥¼ ì„ ìœ¼ë¡œ ì—°ê²° (ì‹œê°„ ìˆœì„œëŒ€ë¡œ)
                if (samples.length > 1) {
                    ctx1D.strokeStyle = 'rgba(150, 150, 150, 0.6)';
                    ctx1D.lineWidth = 1.5;
                    ctx1D.beginPath();
                    ctx1D.moveTo(xScale1D(samples[0].tickOffset), yScale1D(samples[0].tick_pred_error));
                    for (let i = 1; i < samples.length; i++) {
                        ctx1D.lineTo(xScale1D(samples[i].tickOffset), yScale1D(samples[i].tick_pred_error));
                    }
                    ctx1D.stroke();
                }
                
                // ì •ìƒ ìœ ì € í‰ê·  error ìˆ˜í‰ì„  (ë…¹ìƒ‰ ì ì„ )
                const normalUserAvgY = yScale1D(normalUserAvgError);
                ctx1D.strokeStyle = '#00ff00'; // ë…¹ìƒ‰
                ctx1D.lineWidth = 2;
                ctx1D.setLineDash([3, 3]);
                ctx1D.beginPath();
                ctx1D.moveTo(pad, normalUserAvgY);
                ctx1D.lineTo(W1D - pad, normalUserAvgY);
                ctx1D.stroke();
                ctx1D.setLineDash([]);
                
                // ì •ìƒ ìœ ì € í‰ê·  ë¼ë²¨
                ctx1D.fillStyle = '#00ff00';
                ctx1D.font = '12px Arial';
                ctx1D.textAlign = 'right';
                ctx1D.fillText(`Normal Avg: ${normalUserAvgError.toFixed(4)}`, W1D - pad - 5, normalUserAvgY - 5);
                ctx1D.textAlign = 'left';
                
                // fire ê¸°ì¤€ì„  (offset = 0) - íŒŒì´ì¬ ì½”ë“œì™€ ë™ì¼: blue
                ctx1D.strokeStyle = '#0000ff'; // blue
                ctx1D.lineWidth = 2;
                ctx1D.setLineDash([5, 5]);
                const fireX1D = xScale1D(0);
                ctx1D.beginPath();
                ctx1D.moveTo(fireX1D, pad);
                ctx1D.lineTo(fireX1D, H1D - pad);
                ctx1D.stroke();
                ctx1D.setLineDash([]);

                // ì „ì²´ ì  (íšŒìƒ‰) - ë¨¼ì € ê·¸ë¦¬ê¸°
                samples.forEach(s => {
                    if (!s.is_anomalous_tick) { // ì´ìƒ êµ¬ê°„ì´ ì•„ë‹Œ ê²ƒë§Œ íšŒìƒ‰ìœ¼ë¡œ
                        ctx1D.fillStyle = 'rgba(200, 200, 200, 0.3)';
                        ctx1D.beginPath();
                        ctx1D.arc(xScale1D(s.tickOffset), yScale1D(s.tick_pred_error), 2, 0, Math.PI*2);
                        ctx1D.fill();
                    }
                });

                // anomaly tick spike (ë¹¨ê°„ ì ) - 2Dì™€ ë™ì¼í•˜ê²Œ preAnom êµ¬ê°„ ì‚¬ìš©
                // 2Dì™€ ë™ì¼í•œ í•„í„°: preAnom (tickOffset >= -5 && tickOffset <= -1)
                const preAnom1D = samples.filter(s => s.tickOffset >= -5 && s.tickOffset <= -1);
                console.log('1D View - preAnom ìƒ˜í”Œ ìˆ˜:', preAnom1D.length, '/ ì „ì²´:', samples.length);
                console.log('1D View - preAnom vs is_anomalous_tick:', {
                    preAnom_count: preAnom1D.length,
                    is_anomalous_tick_count: samples.filter(s => s.is_anomalous_tick).length,
                    preAnom_with_anomaly_flag: preAnom1D.filter(s => s.is_anomalous_tick).length
                });
                
                preAnom1D.forEach(s => {
                    const x = xScale1D(s.tickOffset);
                    const y = yScale1D(s.tick_pred_error);
                    ctx1D.fillStyle = '#ff0000';
                    ctx1D.beginPath();
                    ctx1D.arc(x, y, 6, 0, Math.PI*2); // 2Dì™€ ë™ì¼í•œ í¬ê¸°(6)
                    ctx1D.fill();
                });
                
                // ì´ë²¤íŠ¸ íƒ€ì… í‘œì‹œ (1D Viewì—ë„)
                samples.forEach(s => {
                    if (s.eventType) {
                        const ex = xScale1D(s.tickOffset);
                        const ey = yScale1D(s.tick_pred_error);
                        let color = '#ffff00'; // fire ê¸°ë³¸ ìƒ‰ìƒ
                        if (s.eventType === 'hit') color = '#ffa500';
                        else if (s.eventType === 'kill') color = '#ff3333';
                        
                        ctx1D.fillStyle = color;
                        ctx1D.font = 'bold 10px Arial';
                        ctx1D.textAlign = 'center';
                        ctx1D.fillText(s.eventType.toUpperCase(), ex, ey - 8);
                    }
                });

                // ì¶• ë¼ë²¨
                ctx1D.fillStyle = '#8a8fa5';
                ctx1D.font = '12px Arial';
                ctx1D.textAlign = 'center';
                ctx1D.fillText('tick offset (relative to fire)', W1D/2, H1D - 10);
                ctx1D.save();
                ctx1D.translate(10, H1D/2);
                ctx1D.rotate(-Math.PI/2);
                ctx1D.fillText('tick_pred_error', 0, 0);
                ctx1D.restore();
                
                // ë§ˆìš°ìŠ¤ íœ ë¡œ bottom-panel ë†’ì´ ì¡°ì ˆ (Ctrl í‚¤ ëˆ„ë¥´ê³  ìˆì„ ë•Œ)
                this.setupAimTraceWheelResize(container);
            }

            // Mock ë°ì´í„° ìƒì„± í•¨ìˆ˜
            generateMockData(playerName, stats) {
                // ì¼ê´€ëœ Mock ë°ì´í„°ë¥¼ ìœ„í•´ playerNameì„ ì‹œë“œë¡œ ì‚¬ìš©
                let seed = 0;
                for (let i = 0; i < playerName.length; i++) {
                    seed += playerName.charCodeAt(i);
                }
                const rng = (max) => {
                    seed = (seed * 9301 + 49297) % 233280;
                    return (seed / 233280) * max;
                };
                
                const characterMap = {
                    1: 'ìºì‹œ', 2: 'ë²„í‹°', 3: 'ë ˆì´ë¸', 4: 'ì»¤í‹°ìŠ¤', 5: 'ì—ë‘',
                    6: 'ì¡°ë€', 7: 'ë¡œì¿ ë¡œ', 8: 'ì•ˆë“œë ˆì´', 9: 'ì•„ì„œ', 10: 'ìœ ë‚˜',
                    11: 'ë¯¸ì‚¬ìš©', 12: 'ì—í¬í¬', 13: 'ì•¨ë¦¬ìŠ¤', 14: 'ìì', 15: 'ëŸ¼&ë ˆì´ì§„'
                };
                
                const osList = ['Unknown', 'Windows', 'MacOS', 'Linux', 'PS5', 'XSX'];
                const inputDeviceList = ['í‚¤ë³´ë“œ/ë§ˆìš°ìŠ¤', 'ì½˜ì†”'];
                const gameTypeList = ['AIë§¤ì¹˜', 'ì¼ë°˜ ë§¤ì¹˜', 'ì´ë²¤íŠ¸ ë§¤ì¹˜', 'ì»¤ìŠ¤í…€ ë§¤ì¹˜'];
                const teamTypeList = ['ì†”ë¡œ', 'ë“€ì˜¤', 'íŠ¸ë¦¬ì˜¤', 'ìŠ¤ì¿¼ë“œ'];
                const reportReasons = ['ìë¦¬ë¹„ì›€/íƒˆì£¼', 'ë¶€ì ì ˆí•œ ë‹‰ë„¤ì„', 'ì•…ì˜ì ì¸ í”Œë ˆì´', 'ë¶ˆë²• í”„ë¡œê·¸ë¨ ì‚¬ìš©', 'ê¸°íƒ€'];
                
                return {
                    // í”Œë ˆì´ì–´ ì •ë³´
                    character: characterMap[Math.floor(rng(15)) + 1],
                    os: osList[Math.floor(rng(osList.length))],
                    inputDevice: inputDeviceList[Math.floor(rng(inputDeviceList.length))],
                    accountId: 'N/A',
                    level: 'N/A',
                    mmr: 'N/A',
                    itemPurchases: [
                        { item: 'íšŒë³µ ì•„ì´í…œ', time: '00:15', cost: 100 },
                        { item: 'ê³µê²©ë ¥ ì¦ê°€', time: '02:30', cost: 250 }
                    ],
                    skillEnhancements: [
                        { skill: 'ìŠ¤í‚¬ 1', level: Math.floor(rng(5)) + 1 },
                        { skill: 'ìŠ¤í‚¬ 2', level: Math.floor(rng(5)) + 1 },
                        { skill: 'ìŠ¤í‚¬ 3', level: Math.floor(rng(5)) + 1 }
                    ],
                    
                    // ë§¤ì¹˜ ì •ë³´
                    gameType: gameTypeList[Math.floor(rng(gameTypeList.length))],
                    teamType: teamTypeList[Math.floor(rng(teamTypeList.length))],
                    
                    // êµì „ ì •ë³´
                    rank: Math.floor(rng(10)) + 1,
                    totalDamage: Math.floor(rng(5000)) + 1000,
                    accuracy: (rng(30) + 20).toFixed(1), // 20-50%
                    
                    // íƒì§€ ë‚´ì—­
                    eacDetection: {
                        detected: rng(1) > 0.7,
                        patterns: {
                            aimbotLSTM: rng(1) > 0.8,
                            highCritRate: rng(1) > 0.85,
                            highHitRate: rng(1) > 0.85,
                            massiveReports: Math.floor(rng(50)),
                            recursiveMassiveReports: rng(1) > 0.7,
                            multiAccount: rng(1) > 0.9,
                            hardwareBan: rng(1) > 0.95,
                            dma: rng(1) > 0.9
                        },
                        details: rng(1) > 0.7 ? 'ë¹„ì •ìƒì ì¸ ì—ì„ íŒ¨í„´ íƒì§€' : null
                    },
                    // 60587 í”Œë ˆì´ì–´ íŠ¹ë³„ ì²˜ë¦¬
                    isPlayer60587: playerName === '60587' || playerName.includes('60587'),
                    ncguardDetection: {
                        detected: rng(1) > 0.8,
                        details: rng(1) > 0.8 ? 'NCGuard íŒ¨í„´ íƒì§€ë¨' : null
                    },
                    internalAimbotDetection: {
                        detected: rng(1) > 0.75,
                        details: rng(1) > 0.75 ? 'ì‚¬ë‚´ ì—ì„ë´‡ íƒì§€ ëª¨ë¸ì—ì„œ ì´ìƒ íŒ¨í„´ ë°œê²¬' : null
                    },
                    ruleBasedDetection: {
                        detected: rng(1) > 0.85,
                        patterns: {
                            respawnHack: rng(1) > 0.9,
                            timeEnergyHack: rng(1) > 0.9,
                            cooldownIgnoreHack: rng(1) > 0.9,
                            rangeHack: rng(1) > 0.9,
                            movementHack: rng(1) > 0.9,
                            installHack: rng(1) > 0.9
                        },
                        details: rng(1) > 0.85 ? 'ë£°ê¸°ë°˜ íŒ¨í„´ ìœ„ë°˜ íƒì§€' : null
                    },
                    userReports: (() => {
                        const hasReports = rng(1) > 0.6;
                        return {
                            detected: hasReports,
                            reports: hasReports ? (() => {
                                const report1Index = Math.floor(rng(reportReasons.length));
                                const report2Index = Math.floor(rng(reportReasons.length));
                                return [
                                    { 
                                        reporter: 'Player_' + Math.floor(rng(100)), 
                                        reason: reportReasons[report1Index], 
                                        reasonIndex: report1Index + 1, 
                                        time: '01:23', 
                                        date: '2024-01-15' 
                                    },
                                    { 
                                        reporter: 'Player_' + Math.floor(rng(100)), 
                                        reason: reportReasons[report2Index], 
                                        reasonIndex: report2Index + 1, 
                                        time: '03:45', 
                                        date: '2024-01-15' 
                                    }
                                ];
                            })() : []
                        };
                    })()
                };
            }
            
            // ìƒˆë¡œìš´ generateReport ë©”ì„œë“œ
            generateReport(playerName) {
                console.log('[DEBUG] generateReport í˜¸ì¶œë¨, playerName:', playerName);
                if (!this.data || !playerName) {
                    console.log('[DEBUG] generateReport ì¢…ë£Œ: data ë˜ëŠ” playerName ì—†ìŒ');
                    return;
                }
                
                const stats = this.data.metadata.playerStats[playerName] || { kills: 0, deaths: 0, team: '' };
                const mockData = this.generateMockData(playerName, stats);
                
                // í”Œë ˆì´ì–´ë³„ ì´ìƒêµ¬ê°„ ì¹´ìš´íŠ¸
                const allAnomalySeqs = this.data.metadata.anomalySeqs || [];
                const playerAnomalySeqs = allAnomalySeqs.filter(seq => {
                    if (!seq.players) return false;
                    if (typeof seq.players.has === 'function') {
                        return seq.players.has(playerName);
                    }
                    if (Array.isArray(seq.players)) {
                        return seq.players.includes(playerName);
                    }
                    return false;
                });
                
                const anomalySeqCount = playerAnomalySeqs.length;
                
                // TOP3 ì´ìƒêµ¬ê°„ ì„ íƒ (maxTickScore ê¸°ì¤€ ë‚´ë¦¼ì°¨ìˆœ)
                const top3AnomalySeqs = playerAnomalySeqs
                    .sort((a, b) => (b.maxTickScore || 0) - (a.maxTickScore || 0))
                    .slice(0, 3);
                
                console.log(`[Report] í”Œë ˆì´ì–´ ${playerName}ì˜ TOP3 ì´ìƒ êµ¬ê°„ ì„ íƒë¨ (ì´ ${anomalySeqCount}ê°œ ì¤‘)`);
                
                // ë¶€ì •í–‰ìœ„ ì˜ì‹¬ ì •í™© íŒë‹¨ (ì´ìƒêµ¬ê°„ì´ ìˆìœ¼ë©´ ì˜ì‹¬ë¨)
                const hasCheatingSuspicion = anomalySeqCount > 0;
                
                // ê²€ì¶œ ë‚´ì—­ ìš”ì•½: ì‚¬ë‚´ ì—ì„ë´‡ íƒì§€ íŒ¨í„´ ê±´ ìˆ˜
                const detectionSummary = [];
                if (anomalySeqCount > 0) {
                    detectionSummary.push(`ì‚¬ë‚´ ì—ì„ë´‡ íƒì§€ íŒ¨í„´ ê²€ì¶œ (${anomalySeqCount}ê±´)`);
                }
                
                // ë§¤ì¹˜ ì •ë³´
                const matchId = this.data.metadata.matchInfo?.match_id || this.data.metadata.matchInfo?.matchId || '0';
                const mapName = this.data.metadata.mapName || 'Unknown';
                const gameStartTime = this.data.metadata.time_range?.min;
                const gameEndTime = this.data.metadata.time_range?.max;
                const survivalTime = (gameEndTime && gameStartTime) ? (gameEndTime - gameStartTime) : 0;
                
                // ë‚ ì§œ í¬ë§· í•¨ìˆ˜ (ë³´ê³ ì„œìš© - YYYY. MM. DD. í˜•ì‹)
                const formatKSTDateForReport = (timestamp) => {
                    if (!timestamp || timestamp === 0 || isNaN(timestamp)) return 'N/A';
                    const ms = timestamp < 10000000000 ? timestamp * 1000 : timestamp;
                    const date = new Date(ms);
                    const kstDate = new Date(date.getTime() + (9 * 60 * 60 * 1000));
                    const year = kstDate.getFullYear();
                    const month = String(kstDate.getMonth() + 1).padStart(2, '0');
                    const day = String(kstDate.getDate()).padStart(2, '0');
                    return `${year}. ${month}. ${day}.`;
                };
                
                const matchStartDate = gameStartTime ? formatKSTDateForReport(gameStartTime) : 'N/A';
                const matchEndDate = gameEndTime ? formatKSTDateForReport(gameEndTime) : 'N/A';
                
                // ì–¸ì–´ë³„ í…ìŠ¤íŠ¸
                const t = this.language === 'ko' ? {
                    title: 'í”Œë ˆì´ì–´ ë³´ê³ ì„œ',
                    generated: 'ìƒì„± ì‹œê°„',
                    conclusion: 'ìš”ì•½',
                    suspicionStatus: 'ë¶€ì •ì‚¬ìš©ì ì˜ì‹¬ ì—¬ë¶€',
                    detected: 'ì˜ì‹¬ë¨',
                    notDetected: 'ì˜ì‹¬ë˜ì§€ ì•ŠìŒ',
                    detectionSummary: 'ê²€ì¶œ ë‚´ì—­ ìš”ì•½',
                    playerId: 'í”Œë ˆì´ì–´ ID',
                    matchId: 'ë§¤ì¹˜ ID',
                    matchStartDate: 'ë§¤ì¹˜ ì‹œì‘ ì¼ì',
                    matchEndDate: 'ë§¤ì¹˜ ì¢…ë£Œ ì¼ì',
                    download: 'ë‹¤ìš´ë¡œë“œ'
                } : {
                    title: 'Player Report',
                    generated: 'Generated',
                    conclusion: 'Summary',
                    suspicionStatus: 'Cheating User Suspicion Status',
                    detected: 'Suspected',
                    notDetected: 'Not Suspected',
                    detectionSummary: 'Detection Summary',
                    playerId: 'Player ID',
                    matchId: 'Match ID',
                    matchStartDate: 'Match Start Date',
                    matchEndDate: 'Match End Date',
                    download: 'Download'
                };
                
                // TOP3 ì´ìƒêµ¬ê°„ì— ëŒ€í•œ AIMTRACE ì´ë¯¸ì§€ ìƒì„± (ì‹¤ì œ ì´ìƒ êµ¬ê°„ ê¸°ì¤€ ì‚¬ìš©)
                const generateAimTraceForSequence = (seqInfo, playerName) => {
                    console.log(`[AIMTRACE REPORT] ì‹œí€€ìŠ¤ ${seqInfo.seqId} ì´ë¯¸ì§€ ìƒì„± ì‹œì‘`);
                    console.log(`  - ì‹œí€€ìŠ¤ ì •ë³´: startTick=${seqInfo.startTick}, endTick=${seqInfo.endTick}, anchorTick=${seqInfo.anchorTick || 'N/A'}`);
                    
                    if (!this.data || !this.data.positions || this.data.positions.length === 0) {
                        console.warn('[AIMTRACE REPORT] positions ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                        return null;
                    }
                    
                    // ì‹¤ì œ ì´ìƒ êµ¬ê°„ ê¸°ì¤€: startTick ~ endTickì— padding ì¶”ê°€
                    const padding = 30; // ì „í›„ 30í‹± ì¶”ê°€
                    const seqStartTick = Number(seqInfo.startTick) - padding;
                    const seqEndTick = Number(seqInfo.endTick) + padding;
                    
                    // ì‹¤ì œ ì´ìƒ êµ¬ê°„ì˜ ì¸ë±ìŠ¤ ì°¾ê¸°
                    let startIdx = 0;
                    let endIdx = this.data.positions.length - 1;
                    for (let i = 0; i < this.data.positions.length; i++) {
                        if (this.data.positions[i].tick >= seqStartTick) {
                            startIdx = i;
                            break;
                        }
                    }
                    for (let i = this.data.positions.length - 1; i >= 0; i--) {
                        if (this.data.positions[i].tick <= seqEndTick) {
                            endIdx = i;
                            break;
                        }
                    }
                    
                    const rangeStartTick = this.data.positions[startIdx]?.tick;
                    const rangeEndTick = this.data.positions[endIdx]?.tick;
                    
                    console.log(`[AIMTRACE REPORT] TICK ë²”ìœ„ (ì‹¤ì œ ì´ìƒ êµ¬ê°„ ê¸°ì¤€):`);
                    console.log(`  - ì‹¤ì œ ì´ìƒ êµ¬ê°„: ${seqInfo.startTick} ~ ${seqInfo.endTick} (${seqInfo.endTick - seqInfo.startTick + 1}í‹±)`);
                    console.log(`  - ì‹œê°í™” ë²”ìœ„: ${rangeStartTick} ~ ${rangeEndTick} (startTick-30 ~ endTick+30, ì´ ${endIdx - startIdx + 1}í‹±)`);
                    console.log(`  - anchorTick: ${seqInfo.anchorTick || 'N/A'}`);
                    
                    // í”Œë ˆì´ì–´ ì´ë¦„ ì •ê·œí™”
                    const normalizedPlayerName = String(playerName).trim();
                    
                    // ë¶„ì„ ì‹œë®¬ë ˆì´ì…˜ê³¼ ë™ì¼í•œ ë°©ì‹ìœ¼ë¡œ ë°ì´í„° ìˆ˜ì§‘ (ì¸ë±ìŠ¤ ê¸°ë°˜, ì¤‘ë³µ ì œê±° ì—†ìŒ)
                    const seqAimData = [];
                    let foundCount = 0;
                    let missingCount = 0;
                    
                    // í¬ì»¤ìŠ¤ ëª¨ë“œì™€ ë™ì¼í•œ ë°©ì‹: ì¸ë±ìŠ¤ ë²”ìœ„ë¡œ ì§ì ‘ ìˆ˜ì§‘
                    for (let idx = startIdx; idx <= endIdx; idx++) {
                        const pos = this.data.positions[idx];
                        if (!pos) {
                            missingCount++;
                            continue;
                        }
                        
                        const player = pos.players ? pos.players.find(p => p && p.name && String(p.name).trim() === normalizedPlayerName) : null;
                        if (!player) {
                            missingCount++;
                            continue;
                        }
                        
                        const yaw = Number(player.yaw);
                        const pitch = Number(player.pitch);
                        
                        if (isNaN(yaw) || isNaN(pitch) || yaw === null || pitch === null) {
                            missingCount++;
                            continue;
                        }
                        
                        // ë¶„ì„ ì‹œë®¬ë ˆì´ì…˜ê³¼ ë™ì¼í•œ ë³€í™˜ ê³µì‹
                        const yawRad = yaw * Math.PI / 180;
                        const pitchRad = pitch * Math.PI / 180;
                        const aim_x = Math.cos(pitchRad) * Math.cos(yawRad);
                        const aim_y = Math.cos(pitchRad) * Math.sin(yawRad);
                        
                        seqAimData.push({
                            aim_x: aim_x,
                            aim_y: aim_y,
                            yaw: yaw,
                            pitch: pitch,
                            time: pos.game_time || 0,
                            tick: pos.tick,
                            tickIdx: idx,
                            type: (pos.tick >= seqInfo.startTick && pos.tick <= seqInfo.endTick) ? 'anom' : 'move'
                        });
                        foundCount++;
                    }
                    
                    // ì´ë²¤íŠ¸ ì •ë³´ ìˆ˜ì§‘ (ë¶„ì„ ì‹œë®¬ë ˆì´ì…˜ê³¼ ë™ì¼)
                    const rangeEvents = (this.data.events || []).filter(e => 
                        e.attacker && e.attacker.name === normalizedPlayerName &&
                        e.tick >= rangeStartTick && e.tick <= rangeEndTick &&
                        (e.event_type_lower === 'fire' || e.event_type_lower === 'hit' || e.event_type_lower === 'kill')
                    );
                    
                    rangeEvents.forEach(event => {
                        const eventTickIdx = this.data.positions.findIndex(p => p.tick === event.tick);
                        if (eventTickIdx !== -1 && eventTickIdx >= startIdx && eventTickIdx <= endIdx) {
                            const pos = this.data.positions[eventTickIdx];
                            const player = pos.players.find(p => p && p.name && String(p.name).trim() === normalizedPlayerName);
                            if (player && player.yaw !== null && player.pitch !== null && 
                                !Number.isNaN(player.yaw) && !Number.isNaN(player.pitch)) {
                                const yawRad = player.yaw * Math.PI / 180;
                                const pitchRad = player.pitch * Math.PI / 180;
                                const aim_x = Math.cos(pitchRad) * Math.cos(yawRad);
                                const aim_y = Math.cos(pitchRad) * Math.sin(yawRad);
                                
                                const existing = seqAimData.find(s => s.tick === event.tick);
                                if (existing) {
                                    existing.type = event.event_type_lower;
                                    existing.eventType = event.event_type_lower;
                                    existing.event = event;
                                } else {
                                    seqAimData.push({
                                        aim_x: aim_x,
                                        aim_y: aim_y,
                                        yaw: player.yaw,
                                        pitch: player.pitch,
                                        time: pos.game_time,
                                        tick: pos.tick,
                                        tickIdx: eventTickIdx,
                                        type: event.event_type_lower,
                                        eventType: event.event_type_lower,
                                        event: event
                                    });
                                }
                            }
                        }
                    });
                    
                    // ì‹œê°„ ìˆœì„œë¡œ ì •ë ¬ (ë¶„ì„ ì‹œë®¬ë ˆì´ì…˜ê³¼ ë™ì¼)
                    seqAimData.sort((a, b) => a.time - b.time);
                    
                    console.log(`[AIMTRACE] ì‹œí€€ìŠ¤ ${seqInfo.seqId} ë°ì´í„° ìˆ˜ì§‘: ${foundCount} ìƒ˜í”Œ, ì—†ìŒ: ${missingCount}, ì´ë²¤íŠ¸: ${rangeEvents.length}ê°œ`);
                    
                    if (seqAimData.length === 0) {
                        console.warn(`[AIMTRACE] ì‹œí€€ìŠ¤ ${seqInfo.seqId}ì— ëŒ€í•œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.`);
                        return null;
                    }
                    
                    // ë¶„ì„ ì‹œë®¬ë ˆì´ì…˜ê³¼ ë™ì¼: ì¤‘ë³µ ì œê±° ì—†ì´ ëª¨ë“  í¬ì¸íŠ¸ ì‚¬ìš©
                    const windowSamples = seqAimData;
                    
                    // Aim Trace ìº”ë²„ìŠ¤ ìƒì„±
                    const seqCanvas = document.createElement('canvas');
                    seqCanvas.width = 800;
                    seqCanvas.height = 600;
                    const seqCtx = seqCanvas.getContext('2d');
                    
                    // ë¶„ì„ ì‹œë®¬ë ˆì´ì…˜ê³¼ ë™ì¼í•œ ë²”ìœ„ ê³„ì‚° ë°©ì‹
                    const aimXs = windowSamples.map(s => s.aim_x).filter(v => !Number.isNaN(v) && v !== null && v !== undefined);
                    const aimYs = windowSamples.map(s => s.aim_y).filter(v => !Number.isNaN(v) && v !== null && v !== undefined);
                    
                    let xMin, xMax, yMin, yMax;
                    if (aimXs.length > 0) {
                        const xMinVal = Math.min(...aimXs);
                        const xMaxVal = Math.max(...aimXs);
                        const xRange = xMaxVal - xMinVal;
                        const xPadding = Math.max(xRange * 0.1, 0.01); // ë¶„ì„ ì‹œë®¬ë ˆì´ì…˜ê³¼ ë™ì¼
                        xMin = xMinVal - xPadding;
                        xMax = xMaxVal + xPadding;
                    } else {
                        xMin = -1;
                        xMax = 1;
                    }
                    
                    if (aimYs.length > 0) {
                        const yMinVal = Math.min(...aimYs);
                        const yMaxVal = Math.max(...aimYs);
                        const yRange = yMaxVal - yMinVal;
                        const yPadding = Math.max(yRange * 0.1, 0.01); // ë¶„ì„ ì‹œë®¬ë ˆì´ì…˜ê³¼ ë™ì¼
                        yMin = yMinVal - yPadding;
                        yMax = yMaxVal + yPadding;
                    } else {
                        yMin = -1;
                        yMax = 1;
                    }
                    
                    console.log(`[AIMTRACE] ì‹œí€€ìŠ¤ ${seqInfo.seqId} ì¢Œí‘œ ë²”ìœ„:`, {aim_x: [xMin.toFixed(4), xMax.toFixed(4)], aim_y: [yMin.toFixed(4), yMax.toFixed(4)]});

                    const pad = 40; // ë¶„ì„ ì‹œë®¬ë ˆì´ì…˜ê³¼ ë™ì¼
                    const W = seqCanvas.width, H = seqCanvas.height;
                    
                    function xScale(v){ 
                        if (xMax === xMin) return W / 2; // ë¶„ì„ ì‹œë®¬ë ˆì´ì…˜ê³¼ ë™ì¼
                        return pad + (v - xMin) / (xMax - xMin) * (W - 2*pad); 
                    }
                    function yScale(v){ 
                        if (yMax === yMin) return H / 2; // ë¶„ì„ ì‹œë®¬ë ˆì´ì…˜ê³¼ ë™ì¼
                        return H - (pad + (v - yMin) / (yMax - yMin) * (H - 2*pad)); 
                    }

                        // ë°°ê²½
                        seqCtx.fillStyle = '#0a0e15';
                        seqCtx.fillRect(0, 0, W, H);

                    // ê·¸ë¦¬ë“œ (ë¶„ì„ ì‹œë®¬ë ˆì´ì…˜ê³¼ ë™ì¼)
                    seqCtx.strokeStyle = '#2a2f3e';
                    seqCtx.lineWidth = 1;
                    const xRange = xMax - xMin;
                    const yRange = yMax - yMin;
                    const gridStepX = Math.max(xRange / 20, 0.01); // ë¶„ì„ ì‹œë®¬ë ˆì´ì…˜ê³¼ ë™ì¼
                    const gridStepY = Math.max(yRange / 15, 0.01); // ë¶„ì„ ì‹œë®¬ë ˆì´ì…˜ê³¼ ë™ì¼
                    for (let x = Math.floor(xMin / gridStepX) * gridStepX; x <= xMax; x += gridStepX) {
                        const sx = xScale(x);
                        if (sx >= pad && sx <= W - pad) {
                            seqCtx.beginPath();
                            seqCtx.moveTo(sx, pad);
                            seqCtx.lineTo(sx, H - pad);
                            seqCtx.stroke();
                        }
                    }
                    for (let y = Math.floor(yMin / gridStepY) * gridStepY; y <= yMax; y += gridStepY) {
                        const sy = yScale(y);
                        if (sy >= pad && sy <= H - pad) {
                            seqCtx.beginPath();
                            seqCtx.moveTo(pad, sy);
                            seqCtx.lineTo(W - pad, sy);
                            seqCtx.stroke();
                        }
                    }

                    // ì¶• ë¼ë²¨
                    seqCtx.fillStyle = '#8a8fa5';
                    seqCtx.font = '12px Arial';
                    seqCtx.textAlign = 'center';
                    seqCtx.fillText(`aim_x [${xMin.toFixed(4)} ~ ${xMax.toFixed(4)}]`, W/2, H-10);
                    seqCtx.save();
                    seqCtx.translate(10, H/2);
                    seqCtx.rotate(-Math.PI/2);
                    seqCtx.fillText(`aim_y [${yMin.toFixed(4)} ~ ${yMax.toFixed(4)}]`, 0, 0);
                    seqCtx.restore();
                    seqCtx.textAlign = 'left';
                    
                    // ê²½ë¡œ ì—°ê²°ì„  (ë¶„ì„ ì‹œë®¬ë ˆì´ì…˜ê³¼ ë™ì¼)
                    if (windowSamples.length > 1) {
                        seqCtx.beginPath();
                        seqCtx.strokeStyle = '#5a637a';
                        seqCtx.lineWidth = 1.5;
                        let firstPoint = true;
                        for (let i = 0; i < windowSamples.length; i++) {
                            const s = windowSamples[i];
                            const x = xScale(s.aim_x);
                            const y = yScale(s.aim_y);
                            if (firstPoint) {
                                seqCtx.moveTo(x, y);
                                firstPoint = false;
                            } else {
                                seqCtx.lineTo(x, y);
                            }
                        }
                        seqCtx.stroke();
                    }
                    
                    // í¬ì¸íŠ¸ ë Œë”ë§ (ë¶„ì„ ì‹œë®¬ë ˆì´ì…˜ê³¼ ë™ì¼í•œ ìŠ¤íƒ€ì¼)
                    windowSamples.forEach(s => {
                        const x = xScale(s.aim_x), y = yScale(s.aim_y);
                        
                        // ìº”ë²„ìŠ¤ ë²”ìœ„ ì²´í¬
                        if (x < 0 || x > W || y < 0 || y > H) return;
                        
                        if (s.eventType === 'kill') {
                            // Kill ì‹œì : ì§„ë¹¨ê°• í° ì› + í…Œë‘ë¦¬
                            seqCtx.fillStyle = '#cc0000';
                            seqCtx.beginPath();
                            seqCtx.arc(x, y, 8, 0, Math.PI*2);
                            seqCtx.fill();
                            seqCtx.strokeStyle = '#ff3333';
                            seqCtx.lineWidth = 3;
                            seqCtx.stroke();
                        } else if (s.eventType === 'hit') {
                            // Hit ì‹œì : ì£¼í™©ìƒ‰ ì›
                            seqCtx.fillStyle = '#ffa500';
                            seqCtx.beginPath();
                            seqCtx.arc(x, y, 6, 0, Math.PI*2);
                            seqCtx.fill();
                        } else if (s.eventType === 'fire') {
                            // Fire ì‹œì : íŒŒë€ìƒ‰ X ë§ˆì»¤
                            seqCtx.strokeStyle = '#0000ff';
                            seqCtx.lineWidth = 3;
                            seqCtx.beginPath();
                            seqCtx.moveTo(x - 10, y - 10);
                            seqCtx.lineTo(x + 10, y + 10);
                            seqCtx.moveTo(x - 10, y + 10);
                            seqCtx.lineTo(x + 10, y - 10);
                            seqCtx.stroke();
                        } else if (s.type === 'anom') {
                            // ì´ìƒ êµ¬ê°„: ë¹¨ê°„ìƒ‰ ì 
                                seqCtx.fillStyle = '#ff4444';
                                seqCtx.beginPath();
                                seqCtx.arc(x, y, 3, 0, Math.PI*2);
                                seqCtx.fill();
                            } else {
                            // ì¼ë°˜ ì´ë™ í¬ì¸íŠ¸: ì‘ì€ íšŒìƒ‰ ì 
                                seqCtx.fillStyle = '#8a8fa5';
                                seqCtx.beginPath();
                                seqCtx.arc(x, y, 2, 0, Math.PI*2);
                                seqCtx.fill();
                            }
                        });

                    // ì´ë²¤íŠ¸ ë¼ë²¨ í‘œì‹œ (ë¶„ì„ ì‹œë®¬ë ˆì´ì…˜ê³¼ ë™ì¼)
                    windowSamples.forEach(s => {
                        if (s.eventType && (s.eventType === 'fire' || s.eventType === 'hit' || s.eventType === 'kill')) {
                            const x = xScale(s.aim_x), y = yScale(s.aim_y);
                            if (x < 0 || x > W || y < 0 || y > H) return;
                            
                            let color = '#ffffff';
                            if (s.eventType === 'kill') color = '#ff3333';
                            else if (s.eventType === 'hit') color = '#ffa500';
                            else if (s.eventType === 'fire') color = '#0000ff';
                            
                            seqCtx.fillStyle = color;
                            seqCtx.font = 'bold 11px Arial';
                            seqCtx.textAlign = 'center';
                            seqCtx.fillText(s.eventType.toUpperCase(), x, y - 15);
                            seqCtx.textAlign = 'left';
                        }
                    });
                    
                    // ë²”ë¡€
                    const legend = [
                        {label: 'Current', color: '#4a90e2'},
                        {label: 'Fire', color: '#0000ff'},
                        {label: 'Hit', color: '#ffa500'},
                        {label: 'Kill', color: '#ff3333'},
                        {label: 'Anomaly', color: '#ff4444'}
                    ];
                    let lx = pad, ly = pad - 12;
                    legend.forEach(l => {
                        if (l.label === 'Fire') {
                            seqCtx.strokeStyle = l.color;
                            seqCtx.lineWidth = 2;
                            seqCtx.beginPath();
                            seqCtx.moveTo(lx - 4, ly - 4);
                            seqCtx.lineTo(lx + 4, ly + 4);
                            seqCtx.moveTo(lx - 4, ly + 4);
                            seqCtx.lineTo(lx + 4, ly - 4);
                            seqCtx.stroke();
                        } else {
                            seqCtx.fillStyle = l.color;
                            seqCtx.beginPath();
                            seqCtx.arc(lx, ly, 4, 0, Math.PI*2);
                            seqCtx.fill();
                        }
                        seqCtx.fillStyle = '#8a8fa5';
                        seqCtx.font = '11px Arial';
                        seqCtx.fillText(l.label, lx + 10, ly + 4);
                        lx += 80;
                    });
                    
                    // ì œëª© ë° ì •ë³´
                    seqCtx.fillStyle = '#ffffff';
                    seqCtx.font = 'bold 16px Arial';
                    seqCtx.textAlign = 'left';
                    seqCtx.fillText(`Seq #${seqInfo.seqId}`, pad, 25);
                    seqCtx.font = '12px Arial';
                    seqCtx.fillStyle = '#8a8fa5';
                    seqCtx.fillText(`Ticks: ${seqInfo.startTick} ~ ${seqInfo.endTick}`, pad, 45);
                    seqCtx.fillText(`max tick_anomaly_score: ${seqInfo.maxTickScore.toFixed(4)} | seq_anomaly_score: ${(seqInfo.seqScore || 0).toFixed(4)}`, pad, 60);
                    
                    return seqCanvas.toDataURL('image/png');
                };
                
                // ì˜ˆì¸¡ ì˜¤ì°¨ ë¹„êµ ì°¨íŠ¸ ìƒì„± í•¨ìˆ˜ (ì‹¤ì œ ì´ìƒ êµ¬ê°„ ê¸°ì¤€)
                const generateErrorChartForSequence = (seqInfo, playerName) => {
                    // ì‹¤ì œ ì´ìƒ êµ¬ê°„ ê¸°ì¤€: startTick ~ endTickì— padding ì¶”ê°€
                    const padding = 30;
                    const seqStartTick = Number(seqInfo.startTick) - padding;
                    const seqEndTick = Number(seqInfo.endTick) + padding;
                    const anchorTick = seqInfo.anchorTick || seqInfo.startTick; // tick offset ê³„ì‚°ìš©
                    
                    // ì‹¤ì œ ì´ìƒ êµ¬ê°„ì˜ ì¸ë±ìŠ¤ ì°¾ê¸°
                    let startIdx = 0;
                    let endIdx = this.data.positions.length - 1;
                    for (let i = 0; i < this.data.positions.length; i++) {
                        if (this.data.positions[i].tick >= seqStartTick) {
                            startIdx = i;
                            break;
                        }
                    }
                    for (let i = this.data.positions.length - 1; i >= 0; i--) {
                        if (this.data.positions[i].tick <= seqEndTick) {
                            endIdx = i;
                            break;
                        }
                    }
                    
                    console.log(`[ERROR CHART] TICK ë²”ìœ„ (ì‹¤ì œ ì´ìƒ êµ¬ê°„ ê¸°ì¤€):`);
                    console.log(`  - ì‹¤ì œ ì´ìƒ êµ¬ê°„: ${seqInfo.startTick} ~ ${seqInfo.endTick}`);
                    console.log(`  - ì‹œê°í™” ë²”ìœ„: ${seqStartTick} ~ ${seqEndTick} (ì¸ë±ìŠ¤ ${startIdx} ~ ${endIdx})`);
                    console.log(`  - anchorTick (offset ê¸°ì¤€): ${anchorTick}`);
                    
                    // í•´ë‹¹ ë²”ìœ„ì˜ ë°ì´í„° ìˆ˜ì§‘ (ì‹œë®¬ë ˆì´ì…˜ê³¼ ë™ì¼)
                    const samples = [];
                    const normalizedPlayerName = String(playerName).trim();
                    
                    for (let idx = startIdx; idx <= endIdx; idx++) {
                        const pos = this.data.positions[idx];
                        if (!pos) continue;
                        
                        const player = pos.players ? pos.players.find(p => p && p.name && String(p.name).trim() === normalizedPlayerName) : null;
                        if (!player) continue;
                        
                        // tick_pred_error ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ì‹œë®¬ë ˆì´ì…˜ê³¼ ë™ì¼)
                        const tickAnom = this.anomalyByTick ? this.anomalyByTick.get(pos.tick) : null;
                        const tick_pred_error = tickAnom ? tickAnom.score : 0;
                        const is_anomalous_tick = tickAnom ? tickAnom.isAnom : false;
                        
                        // tick offset ê³„ì‚° (ì‹œë®¬ë ˆì´ì…˜ê³¼ ë™ì¼: pos.tick - anchorTick)
                        const tickOffset = pos.tick - anchorTick;
                        
                        samples.push({
                            tick: pos.tick,
                            tickOffset: tickOffset,
                            tick_pred_error: tick_pred_error,
                            is_anomalous_tick: is_anomalous_tick
                        });
                    }
                    
                    if (samples.length === 0) return null;
                    
                    // ì°¨íŠ¸ ë°ì´í„° ì •ë ¬ (tickOffset ê¸°ì¤€)
                    samples.sort((a, b) => a.tickOffset - b.tickOffset);
                    
                    // ì°¨íŠ¸ ìº”ë²„ìŠ¤ ìƒì„±
                    const chartCanvas = document.createElement('canvas');
                    chartCanvas.width = 800;
                    chartCanvas.height = 600;
                    const chartCtx = chartCanvas.getContext('2d');
                    
                    const pad = 50;
                    const W = chartCanvas.width, H = chartCanvas.height;
                    
                    // ë²”ìœ„ ê³„ì‚°
                    const tickOffsets = samples.map(s => s.tickOffset);
                    const errors = samples.map(s => s.tick_pred_error);
                    const offsetMin = Math.min(...tickOffsets);
                    const offsetMax = Math.max(...tickOffsets);
                    const actualErrorMin = errors.length > 0 ? Math.min(...errors) : 0;
                    const actualErrorMax = errors.length > 0 ? Math.max(...errors) : 1;
                    const actualErrorRange = actualErrorMax - actualErrorMin;
                    const errorBuffer = Math.max(actualErrorRange * 0.2, actualErrorMax * 0.1, 0.01);
                    const errorMin = Math.max(0, actualErrorMin - errorBuffer * 0.1);
                    const errorMax = actualErrorMax + errorBuffer;
                    const errorRange = errorMax - errorMin || 1;
                    
                    // ì •ìƒ ìœ ì € í‰ê·  ê³„ì‚°
                    const normalSamples = samples.filter(s => !s.is_anomalous_tick);
                    const normalErrors = normalSamples.map(s => s.tick_pred_error);
                    const normalUserAvgError = normalErrors.length > 0 
                        ? normalErrors.reduce((sum, e) => sum + e, 0) / normalErrors.length 
                        : (actualErrorMax * 0.1);
                    
                    function xScale(offset) { return pad + (offset - offsetMin) / (offsetMax - offsetMin || 1) * (W - 2*pad); }
                    function yScale(error) { 
                        const normalized = (error - errorMin) / errorRange;
                        return H - (pad + normalized * (H - 2*pad)); 
                    }
                    
                    // ë°°ê²½
                    chartCtx.fillStyle = '#0a0e15';
                    chartCtx.fillRect(0, 0, W, H);
                    
                    // ê·¸ë¦¬ë“œ
                    chartCtx.strokeStyle = '#2a2f3e';
                    chartCtx.lineWidth = 1;
                    for (let i = 0; i <= 10; i++) {
                        const x = pad + (W - 2*pad) * i / 10;
                        chartCtx.beginPath();
                        chartCtx.moveTo(x, pad);
                        chartCtx.lineTo(x, H - pad);
                        chartCtx.stroke();
                    }
                    for (let i = 0; i <= 10; i++) {
                        const y = pad + (H - 2*pad) * i / 10;
                        chartCtx.beginPath();
                        chartCtx.moveTo(pad, y);
                        chartCtx.lineTo(W - pad, y);
                        chartCtx.stroke();
                    }
                    
                    // ì´ìƒ êµ¬ê°„ ë°°ê²½ (ë¹¨ê°„ìƒ‰ ë°˜íˆ¬ëª…)
                    let anomalyStartIdx = null;
                    for (let i = 0; i < samples.length; i++) {
                        const s = samples[i];
                        if (s.is_anomalous_tick) {
                            if (anomalyStartIdx === null) anomalyStartIdx = i;
                        } else {
                            if (anomalyStartIdx !== null) {
                                const startX = xScale(samples[anomalyStartIdx].tickOffset);
                                const endX = xScale(samples[i - 1].tickOffset);
                                chartCtx.fillStyle = 'rgba(255, 0, 0, 0.15)';
                                chartCtx.fillRect(startX, pad, endX - startX, H - 2*pad);
                                anomalyStartIdx = null;
                            }
                        }
                    }
                    if (anomalyStartIdx !== null) {
                        const startX = xScale(samples[anomalyStartIdx].tickOffset);
                        const endX = xScale(samples[samples.length - 1].tickOffset);
                        chartCtx.fillStyle = 'rgba(255, 0, 0, 0.15)';
                        chartCtx.fillRect(startX, pad, endX - startX, H - 2*pad);
                    }
                    
                    // ì „ì²´ ì„  ì—°ê²°
                    if (samples.length > 1) {
                        chartCtx.strokeStyle = 'rgba(150, 150, 150, 0.6)';
                        chartCtx.lineWidth = 1.5;
                        chartCtx.beginPath();
                        chartCtx.moveTo(xScale(samples[0].tickOffset), yScale(samples[0].tick_pred_error));
                        for (let i = 1; i < samples.length; i++) {
                            chartCtx.lineTo(xScale(samples[i].tickOffset), yScale(samples[i].tick_pred_error));
                        }
                        chartCtx.stroke();
                    }
                    
                    // ì •ìƒ ìœ ì € í‰ê·  ìˆ˜í‰ì„  (ë…¹ìƒ‰ ì ì„ )
                    const normalUserAvgY = yScale(normalUserAvgError);
                    chartCtx.strokeStyle = '#00ff00';
                    chartCtx.lineWidth = 2;
                    chartCtx.setLineDash([3, 3]);
                    chartCtx.beginPath();
                    chartCtx.moveTo(pad, normalUserAvgY);
                    chartCtx.lineTo(W - pad, normalUserAvgY);
                    chartCtx.stroke();
                    chartCtx.setLineDash([]);
                    
                    // ì •ìƒ ìœ ì € í‰ê·  ë¼ë²¨
                    chartCtx.fillStyle = '#00ff00';
                    chartCtx.font = '12px Arial';
                    chartCtx.textAlign = 'right';
                    chartCtx.fillText(`Norm Avg: ${normalUserAvgError.toFixed(4)}`, W - pad - 5, normalUserAvgY - 5);
                    chartCtx.textAlign = 'left';
                    
                    // fire ê¸°ì¤€ì„  (offset = 0, íŒŒë€ìƒ‰ ì ì„ )
                    const fireX = xScale(0);
                    chartCtx.strokeStyle = '#0000ff';
                    chartCtx.lineWidth = 2;
                    chartCtx.setLineDash([5, 5]);
                    chartCtx.beginPath();
                    chartCtx.moveTo(fireX, pad);
                    chartCtx.lineTo(fireX, H - pad);
                    chartCtx.stroke();
                    chartCtx.setLineDash([]);
                    
                    // fire ë¼ë²¨
                    chartCtx.fillStyle = '#0000ff';
                    chartCtx.font = 'bold 11px Arial';
                    chartCtx.textAlign = 'center';
                    chartCtx.fillText('FIRE', fireX, pad - 5);
                    chartCtx.textAlign = 'left';
                    
                    // ì „ì²´ ì  (íšŒìƒ‰)
                    samples.forEach(s => {
                        if (!s.is_anomalous_tick) {
                            chartCtx.fillStyle = 'rgba(200, 200, 200, 0.3)';
                            chartCtx.beginPath();
                            chartCtx.arc(xScale(s.tickOffset), yScale(s.tick_pred_error), 2, 0, Math.PI*2);
                            chartCtx.fill();
                        }
                    });
                    
                    // ì´ìƒ êµ¬ê°„ ì  (ë¹¨ê°„ìƒ‰)
                    samples.forEach(s => {
                        if (s.is_anomalous_tick) {
                            chartCtx.fillStyle = '#ff0000';
                            chartCtx.beginPath();
                            chartCtx.arc(xScale(s.tickOffset), yScale(s.tick_pred_error), 3, 0, Math.PI*2);
                            chartCtx.fill();
                        }
                    });
                    
                    // ì¶• ë¼ë²¨
                    chartCtx.fillStyle = '#8a8fa5';
                    chartCtx.font = '12px Arial';
                    chartCtx.textAlign = 'center';
                    chartCtx.fillText('tick offset (relative to fire)', W/2, H - 10);
                    chartCtx.save();
                    chartCtx.translate(10, H/2);
                    chartCtx.rotate(-Math.PI/2);
                    chartCtx.fillText('tick_pred_error', 0, 0);
                    chartCtx.restore();
                    chartCtx.textAlign = 'left';
                    
                    // ì œëª©
                    chartCtx.fillStyle = '#ffffff';
                    chartCtx.font = 'bold 16px Arial';
                    chartCtx.fillText(`ì •ìƒ ìœ ì € í‰ê·  VS ${playerName}ì˜ ì˜ˆì¸¡ ì˜¤ì°¨ ë¹„êµ`, pad, 25);
                    
                    return chartCanvas.toDataURL('image/png');
                };
                
                // TOP3 ì´ìƒêµ¬ê°„ì— ëŒ€í•œ AIMTRACE ì´ë¯¸ì§€ ë° ì˜ˆì¸¡ ì˜¤ì°¨ ì°¨íŠ¸ ìƒì„±
                const aimTraceImages = [];
                top3AnomalySeqs.forEach((seqInfo, idx) => {
                    const aimTraceImage = generateAimTraceForSequence(seqInfo, playerName);
                    const errorChartImage = generateErrorChartForSequence(seqInfo, playerName);
                    if (aimTraceImage || errorChartImage) {
                        aimTraceImages.push({
                            seqInfo: seqInfo,
                            aimTraceImage: aimTraceImage,
                            errorChartImage: errorChartImage,
                            index: idx + 1
                        });
                    }
                });
                
                // HTML ìƒì„± (í…œí”Œë¦¿ ë¦¬í„°ëŸ´ ì¤‘ì²© ìµœì†Œí™”)
                const reportHTML = this.buildReportHTML({
                    playerName,
                    matchId,
                    matchStartDate,
                    matchEndDate,
                    hasCheatingSuspicion,
                    detectionSummary,
                    stats,
                    mockData,
                    survivalTime,
                    anomalySeqCount,
                    top3AnomalySeqs,
                    aimTraceImages,
                    t
                });
                
                // ìƒˆ ì°½ìœ¼ë¡œ ì—´ê¸°
                const win = window.open('', '_blank');
                if (!win) {
                    alert(this.language === 'ko' ? 'ë³´ê³ ì„œ ì°½ì„ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë¸Œë¼ìš°ì €ì˜ íŒì—… ì°¨ë‹¨ì„ í•´ì œí•´ì£¼ì„¸ìš”.' : 'Cannot open report window. Please disable popup blocker.');
                            return;
                        }
                this.currentReportWindow = win;
                win.document.write(reportHTML);
                win.document.close();
                console.log('[DEBUG] ë³´ê³ ì„œ ì°½ ì—´ê¸° ì™„ë£Œ');
            }
            
            // HTML ìƒì„± í—¬í¼ ë©”ì„œë“œ (í…œí”Œë¦¿ ë¦¬í„°ëŸ´ ì¤‘ì²© ë°©ì§€)
            buildReportHTML(data) {
                const { playerName, matchId, matchStartDate, matchEndDate, hasCheatingSuspicion, 
                        detectionSummary, stats, mockData, survivalTime, anomalySeqCount, top3AnomalySeqs, aimTraceImages, t } = data;
                
                // CSS ìŠ¤íƒ€ì¼
                const styles = `
        body { font-family: Arial, sans-serif; padding: 20px; background: #1a1f2e; color: #fff; line-height: 1.6; }
        .header { border-bottom: 2px solid #4a90e2; padding-bottom: 10px; margin-bottom: 20px; }
        .section { margin: 20px 0; padding: 15px; background: #2a2f3e; border-radius: 8px; }
        .subsection { margin: 15px 0; padding: 10px; background: #1a1f2e; border-radius: 4px; }
        .stat-value { color: #fff; font-size: 18px; font-weight: bold; }
        .suspicion-yes { color: #ff6b6b; font-size: 24px; font-weight: bold; }
        .suspicion-no { color: #51cf66; font-size: 24px; font-weight: bold; }
        .section-title { background: #fff; color: #1a1f2e; padding: 10px 15px; border-radius: 4px; margin-bottom: 15px; font-size: 20px; font-weight: bold; }
        .info-row { display: flex; align-items: center; padding: 8px 0; border-bottom: 1px solid #3a3f4e; }
        .info-label { color: #8a8fa5; min-width: 180px; flex-shrink: 0; }
        .info-value { color: #fff; font-weight: bold; margin-left: 20px; }
        .pattern-list { list-style: none; padding: 0; }
        .pattern-list li { padding: 5px 0; border-bottom: 1px solid #3a3f4e; }
                `;
                
                // ê²€ì¶œ ë‚´ì—­ HTML
                const detectionSummaryHTML = detectionSummary.length > 0
                    ? '<ul class="pattern-list">' + detectionSummary.map(item => '<li>' + item + '</li>').join('') + '</ul>'
                    : '<p>' + t.notDetected + '</p>';
                
                // ì—ì„ë´‡ ì˜ì‹¬ êµ¬ê°„ ì‹œê°í™” HTML ìƒì„±
                const aimTraceSectionHTML = aimTraceImages.length > 0
                    ? aimTraceImages.map((trace, idx) => {
                        const seq = trace.seqInfo;
                        const tickRange = seq.endTick - seq.startTick + 1;
                        return `
            <div style="margin-bottom: 30px; padding: 15px; background: #1a1f2e; border-radius: 4px;">
                <h4 style="color: #4a90e2; margin-bottom: 15px;">ì´ìƒ êµ¬ê°„ #${trace.index}</h4>
                <div style="margin-bottom: 15px; padding: 10px; background: #2a2f3e; border-radius: 4px; border-left: 3px solid #4a90e2;">
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; color: #8a8fa5; font-size: 12px;">
                        <div><strong style="color: #fff;">ì‹œí€€ìŠ¤ ID:</strong> ${seq.seqId || 'N/A'}</div>
                        <div><strong style="color: #fff;">ì‹œì‘ Tick:</strong> ${seq.startTick}</div>
                        <div><strong style="color: #fff;">ì¢…ë£Œ Tick:</strong> ${seq.endTick}</div>
                        <div><strong style="color: #fff;">Anchor Tick:</strong> ${seq.anchorTick || 'N/A'}</div>
                        <div><strong style="color: #fff;">ìµœëŒ€ Tick ì ìˆ˜:</strong> ${(seq.maxTickScore || 0).toFixed(4)}</div>
                        <div><strong style="color: #fff;">ì‹œí€€ìŠ¤ ì ìˆ˜:</strong> ${(seq.seqScore || 0).toFixed(4)}</div>
                        <div><strong style="color: #fff;">í‹± ë²”ìœ„:</strong> ${tickRange} í‹±</div>
                    </div>
                </div>
                <div style="margin-top: 15px; display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px;">
                    <div>
                        <h5 style="color: #8a8fa5; font-size: 12px; margin-bottom: 5px;">2D ì—ì„ ì¶”ì </h5>
                        ${trace.aimTraceImage ? `<img src="${trace.aimTraceImage}" style="width: 100%; height: auto; border: 1px solid #3a3f4e; border-radius: 4px;" />` : '<p style="color: #8a8fa5; font-size: 11px;">AIMTRACE ë°ì´í„° ì—†ìŒ</p>'}
                    </div>
                    <div>
                        <h5 style="color: #8a8fa5; font-size: 12px; margin-bottom: 5px;">ì •ìƒ ìœ ì € í‰ê·  VS ${playerName}ì˜ ì˜ˆì¸¡ ì˜¤ì°¨ ë¹„êµ</h5>
                        ${trace.errorChartImage ? `<img src="${trace.errorChartImage}" style="width: 100%; height: auto; border: 1px solid #3a3f4e; border-radius: 4px;" />` : '<p style="color: #8a8fa5; font-size: 11px;">ì˜ˆì¸¡ ì˜¤ì°¨ ë°ì´í„° ì—†ìŒ</p>'}
                    </div>
                </div>
            </div>`;
                    }).join('')
                    : '<p style="color: #8a8fa5;">ì—ì„ ê¶¤ì  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. (ì´ìƒ ì‹œí€€ìŠ¤ëŠ” ìˆìœ¼ë‚˜, í•´ë‹¹ êµ¬ê°„ì˜ ì¡°ì¤€ ë°ì´í„°ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤)</p>';
                
                // ìœ ì € ì •ë³´ HTML (3.1 ê¸°ë³¸ ì •ë³´)
                const playerBasicInfoHTML = `
            <div class="info-row" style="border: 1px solid #3a3f4e; padding: 10px; border-radius: 4px; background: #1a1f2e; margin-bottom: 10px;">
                    <span class="info-label" style="display: block; margin-bottom: 5px;">Actor_NPGameAccountID:</span>
                    <span class="info-value" style="display: block;">${playerName}</span>
            </div>
            <div class="info-row" style="border: 1px solid #3a3f4e; padding: 10px; border-radius: 4px; background: #1a1f2e; margin-bottom: 10px;">
                    <span class="info-label" style="display: block; margin-bottom: 5px;">Actor_GameDBUserNo:</span>
                    <span class="info-value" style="display: block;">${mockData.accountId || 'N/A'}</span>
            </div>
            <div class="info-row" style="border: 1px solid #3a3f4e; padding: 10px; border-radius: 4px; background: #1a1f2e; margin-bottom: 10px;">
                    <span class="info-label" style="display: block; margin-bottom: 5px;">Actor_Name:</span>
                    <span class="info-value" style="display: block;">${playerName}</span>
            </div>
            <div class="info-row" style="border: 1px solid #3a3f4e; padding: 10px; border-radius: 4px; background: #1a1f2e; margin-bottom: 10px;">
                    <span class="info-label" style="display: block; margin-bottom: 5px;">Actor_Level:</span>
                    <span class="info-value" style="display: block;">${mockData.level || 'N/A'}</span>
            </div>
            <div class="info-row" style="border: 1px solid #3a3f4e; padding: 10px; border-radius: 4px; background: #1a1f2e; margin-bottom: 10px;">
                    <span class="info-label" style="display: block; margin-bottom: 5px;">Actor_Rank:</span>
                    <span class="info-value" style="display: block;">${mockData.rank || 'N/A'}</span>
            </div>
            <div class="info-row" style="border: 1px solid #3a3f4e; padding: 10px; border-radius: 4px; background: #1a1f2e; margin-bottom: 10px;">
                    <span class="info-label" style="display: block; margin-bottom: 5px;">Actor_MMR:</span>
                    <span class="info-value" style="display: block;">${mockData.mmr || 'N/A'}</span>
            </div>
                `;
                
                // ë§¤ì¹˜ ê²°ê³¼ ì •ë³´ HTML (3.2 ë§¤ì¹˜ ê²°ê³¼ ì •ë³´)
                const matchResultInfoHTML = `
            <div class="info-row" style="border: 1px solid #3a3f4e; padding: 10px; border-radius: 4px; background: #1a1f2e; margin-bottom: 10px;">
                    <span class="info-label" style="display: block; margin-bottom: 5px;">Actor_Char:</span>
                    <span class="info-value" style="display: block;">${mockData.character || 'N/A'}</span>
            </div>
            <div class="info-row" style="border: 1px solid #3a3f4e; padding: 10px; border-radius: 4px; background: #1a1f2e; margin-bottom: 10px;">
                    <span class="info-label" style="display: block; margin-bottom: 5px;">Actor_OS:</span>
                    <span class="info-value" style="display: block;">${mockData.os || 'N/A'}</span>
            </div>
            <div class="info-row" style="border: 1px solid #3a3f4e; padding: 10px; border-radius: 4px; background: #1a1f2e; margin-bottom: 10px;">
                    <span class="info-label" style="display: block; margin-bottom: 5px;">Data_Num7 (ì…ë ¥ ì¥ì¹˜ ì •ë³´):</span>
                    <span class="info-value" style="display: block;">${mockData.inputDevice || 'N/A'}</span>
        </div>
            <div class="info-row" style="border: 1px solid #3a3f4e; padding: 10px; border-radius: 4px; background: #1a1f2e; margin-bottom: 10px;">
                    <span class="info-label" style="display: block; margin-bottom: 5px;">Entity_Code (ìµœì¢… ìˆœìœ„):</span>
                    <span class="info-value" style="display: block;">${mockData.rank || 'N/A'}</span>
            </div>
            <div class="info-row" style="border: 1px solid #3a3f4e; padding: 10px; border-radius: 4px; background: #1a1f2e; margin-bottom: 10px;">
                    <span class="info-label" style="display: block; margin-bottom: 5px;">Entity_ID (ìƒì¡´ ì‹œê°„ ì´ˆ):</span>
                    <span class="info-value" style="display: block;">${survivalTime.toFixed(1)}</span>
                </div>
            <div class="info-row" style="border: 1px solid #3a3f4e; padding: 10px; border-radius: 4px; background: #1a1f2e; margin-bottom: 10px;">
                    <span class="info-label" style="display: block; margin-bottom: 5px;">Data_Num2 (Kill ìˆ˜):</span>
                    <span class="info-value" style="display: block;">${stats.kills}</span>
        </div>
            <div class="info-row" style="border: 1px solid #3a3f4e; padding: 10px; border-radius: 4px; background: #1a1f2e; margin-bottom: 10px;">
                    <span class="info-label" style="display: block; margin-bottom: 5px;">Data_Num3 (Death ìˆ˜):</span>
                    <span class="info-value" style="display: block;">${stats.deaths}</span>
            </div>
            <div class="info-row" style="border: 1px solid #3a3f4e; padding: 10px; border-radius: 4px; background: #1a1f2e; margin-bottom: 10px;">
                    <span class="info-label" style="display: block; margin-bottom: 5px;">Data_Num4 (ì–´ì‹œìŠ¤íŠ¸ ìˆ˜):</span>
                    <span class="info-value" style="display: block;">${stats.assists || 0}</span>
                </div>
            <div class="info-row" style="border: 1px solid #3a3f4e; padding: 10px; border-radius: 4px; background: #1a1f2e; margin-bottom: 10px;">
                    <span class="info-label" style="display: block; margin-bottom: 5px;">Data_Num5 (ì´ ë°ë¯¸ì§€):</span>
                    <span class="info-value" style="display: block;">${mockData.totalDamage || 'N/A'}</span>
                                                </div>
            <div class="info-row" style="border: 1px solid #3a3f4e; padding: 10px; border-radius: 4px; background: #1a1f2e; margin-bottom: 10px;">
                    <span class="info-label" style="display: block; margin-bottom: 5px;">Data_Num6 (ëª…ì¤‘ë¥ ):</span>
                    <span class="info-value" style="display: block;">${mockData.accuracy || 'N/A'}%</span>
            </div>
                `;
                
                // ë³´ê³ ì„œ ìƒì„± ì‹œê°„ í¬ë§· (YYYY. M. D. ì˜¤í›„/ì˜¤ì „ H:MM:SS í˜•ì‹)
                const reportGenTime = new Date();
                const year = reportGenTime.getFullYear();
                const month = reportGenTime.getMonth() + 1;
                const day = reportGenTime.getDate();
                const hours = reportGenTime.getHours();
                const minutes = String(reportGenTime.getMinutes()).padStart(2, '0');
                const seconds = String(reportGenTime.getSeconds()).padStart(2, '0');
                const ampm = hours >= 12 ? 'ì˜¤í›„' : 'ì˜¤ì „';
                const displayHours = hours > 12 ? hours - 12 : (hours === 0 ? 12 : hours);
                const genTimeStr = `${year}. ${month}. ${day}. ${ampm} ${displayHours}:${minutes}:${seconds}`;
                
                // ë§¤ì¹˜ ì¢…ë£Œ ì‹œê° í¬ë§·
                const matchEndTimeStr = matchEndDate !== 'N/A' ? matchEndDate : 'N/A';
                
                // ì „ì²´ HTML ì¡°í•©
                return `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>${t.title} - ${playerName}</title>
    <style>${styles}</style>
</head>
<body>
    <button id="download-btn" style="position:fixed; top:16px; right:16px; background:#4a90e2; color:#fff; border:none; padding:8px 12px; border-radius:4px; cursor:pointer; z-index:1000;">${t.download}</button>
    <div class="header">
        <h1>${t.title}</h1>
        <div style="margin-top: 15px; padding: 15px; background: #2a2f3e; border-radius: 4px; border-left: 3px solid #4a90e2;">
            <div style="color: #8a8fa5; font-size: 12px; line-height: 1.8;">
                <div><strong style="color: #fff;">í”Œë ˆì´ì–´ ID:</strong> ${playerName}</div>
                <div><strong style="color: #fff;">ë¶„ì„ ë§¤ì¹˜ ID:</strong> ${matchId}</div>
                <div><strong style="color: #fff;">ë§¤ì¹˜ ì¢…ë£Œ ì‹œê°:</strong> ${matchEndTimeStr}</div>
                <div><strong style="color: #fff;">ë³´ê³ ì„œ ìƒì„± ì‹œê°„:</strong> ${genTimeStr}</div>
                                                </div>
                                            </div>
        </div>
        
    <div class="section">
        <h2 class="section-title">1. ${t.conclusion}</h2>
        <div class="subsection">
            <h3>${t.suspicionStatus}</h3>
            <div class="stat-value ${hasCheatingSuspicion ? 'suspicion-yes' : 'suspicion-no'}">
                ${hasCheatingSuspicion ? t.detected : t.notDetected}
            </div>
        </div>
        <div class="subsection">
            <h3>${t.detectionSummary}</h3>
            ${detectionSummaryHTML}
        </div>
    </div>
    
    <div class="section">
        <h2 class="section-title">2. ì—ì„ë´‡ ì˜ì‹¬ êµ¬ê°„ ì‹œê°í™”</h2>
        ${aimTraceSectionHTML}
    </div>
    
    <div class="section">
        <h2 class="section-title">3. ìœ ì € ì •ë³´ ë° ì°¸ì—¬ ë§¤ì¹˜ ì •ë³´</h2>
        
        <div class="subsection">
            <h3 style="color: #8a8fa5; font-size: 16px; margin-bottom: 15px;">3.1 ê¸°ë³¸ ì •ë³´</h3>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                ${playerBasicInfoHTML}
            </div>
        </div>
        
        <div class="subsection">
            <h3 style="color: #8a8fa5; font-size: 16px; margin-bottom: 15px; margin-top: 20px;">3.2 ë§¤ì¹˜ ê²°ê³¼ ì •ë³´</h3>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                ${matchResultInfoHTML}
            </div>
        </div>
        </div>
        
</body>
<script>
    (function(){
        const btn = document.getElementById('download-btn');
        if (btn) {
            btn.addEventListener('click', function(){
                const html = document.documentElement.outerHTML;
                const blob = new Blob([html], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = \`report_\${playerName}_\${Date.now()}.html\`;
                a.click();
                URL.revokeObjectURL(url);
            });
        }
    })();
<\/script>
</html>`;
            }
            
            detectMapFromBounds(bounds) {
                // ë§µ ë°ì´í„° ë¡œë“œ ì œê±° (ë¶ˆí•„ìš”)
                // boundsë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë§µì„ ì¶”ë¡ í•˜ëŠ” ë¡œì§ì´ í•„ìš”í•˜ë©´ ì—¬ê¸°ì— ì¶”ê°€
                return null;
            }
            
            async renderMapGeometry(mapName) {
                // ë§µ ì§€ì˜¤ë©”íŠ¸ë¦¬ ë°ì´í„° ë¡œë“œ
                if (!this.mapData || !this.mapData[mapName] || !this.mapData[mapName].geometry) {
                    console.log('ë§µ ì§€ì˜¤ë©”íŠ¸ë¦¬ ë°ì´í„° ì—†ìŒ:', mapName);
                    return;
                }
                
                const geometry = this.mapData[mapName].geometry;
                const mapGroup = new THREE.Group();
                mapGroup.name = 'mapGeometry';
                
                // ê¸°ì¡´ ë§µ ì§€ì˜¤ë©”íŠ¸ë¦¬ ì œê±°
                const existingMap = this.scene.getObjectByName('mapGeometry');
                if (existingMap) {
                    this.scene.remove(existingMap);
                }
                
                // ë²½ ë Œë”ë§
                if (geometry.walls && geometry.walls.length > 0) {
                    const wallMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x4a5568, 
                        metalness: 0.3,
                        roughness: 0.7,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    geometry.walls.forEach(wall => {
                        const wallGeometry = new THREE.BoxGeometry(wall.width, wall.height, wall.depth);
                        const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
                        wallMesh.position.set(wall.x, wall.z + wall.height / 2, wall.y);
                        if (wall.rotation) {
                            wallMesh.rotation.y = wall.rotation * Math.PI / 180;
                        }
                        wallMesh.castShadow = true;
                        wallMesh.receiveShadow = true;
                        mapGroup.add(wallMesh);
                    });
                }
                
                // ê±´ë¬¼ ë Œë”ë§
                if (geometry.buildings && geometry.buildings.length > 0) {
                    const buildingMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x2d3748, 
                        metalness: 0.2,
                        roughness: 0.8,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    geometry.buildings.forEach(building => {
                        const buildingGeometry = new THREE.BoxGeometry(building.width, building.height, building.depth);
                        const buildingMesh = new THREE.Mesh(buildingGeometry, buildingMaterial);
                        buildingMesh.position.set(building.x, building.z + building.height / 2, building.y);
                        if (building.rotation) {
                            buildingMesh.rotation.y = building.rotation * Math.PI / 180;
                        }
                        buildingMesh.castShadow = true;
                        buildingMesh.receiveShadow = true;
                        mapGroup.add(buildingMesh);
                    });
                }
                
                // í­íƒ„ ì„¤ì¹˜ ì§€ì  í‘œì‹œ
                if (geometry.sites && geometry.sites.length > 0) {
                    const siteMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xff6b6b, 
                        emissive: 0xff0000,
                        emissiveIntensity: 0.3,
                        transparent: true,
                        opacity: 0.6
                    });
                    
                    geometry.sites.forEach(site => {
                        const siteGeometry = new THREE.CylinderGeometry(50, 50, 5, 16);
                        const siteMesh = new THREE.Mesh(siteGeometry, siteMaterial);
                        siteMesh.position.set(site.x, site.z + 2.5, site.y);
                        siteMesh.rotation.x = Math.PI / 2;
                        mapGroup.add(siteMesh);
                        
                        // ì‚¬ì´íŠ¸ ì´ë¦„ ë¼ë²¨ (ì„ íƒì )
                        if (site.name) {
                            const loader = new THREE.FontLoader();
                            // í…ìŠ¤íŠ¸ëŠ” ë‚˜ì¤‘ì— ì¶”ê°€ ê°€ëŠ¥
                        }
                    });
                }
                
                // ìŠ¤í° ì§€ì  í‘œì‹œ
                if (geometry.spawns && geometry.spawns.length > 0) {
                    geometry.spawns.forEach(spawn => {
                        const spawnColor = spawn.team === 'CT' ? 0x4a90e2 : 0xff6b6b;
                        const spawnMaterial = new THREE.MeshStandardMaterial({ 
                            color: spawnColor, 
                            transparent: true,
                            opacity: 0.5
                        });
                        const spawnGeometry = new THREE.CylinderGeometry(30, 30, 10, 8);
                        const spawnMesh = new THREE.Mesh(spawnGeometry, spawnMaterial);
                        spawnMesh.position.set(spawn.x, spawn.z + 5, spawn.y);
                        spawnMesh.rotation.x = Math.PI / 2;
                        mapGroup.add(spawnMesh);
                    });
                }
                
                // ë§µ ì§€ì˜¤ë©”íŠ¸ë¦¬ë¥¼ ì”¬ì— ì¶”ê°€
                this.scene.add(mapGroup);
                console.log('ë§µ ì§€ì˜¤ë©”íŠ¸ë¦¬ ë Œë”ë§ ì™„ë£Œ:', mapName);
            }
            
            analyzeAndRenderPaths() {
                if (!this.data || !this.data.positions || !this.playerIndex) {
                    return;
                }
                
                // baseCameraDistanceê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìœ¼ë©´ ê²½ë¡œ ë Œë”ë§ ê±´ë„ˆë›°ê¸°
                if (!this.baseCameraDistance || this.baseCameraDistance <= 0) {
                    console.log('baseCameraDistanceê°€ ì„¤ì •ë˜ì§€ ì•Šì•„ ê²½ë¡œ ë Œë”ë§ì„ ê±´ë„ˆëœë‹ˆë‹¤.');
                    return;
                }
                
                // ê¸°ì¡´ ê²½ë¡œ ë¼ì¸ ì œê±°
                if (this.pathLines) {
                    this.pathLines.forEach(line => {
                        this.scene.remove(line);
                    });
                    this.pathLines = [];
                } else {
                    this.pathLines = [];
                }
                
                // ëª¨ë“  í”Œë ˆì´ì–´ì˜ ì´ë™ ê²½ë¡œë¥¼ ê·¸ëŒ€ë¡œ ì ì„ ìœ¼ë¡œ ë Œë”ë§
                this.playerIndex.forEach((positions, playerName) => {
                    if (positions.length < 2) return;
                    
                    // ê° í”Œë ˆì´ì–´ì˜ ëª¨ë“  ì´ë™ ê²½ë¡œë¥¼ ì ì„ ìœ¼ë¡œ í‘œì‹œ
                    const pathPoints = [];
                    
                    for (let i = 0; i < positions.length; i++) {
                        const pos = positions[i].position;
                        if (pos && pos[0] !== null && pos[1] !== null) {
                            pathPoints.push(new THREE.Vector3(
                                pos[0], 
                                pos[2] || 0, 
                                pos[1]
                            ));
                        }
                    }
                    
                    if (pathPoints.length < 2) return;
                    
                    // ê²½ë¡œë¥¼ í°ìƒ‰ ì‹¤ì„ ìœ¼ë¡œ ë Œë”ë§
                    const geometry = new THREE.BufferGeometry().setFromPoints(pathPoints);
                    
                    const material = new THREE.LineBasicMaterial({
                        color: 0xffffff, // í°ìƒ‰
                        linewidth: 1.5,
                        opacity: 0.8,
                        transparent: true
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    this.scene.add(line);
                    this.pathLines.push(line);
                });
                
                console.log(`ëª¨ë“  í”Œë ˆì´ì–´ ê²½ë¡œ ${this.pathLines.length}ê°œ ë Œë”ë§ ì™„ë£Œ`);
            }
            
            // setupMapImageInput ì œê±°ë¨ (POCì—ì„œëŠ” ìë™ ë¡œë“œë§Œ ì‚¬ìš©)
            
            loadMapImageFromPath(imagePath) {
                if (!imagePath) return;
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(
                    imagePath,
                    (texture) => {
                        this.applyMapImageSettings(texture);
                        this.mapImageTexture = texture;
                        console.log('ë§µ ì´ë¯¸ì§€ í…ìŠ¤ì²˜ ë¡œë“œ ì™„ë£Œ:', imagePath);
                        
                        if (this.mapBounds) {
                            this.renderMapImage();
                            console.log('ë§µ ì´ë¯¸ì§€ ìë™ ë Œë”ë§ ì™„ë£Œ');
                        } else {
                            console.log('ë§µ ê²½ê³„ê°€ ì•„ì§ ê³„ì‚°ë˜ì§€ ì•ŠìŒ. ë§µ ê²½ê³„ ê³„ì‚° í›„ ìë™ ë Œë”ë§ë©ë‹ˆë‹¤.');
                        }
                    },
                    undefined,
                    (error) => {
                        console.error('ë§µ ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨:', imagePath, error);
                    }
                );
            }
            
            applyMapImageSettings(texture) {
                if (!texture || !this.mapImageSettings) return;
                const cfg = this.mapImageSettings;
                texture.wrapS = THREE.ClampToEdgeWrapping;
                texture.wrapT = THREE.ClampToEdgeWrapping;
                texture.repeat.set(cfg.repeatX ?? 1, cfg.repeatY ?? 1);
                texture.offset.set(cfg.offsetX ?? 0, cfg.offsetY ?? 0);
                texture.rotation = cfg.textureRotation ?? 0;
                texture.center.set(0.5, 0.5);
            }
            
            renderMapImage() {
                if (!this.mapImageTexture || !this.mapBounds) return;
                
                // ê¸°ì¡´ ë§µ ì´ë¯¸ì§€ ì œê±°
                if (this.mapImagePlane) {
                    this.scene.remove(this.mapImagePlane);
                    this.mapImagePlane = null;
                }
                
                const bounds = this.mapBounds;
                // ì¢Œí‘œê³„ ë§¤í•‘:
                // ê²Œì„ ì¢Œí‘œê³„: X(ì¢Œìš°), Y(ì „í›„), Z(ë†’ì´)
                // Three.js ì¢Œí‘œê³„: X(ì¢Œìš°), Y(ë†’ì´), Z(ì „í›„)
                // í”Œë ˆì´ì–´ ìœ„ì¹˜: mesh.position.set(player.position[0], player.position[2], player.position[1])
                //   -> gameX -> sceneX, gameZ -> sceneY, gameY -> sceneZ
                
                // ë§µ ì´ë¯¸ì§€ëŠ” X-Z í‰ë©´ì— ë°°ì¹˜ (ìœ„ì—ì„œ ë‚´ë ¤ë‹¤ë³¼ ë•Œ ë³´ì´ë„ë¡)
                // PlaneGeometryëŠ” ê¸°ë³¸ì ìœ¼ë¡œ Y-Z í‰ë©´ì´ë¯€ë¡œ X-Z í‰ë©´ìœ¼ë¡œ íšŒì „ í•„ìš”
                const cfg = this.mapImageSettings || {};
                const mapWidth = bounds.width * (cfg.scaleX ?? 1);   // X ë°©í–¥ (ì¢Œìš°)
                const mapDepth = bounds.depth * (cfg.scaleZ ?? 1);   // Y ë°©í–¥ (ì „í›„) -> scene Z ë°©í–¥
                
                // í‰ë©´ ì§€ì˜¤ë©”íŠ¸ë¦¬ ìƒì„± (ê¸°ë³¸ Y-Z í‰ë©´)
                const planeGeometry = new THREE.PlaneGeometry(mapWidth, mapDepth);
                
                // íˆ¬ëª…ë„ (ê¸°ë³¸ê°’ 80%)
                const opacity = 0.8;
                
                // ë¨¸í‹°ë¦¬ì–¼ ìƒì„±
                const material = new THREE.MeshBasicMaterial({
                    map: this.mapImageTexture,
                    transparent: true,
                    opacity: opacity,
                    side: THREE.DoubleSide
                });
                
                // ë©”ì‹œ ìƒì„±
                this.mapImagePlane = new THREE.Mesh(planeGeometry, material);
                
                // X-Z í‰ë©´ì— ë°°ì¹˜ (YëŠ” ë†’ì´)
                // ê²Œì„ ì¢Œí‘œ: centerX, centerY, centerZ
                // Three.js ì¢Œí‘œ: centerX, centerZ, centerY
                const worldOffsetX = cfg.worldOffsetX ?? 0;
                const worldOffsetZ = cfg.worldOffsetZ ?? 0;
                const verticalOffset = cfg.worldOffsetY ?? 0;
                const baseHeight = Number.isFinite(bounds.minZ)
                    ? bounds.minZ - 5
                    : (Number.isFinite(bounds.centerZ) ? bounds.centerZ - 5 : -5);
                this.mapImagePlane.position.set(
                    bounds.centerX + worldOffsetX,           // X: ì¢Œìš° ì¤‘ì‹¬
                    baseHeight + verticalOffset,             // Y: ë†’ì´
                    bounds.centerY + worldOffsetZ            // Z: ì „í›„ ì¤‘ì‹¬
                );
                
                // X-Z í‰ë©´ìœ¼ë¡œ íšŒì „ (Xì¶•ìœ¼ë¡œ -90ë„ íšŒì „)
                // PlaneGeometryëŠ” ê¸°ë³¸ì ìœ¼ë¡œ Y-Z í‰ë©´ì´ë¯€ë¡œ X-Z í‰ë©´ìœ¼ë¡œ ë§Œë“¤ë ¤ë©´ Xì¶• íšŒì „ í•„ìš”
                this.mapImagePlane.rotation.x = -Math.PI / 2;
                if (cfg.worldRotation) {
                    this.mapImagePlane.rotation.y = cfg.worldRotation;
                }
                
                // ì”¬ì— ì¶”ê°€ (ë°°ê²½ìœ¼ë¡œ ì‚¬ìš©ë˜ë¯€ë¡œ ë¨¼ì € ì¶”ê°€)
                this.scene.add(this.mapImagePlane);
                
                console.log('ë§µ ì´ë¯¸ì§€ ë Œë”ë§ ì™„ë£Œ (X-Z í‰ë©´):', mapWidth, 'Ã—', mapDepth);
                console.log('ë§µ ê²½ê³„:', {
                    minX: bounds.minX, maxX: bounds.maxX,
                    minY: bounds.minY, maxY: bounds.maxY,
                    centerX: bounds.centerX, centerY: bounds.centerY, centerZ: bounds.centerZ
                });
            }
            
            removeMapImage() {
                if (this.mapImagePlane) {
                    this.scene.remove(this.mapImagePlane);
                    this.mapImagePlane = null;
                }
                if (this.mapImageTexture) {
                    this.mapImageTexture.dispose();
                    this.mapImageTexture = null;
                }
            }
            
            setupMapBounds() {
                if (!this.mapBounds) return;
                
                // ë§µ ê²½ê³„ ë°•ìŠ¤ í‘œì‹œ (fit to viewì— ì˜í–¥ ì£¼ì§€ ì•Šë„ë¡ ë§¤ìš° íˆ¬ëª…í•˜ê²Œ)
                const bounds = this.mapBounds;
                const width = bounds.width;
                const height = bounds.depth;
                const depth = bounds.height;
                
                const geometry = new THREE.BoxGeometry(width, depth, height);
                const edges = new THREE.EdgesGeometry(geometry);
                const line = new THREE.LineSegments(
                    edges,
                    new THREE.LineBasicMaterial({ color: 0x4a90e2, opacity: 0.05, transparent: true }) // ë§¤ìš° íˆ¬ëª…í•˜ê²Œ
                );
                line.position.set(bounds.centerX, bounds.centerZ, bounds.centerY);
                this.scene.add(line);
                // ë§µ ê²½ê³„ ë°•ìŠ¤ë¥¼ ë³„ë„ë¡œ ì €ì¥í•˜ì—¬ fitToViewì—ì„œ ì œì™¸
                this.mapBoundsBox = line;
                
                // ë§µ ì§€ì˜¤ë©”íŠ¸ë¦¬ ë Œë”ë§ (ê°ì§€ëœ ë§µì´ ìˆìœ¼ë©´)
                if (this.detectedMapName) {
                    this.renderMapGeometry(this.detectedMapName);
                }
                
                // ì£¼ìš” ê²½ë¡œ ë Œë”ë§ì€ setupMapBounds() í˜¸ì¶œ í›„ processData()ì—ì„œ ìˆ˜í–‰
                
                // ì¹´ë©”ë¼ ìœ„ì¹˜ ì¡°ì • ë° ê¸°ë³¸ ê±°ë¦¬ ì„¤ì •
                // ì¢Œí‘œ ì •ê·œí™”: ë§µ í¬ê¸°ì— ë”°ë¼ ì¹´ë©”ë¼ ê±°ë¦¬ë¥¼ ì ì ˆíˆ ì¡°ì •
                const maxDim = Math.max(width, height, depth);
                // ì •ê·œí™”ëœ í¬ê¸° ì‚¬ìš© (ë” ì¼ê´€ëœ ì¹´ë©”ë¼ ê±°ë¦¬)
                const normalizedMaxDim = bounds.normalizedWidth ? 
                    Math.max(bounds.normalizedWidth, bounds.normalizedHeight, bounds.normalizedDepth) : 
                    maxDim;
                
                // ì •ê·œí™”ëœ í¬ê¸° ê¸°ì¤€ìœ¼ë¡œ ì¹´ë©”ë¼ ê±°ë¦¬ ì¡°ì • (ë” ê°€ê¹ê²Œ)
                if (normalizedMaxDim > 3000) {
                    this.baseCameraDistance = normalizedMaxDim * 0.8; // í° ë§µ: 80% ê±°ë¦¬
                } else if (normalizedMaxDim > 1500) {
                    this.baseCameraDistance = normalizedMaxDim * 1.0; // ì¤‘ê°„ ë§µ: 100% ê±°ë¦¬
                } else {
                    this.baseCameraDistance = normalizedMaxDim * 1.5; // ì‘ì€ ë§µ: 150% ê±°ë¦¬
                }
                this.cameraDistance = this.baseCameraDistance;
                // ì¹´ë©”ë¼ë¥¼ ë§µ ì¤‘ì‹¬ ìœ„ì—ì„œ ë‚´ë ¤ë‹¤ë³´ëŠ” ê°ë„ë¡œ ì„¤ì •
                this.camera.position.set(
                    bounds.centerX,
                    bounds.centerZ + maxDim * 1.0,
                    bounds.centerY + maxDim * 1.5
                );
                this.camera.lookAt(bounds.centerX, bounds.centerZ, bounds.centerY);
                
                // ì¹´ë©”ë¼ íšŒì „ ì´ˆê¸°í™”
                this.cameraRotationX = 0.4; // ì•½ 23ë„ ì•„ë˜ë¡œ
                this.cameraRotationY = Math.PI / 4; // 45ë„
                
                // ë¯¸ë‹ˆë§µ ë¹„í™œì„±í™” (ë©”ì¸ ë·°ê°€ 2Dì´ë¯€ë¡œ ë¶ˆí•„ìš”)
                // if (typeof this.initMinimap === 'function') {
                //     this.initMinimap();
                // }
                
                // ê·¸ë¦¬ë“œ ì¡°ì • (ë” ëª…í™•í•˜ê²Œ)
                const gridSize = Math.max(width, height) * 1.2;
                const gridDivisions = Math.ceil(gridSize / 100); // 100 ë‹¨ìœ„ë¡œ êµ¬ë¶„
                const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x4a90e2, 0x2a3f5a);
                gridHelper.position.set(bounds.centerX, 0, bounds.centerY);
                this.scene.add(gridHelper);
                
                // êµ¬ì—­ í‘œì‹œë¥¼ ìœ„í•œ ì„  ì¶”ê°€ (10x10 êµ¬ì—­)
                const sectorSize = Math.max(width, height) / 10;
                const sectorsHelper = new THREE.Group();
                
                // Xì¶• ì„ 
                for (let i = 0; i <= 10; i++) {
                    const x = bounds.minX + (width / 10) * i;
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(x, bounds.centerZ, bounds.minY),
                        new THREE.Vector3(x, bounds.centerZ, bounds.maxY)
                    ]);
                    const lineMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x3a4f6a, 
                        opacity: 0.3, 
                        transparent: true 
                    });
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    sectorsHelper.add(line);
                }
                
                // Yì¶• ì„ 
                for (let i = 0; i <= 10; i++) {
                    const y = bounds.minY + (height / 10) * i;
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(bounds.minX, bounds.centerZ, y),
                        new THREE.Vector3(bounds.maxX, bounds.centerZ, y)
                    ]);
                    const lineMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x3a4f6a, 
                        opacity: 0.3, 
                        transparent: true 
                    });
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    sectorsHelper.add(line);
                }
                
                this.scene.add(sectorsHelper);
                
                // ì¢Œí‘œì¶• í‘œì‹œ (ì›ì  ë° ì£¼ìš” êµ¬ì—­)
                const axesHelper = new THREE.AxesHelper(Math.max(width, height) * 0.1);
                axesHelper.position.set(bounds.centerX, bounds.centerZ, bounds.centerY);
                this.scene.add(axesHelper);
                
                // êµ¬ì—­ ë¼ë²¨ ì¶”ê°€ (ì£¼ìš” í¬ì¸íŠ¸)
                const labelPoints = [
                    { x: bounds.minX, y: bounds.minY, label: 'A1' },
                    { x: bounds.centerX, y: bounds.minY, label: 'B1' },
                    { x: bounds.maxX, y: bounds.minY, label: 'C1' },
                    { x: bounds.minX, y: bounds.centerY, label: 'A2' },
                    { x: bounds.centerX, y: bounds.centerY, label: 'Center' },
                    { x: bounds.maxX, y: bounds.centerY, label: 'C2' },
                    { x: bounds.minX, y: bounds.maxY, label: 'A3' },
                    { x: bounds.centerX, y: bounds.maxY, label: 'B3' },
                    { x: bounds.maxX, y: bounds.maxY, label: 'C3' }
                ];
                
                labelPoints.forEach(point => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 128;
                    canvas.height = 32;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#8a8fa5';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(point.label, canvas.width / 2, canvas.height / 2 + 4);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                        map: texture, 
                        transparent: true 
                    }));
                    sprite.position.set(point.x, bounds.centerZ + 5, point.y);
                    sprite.scale.set(40, 10, 1);
                    this.scene.add(sprite);
                });
                
                // Map Bounds UI ì œê±°ë¨ (ì°¸ì—¬ í”Œë ˆì´ì–´ ìˆ˜ë¡œ ëŒ€ì²´)
            }

            setupScene() {
                const container = document.getElementById('canvas-container');
                // containerê°€ ìˆ¨ê²¨ì ¸ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ê¸°ë³¸ê°’ ì‚¬ìš©
                let width = container ? container.clientWidth : 800;
                let height = container ? container.clientHeight : 600;
                
                // í¬ê¸°ê°€ 0ì´ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©
                if (width === 0) width = 800;
                if (height === 0) height = 600;

                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0e15);
                this.scene.fog = new THREE.Fog(0x0a0e15, 1000, 5000);

                this.camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 10000);
                this.camera.position.set(0, 500, 1000);
                this.camera.lookAt(0, 0, 0);

                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('canvas'),
                    antialias: true 
                });
                this.renderer.setSize(width, height);
                this.renderer.shadowMap.enabled = true;

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
                directionalLight.position.set(500, 1000, 500);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);

                window.addEventListener('resize', () => {
                    const width = container.clientWidth;
                    const height = container.clientHeight;
                    this.camera.aspect = width / height;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(width, height);
                });
            }

            setupControls() {
                let isMouseDown = false;
                let isPanning = false; // íŒ¨ë‹ ëª¨ë“œ í”Œë˜ê·¸
                let mouseX = 0, mouseY = 0;
                
                // íŒ¨ë‹ ì˜¤í”„ì…‹ì„ ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë¡œ ì´ˆê¸°í™”
                if (!this.panOffset) {
                    this.panOffset = { x: 0, y: 0, z: 0 };
                }

                const canvas = document.getElementById('canvas');
                
                canvas.addEventListener('mousedown', (e) => {
                    isMouseDown = true;
                    isPanning = e.shiftKey; // Shift í‚¤ê°€ ëˆŒë ¤ìˆìœ¼ë©´ íŒ¨ë‹ ëª¨ë“œ
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });

                canvas.addEventListener('mousemove', (e) => {
                    if (isMouseDown) {
                        const deltaX = e.clientX - mouseX;
                        const deltaY = e.clientY - mouseY;
                        
                        // Shift í‚¤ ìƒíƒœë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ í™•ì¸ (mousemove ì¤‘ì—ë„ ë³€ê²½ ê°€ëŠ¥)
                        const shouldPan = e.shiftKey;
                        
                        // Follow ëª¨ë“œì—ì„œë„ ë§ˆìš°ìŠ¤ ë“œë˜ê·¸ë¡œ ì¹´ë©”ë¼ íšŒì „/ì´ë™ í—ˆìš©
                        // Shift í‚¤ë¥¼ ëˆ„ë¥´ë©´ íŒ¨ë‹, ì•„ë‹ˆë©´ íšŒì „
                        // Follow ëª¨ë“œì—ì„œë„ ì‹œì  ì´ë™ì€ ê°€ëŠ¥í•˜ë„ë¡ í•¨ (ë“œë˜ê·¸ ë¹„í™œì„±í™” ì œê±°)
                        
                        // 3D ë·°: Shift í‚¤ë¥¼ ëˆ„ë¥´ë©´ íŒ¨ë‹, ì•„ë‹ˆë©´ íšŒì „
                        if (shouldPan) {
                            // íŒ¨ë‹ ëª¨ë“œ: ì¹´ë©”ë¼ íƒ€ê²Ÿ(ì¤‘ì•™ ì‹œì )ì„ í‰ë©´ìœ¼ë¡œ ì´ë™ (ì¤Œ ì•„ë‹˜)
                            const mapSize = this.mapBounds ? Math.max(this.mapBounds.width, this.mapBounds.depth) : 1000;
                            // íŒ¨ë‹ ì†ë„ ì¡°ì • (ì¤‘ì•™ ì‹œì  ì´ë™)
                            const basePanSpeed = Math.max(0.01, Math.min(0.3, mapSize / 30000));
                            
                            // ìŠ¤ì¼€ì¼ë§ëœ ì¢Œí‘œ ê¸°ì¤€ìœ¼ë¡œ íŒ¨ë‹ ì†ë„ ì¡°ì •
                            const scaledPanSpeed = basePanSpeed / this.coordinateScale;
                            
                            // ë¶€ë“œëŸ¬ìš´ íŒ¨ë‹ì„ ìœ„í•œ ê°ì‡  ê³„ìˆ˜
                            const smoothingFactor = 0.6;
                            const smoothedDeltaX = deltaX * smoothingFactor;
                            const smoothedDeltaY = deltaY * smoothingFactor;
                            
                            const right = new THREE.Vector3();
                            const up = new THREE.Vector3();
                            
                            // ì¹´ë©”ë¼ì˜ ì˜¤ë¥¸ìª½ ë°©í–¥ ê³„ì‚°
                            this.camera.getWorldDirection(new THREE.Vector3());
                            right.setFromMatrixColumn(this.camera.matrixWorld, 0);
                            up.setFromMatrixColumn(this.camera.matrixWorld, 1);
                            
                            // ì¹´ë©”ë¼ íƒ€ê²Ÿì„ ì§ì ‘ ì´ë™ (panOffset ëŒ€ì‹  cameraTarget ì´ë™)
                            if (!this.cameraTarget) {
                                // cameraTargetì´ ì—†ìœ¼ë©´ ê²½ë¡œ ì¤‘ì‹¬ìœ¼ë¡œ ì´ˆê¸°í™”
                                const bounds = this.mapBounds;
                                if (bounds && bounds.pathCenterX !== undefined) {
                                    this.cameraTarget = {
                                        x: bounds.pathCenterX,
                                        y: bounds.pathCenterZ,
                                        z: bounds.pathCenterY
                                    };
                                } else {
                                    this.cameraTarget = { x: 0, y: 0, z: 0 };
                                }
                            }
                            
                            // ì¹´ë©”ë¼ íƒ€ê²Ÿ ì´ë™: ì¢Œìš°/ìœ„ì•„ë˜ ë…ë¦½ì ìœ¼ë¡œ ì²˜ë¦¬
                            // ì´ë™ ë°©í–¥ì˜ ì£¼ì„±ë¶„ì„ ê³„ì‚°í•˜ì—¬ ì¢Œìš° ë˜ëŠ” ìœ„ì•„ë˜ë§Œ ì´ë™
                            const absDeltaX = Math.abs(smoothedDeltaX);
                            const absDeltaY = Math.abs(smoothedDeltaY);
                            
                            // ì´ë™ ë°©í–¥ ê²°ì •: ë” í° ì´ë™ëŸ‰ì„ ê°€ì§„ ë°©í–¥ìœ¼ë¡œë§Œ ì´ë™
                            const isHorizontalMove = absDeltaX > absDeltaY;
                            
                            let newTargetX = this.cameraTarget.x;
                            let newTargetY = this.cameraTarget.y;
                            let newTargetZ = this.cameraTarget.z;
                            
                            if (isHorizontalMove) {
                                // ì¢Œìš° ì´ë™: X, Zì¶•ìœ¼ë¡œë§Œ ì´ë™ (ì¹´ë©”ë¼ì˜ ì˜¤ë¥¸ìª½ ë°©í–¥ ì‚¬ìš©)
                                const panAmount = smoothedDeltaX * scaledPanSpeed * 0.5;
                                newTargetX += right.x * panAmount;
                                newTargetZ += right.z * panAmount;
                                // Yì¶•(ë†’ì´)ì€ ë³€ê²½í•˜ì§€ ì•ŠìŒ
                            } else {
                                // ìœ„ì•„ë˜ ì´ë™: Yì¶•(ë†’ì´)ìœ¼ë¡œë§Œ ì´ë™
                                newTargetY -= smoothedDeltaY * scaledPanSpeed * 0.5;
                                // X, Zì¶•ì€ ë³€ê²½í•˜ì§€ ì•ŠìŒ
                            }
                            
                            // íŒ¨ë‹ ì˜¤í”„ì…‹ì€ 0ìœ¼ë¡œ ìœ ì§€ (ì¹´ë©”ë¼ íƒ€ê²Ÿë§Œ ì´ë™)
                            let newPanX = 0;
                            let newPanY = 0;
                            let newPanZ = 0;
                            
                            // í”Œë ˆì´ì–´ ê²½ë¡œ ë²”ìœ„ ë‚´ë¡œ ì œí•œ
                            if (this.mapBounds && this.mapBounds.pathMinZ !== undefined) {
                                const bounds = this.mapBounds;
                                
                                // ê²½ë¡œ ê²½ê³„ ë‚´ë¡œ ì œí•œ (ì•½ê°„ì˜ ì—¬ìœ  ê³µê°„ í¬í•¨)
                                const margin = Math.max(
                                    bounds.pathWidth || bounds.width || 0,
                                    bounds.pathHeight || bounds.height || 0,
                                    bounds.pathDepth || bounds.depth || 0
                                ) * 0.1;
                                
                                // Yì¶•(ë†’ì´) ê²½ê³„ ì²´í¬
                                const minY = bounds.pathMinZ - margin;
                                const maxY = bounds.pathMaxZ + margin;
                                newTargetY = Math.max(minY, Math.min(maxY, newTargetY));
                                
                                // X, Zì¶• ê²½ê³„ ì²´í¬ (ì¢Œìš° ì´ë™ ì‹œ)
                                if (isHorizontalMove) {
                                    const minX = (bounds.pathMinX !== undefined ? bounds.pathMinX : bounds.minX) - margin;
                                    const maxX = (bounds.pathMaxX !== undefined ? bounds.pathMaxX : bounds.maxX) + margin;
                                    const minZ = (bounds.pathMinY !== undefined ? bounds.pathMinY : bounds.minY) - margin;
                                    const maxZ = (bounds.pathMaxY !== undefined ? bounds.pathMaxY : bounds.maxY) + margin;
                                    
                                    newTargetX = Math.max(minX, Math.min(maxX, newTargetX));
                                    newTargetZ = Math.max(minZ, Math.min(maxZ, newTargetZ));
                                }
                            }
                            
                            // ì¹´ë©”ë¼ íƒ€ê²Ÿ ì—…ë°ì´íŠ¸
                            this.cameraTarget.x = newTargetX;
                            this.cameraTarget.y = newTargetY;
                            this.cameraTarget.z = newTargetZ;
                            
                            // íŒ¨ë‹ ì˜¤í”„ì…‹ì€ 0ìœ¼ë¡œ ìœ ì§€
                            this.panOffset.x = 0;
                            this.panOffset.y = 0;
                            this.panOffset.z = 0;
                            
                            isPanning = true;
                        } else {
                            // ì¼ë°˜ ëª¨ë“œ ë˜ëŠ” í¬ì»¤ìŠ¤ ëª¨ë“œ: ì¹´ë©”ë¼ íšŒì „ (í¬ì»¤ìŠ¤ ëª¨ë“œì—ì„œë„ ììœ ë¡­ê²Œ ì´ë™ ê°€ëŠ¥)
                            const rotationSpeed = 0.005;
                            this.cameraRotationY += deltaX * rotationSpeed;
                            this.cameraRotationX += deltaY * rotationSpeed;
                            this.cameraRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.cameraRotationX));
                            
                            isPanning = false;
                        }
                        
                        // ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸ (íŒ¨ë‹/íšŒì „ ëª¨ë‘ ì¦‰ì‹œ ë°˜ì˜)
                        if (this.updateCamera) {
                            this.updateCamera();
                        }
                        mouseX = e.clientX;
                        mouseY = e.clientY;
                    }
                });

                canvas.addEventListener('mouseup', () => {
                    isMouseDown = false;
                    isPanning = false;
                });
                
                // Shift í‚¤ ìƒíƒœ ì¶”ì  (íŒ¨ë‹ìš©)
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Shift' && isMouseDown) {
                        isPanning = true;
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    if (e.key === 'Shift') {
                        isPanning = false;
                    }
                });

                canvas.addEventListener('wheel', (e) => {
                    let zoomSpeed = 3; // ê¸°ë³¸ ì¤Œ ì†ë„ (5 -> 3ìœ¼ë¡œ ê°ì†Œ)
                    
                    // Ctrl + Shift: ê·¹ë„ë¡œ ì„¸ë°€í•œ ì¤Œ (0.1ë°°)
                    if (e.ctrlKey && e.shiftKey) {
                        zoomSpeed = 0.1;
                    }
                    // Ctrl í‚¤: ë§¤ìš° ì„¸ë°€í•œ ì¤Œ (0.3ë°°, ê¸°ì¡´ 0.5ì—ì„œ ê°ì†Œ)
                    else if (e.ctrlKey) {
                        zoomSpeed = 0.3;
                    }
                    // Shift í‚¤: ë¹ ë¥¸ ì¤Œ (8ë°°, ê¸°ì¡´ 10ì—ì„œ ê°ì†Œ)
                    else if (e.shiftKey) {
                        zoomSpeed = 8;
                    }
                    // Alt í‚¤: ì„¸ë°€í•œ ì¤Œ (0.8ë°°, ê¸°ì¡´ 1ì—ì„œ ê°ì†Œ)
                    else if (e.altKey) {
                        zoomSpeed = 0.8;
                    }
                    
                    // ì¤Œ ë°©í–¥: deltaY > 0ì´ë©´ ì•„ë˜ë¡œ ìŠ¤í¬ë¡¤ (ì¶•ì†Œ), deltaY < 0ì´ë©´ ìœ„ë¡œ ìŠ¤í¬ë¡¤ (í™•ëŒ€)
                    // deltaYë¥¼ ë” ì„¸ë°€í•˜ê²Œ ì²˜ë¦¬ (ê¸°ë³¸ì ìœ¼ë¡œ 100 ë‹¨ìœ„ì´ë¯€ë¡œ ë” ì‘ì€ ë‹¨ìœ„ë¡œ ë³€í™˜)
                    const normalizedDelta = e.deltaY * 0.01; // 100 -> 1ë¡œ ì •ê·œí™”
                    const zoomDelta = normalizedDelta * zoomSpeed;
                    this.cameraDistance += zoomDelta;
                    
                    // í™•ëŒ€/ì¶•ì†Œ í•œê³„ ì™„í™” (ìµœëŒ€ í™•ëŒ€ ê°€ëŠ¥í•˜ë„ë¡)
                    const minDist = 1; // ìµœì†Œ ê±°ë¦¬ë¥¼ 1ë¡œ ì„¤ì •í•˜ì—¬ ìµœëŒ€í•œ ê°€ê¹Œì´ í™•ëŒ€ ê°€ëŠ¥
                    const maxDist = Math.max(minDist + 500, this.baseCameraDistance * 25.0);  // ë” ë©€ë¦¬ ì¶•ì†Œ í—ˆìš©
                    this.cameraDistance = Math.max(minDist, Math.min(maxDist, this.cameraDistance));
                    
                    // Follow ëª¨ë“œì—ì„œ ìˆ˜ë™ ì¤Œ ì¡°ì • ì‹œ í”Œë˜ê·¸ ì„¤ì •
                    if (this.followPlayer && this.selectedPlayer) {
                        this.manualZoomInFollow = true;
                    }
                    
                    // ì¹´ë©”ë¼ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                    if (this.updateCamera) {
                        this.updateCamera();
                    }
                    
                    e.preventDefault();
                });
                
                // í‚¤ë³´ë“œë¡œ ì„¸ë°€í•œ ì¤Œ ì»¨íŠ¸ë¡¤ ì¶”ê°€ (+, - í‚¤)
                document.addEventListener('keydown', (e) => {
                    let zoomChanged = false;
                    // Ctrl + +/- : ë§¤ìš° ì„¸ë°€í•œ ì¤Œ
                    if (e.ctrlKey && (e.key === '+' || e.key === '=')) {
                        this.cameraDistance -= 1;
                        zoomChanged = true;
                        e.preventDefault();
                    } else if (e.ctrlKey && e.key === '-') {
                        this.cameraDistance += 1;
                        zoomChanged = true;
                        e.preventDefault();
                    }
                    // Alt + +/- : ì„¸ë°€í•œ ì¤Œ
                    else if (e.altKey && (e.key === '+' || e.key === '=')) {
                        this.cameraDistance -= 5;
                        zoomChanged = true;
                        e.preventDefault();
                    } else if (e.altKey && e.key === '-') {
                        this.cameraDistance += 5;
                        zoomChanged = true;
                        e.preventDefault();
                    }
                    // Shift + +/- : ë¹ ë¥¸ ì¤Œ
                    else if (e.shiftKey && (e.key === '+' || e.key === '=')) {
                        this.cameraDistance -= 50;
                        zoomChanged = true;
                        e.preventDefault();
                    } else if (e.shiftKey && e.key === '-') {
                        this.cameraDistance += 50;
                        zoomChanged = true;
                        e.preventDefault();
                    }
                    // +/- : ì¼ë°˜ ì¤Œ
                    else if (e.key === '+' || e.key === '=') {
                        this.cameraDistance -= 10;
                        zoomChanged = true;
                        e.preventDefault();
                    } else if (e.key === '-') {
                        this.cameraDistance += 10;
                        zoomChanged = true;
                        e.preventDefault();
                    }
                    
                    if (zoomChanged) {
                    // í•œê³„ ì ìš© (ìµœëŒ€ í™•ëŒ€ ê°€ëŠ¥í•˜ë„ë¡)
                    const minDist = 1; // ìµœì†Œ ê±°ë¦¬ë¥¼ 1ë¡œ ì„¤ì •í•˜ì—¬ ìµœëŒ€í•œ ê°€ê¹Œì´ í™•ëŒ€ ê°€ëŠ¥
                    const maxDist = Math.max(minDist + 500, this.baseCameraDistance * 25.0);
                    this.cameraDistance = Math.max(minDist, Math.min(maxDist, this.cameraDistance));
                        
                        // Follow ëª¨ë“œì—ì„œ ìˆ˜ë™ ì¤Œ ì¡°ì • ì‹œ í”Œë˜ê·¸ ì„¤ì •
                        if (this.followPlayer && this.selectedPlayer) {
                            this.manualZoomInFollow = true;
                        }
                    
                    // ì¹´ë©”ë¼ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                    if (this.updateCamera) {
                        this.updateCamera();
                        }
                    }
                });

                this.updateCamera = () => {
                    // 3D ë·°: Follow ëª¨ë“œë©´ ì„ íƒí•œ í”Œë ˆì´ì–´ì˜ ìŠ¤ì¼€ì¼ëœ ì¢Œí‘œì— ê³ ì •
                    // ì•„ë‹ˆë©´ ìŠ¤ì¼€ì¼ëœ ê¸°ë³¸ íƒ€ê²Ÿ(defaultTarget)ì„ ì‚¬ìš©
                    let target;
                    
                    if (this.followPlayer && this.selectedPlayer && this.cameraTarget) {
                        // Follow ëª¨ë“œ: ì„ íƒí•œ í”Œë ˆì´ì–´ì˜ ìŠ¤ì¼€ì¼ëœ ì¢Œí‘œë¥¼ ì‚¬ìš©
                        target = this.cameraTarget;
                    } else if (this.cameraTarget) {
                        target = this.cameraTarget;
                    } else if (this.defaultTarget) {
                        target = this.defaultTarget;
                    } else {
                        target = { x: 0, y: 0, z: 0 };
                    }
                    
                    // 3D ë·°: ì¹´ë©”ë¼ë¥¼ íƒ€ê²Ÿ ì£¼ë³€ì— ë°°ì¹˜
                        const baseX = target.x + this.cameraDistance * Math.sin(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                        const baseY = target.y + this.cameraDistance * Math.sin(this.cameraRotationX);
                        const baseZ = target.z + this.cameraDistance * Math.cos(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                    
                        // íŒ¨ë‹ ì˜¤í”„ì…‹ ì ìš©
                        this.camera.position.set(
                        baseX + (this.panOffset ? this.panOffset.x : 0),
                        baseY + (this.panOffset ? this.panOffset.y : 0),
                        baseZ + (this.panOffset ? this.panOffset.z : 0)
                    );
                    
                        this.camera.lookAt(
                        target.x + (this.panOffset ? this.panOffset.x : 0),
                        target.y + (this.panOffset ? this.panOffset.y : 0),
                        target.z + (this.panOffset ? this.panOffset.z : 0)
                    );
                    
                    // ì¹´ë©”ë¼ ì •ë³´ ì—…ë°ì´íŠ¸
                    this.updateCameraInfo();
                };
                
                // ì¹´ë©”ë¼ ì •ë³´ í‘œì‹œ ì—…ë°ì´íŠ¸
                this.updateCameraInfo = () => {
                    const distanceEl = document.getElementById('camera-distance');
                    const zoomEl = document.getElementById('camera-zoom');
                    const targetEl = document.getElementById('camera-target');
                    const positionEl = document.getElementById('camera-position');
                    const rotationEl = document.getElementById('camera-rotation');
                    const followEl = document.getElementById('camera-follow');
                    
                    if (distanceEl) {
                        distanceEl.textContent = this.cameraDistance ? this.cameraDistance.toFixed(1) : '-';
                    }
                    
                    if (zoomEl) {
                        // ì¤Œ ë ˆë²¨ ê³„ì‚° (ê±°ë¦¬ ê¸°ë°˜, ì‘ì„ìˆ˜ë¡ ì¤Œì¸)
                        const baseDistance = 1000;
                        const zoomLevel = baseDistance / (this.cameraDistance || 1);
                        zoomEl.textContent = zoomLevel.toFixed(2) + 'x';
                    }
                    
                    if (targetEl && this.cameraTarget) {
                        targetEl.textContent = `${this.cameraTarget.x.toFixed(1)}, ${this.cameraTarget.y.toFixed(1)}, ${this.cameraTarget.z.toFixed(1)}`;
                    }
                    
                    if (positionEl && this.camera) {
                        positionEl.textContent = `${this.camera.position.x.toFixed(1)}, ${this.camera.position.y.toFixed(1)}, ${this.camera.position.z.toFixed(1)}`;
                    }
                    
                    if (rotationEl) {
                        rotationEl.textContent = `X:${(this.cameraRotationX * 180 / Math.PI).toFixed(1)}Â° Y:${(this.cameraRotationY * 180 / Math.PI).toFixed(1)}Â°`;
                    }
                    
                    if (followEl) {
                        followEl.textContent = (this.followPlayer && this.selectedPlayer) ? `Following: ${this.selectedPlayer}` : 'Free';
                    }
                };
                

                document.getElementById('play-btn').addEventListener('click', () => {
                    this.togglePlay();
                });

                document.getElementById('timeline').addEventListener('click', (e) => {
                    const rect = e.currentTarget.getBoundingClientRect();
                    const percent = (e.clientX - rect.left) / rect.width;
                    this.seekTo(percent);
                });

                document.querySelectorAll('.speed-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        const newSpeed = parseFloat(btn.dataset.speed);
                        console.log('ì¬ìƒ ì†ë„ ë³€ê²½:', this.playSpeed, '->', newSpeed);
                        this.playSpeed = newSpeed;
                        // ì¬ìƒ ì†ë„ ë³€ê²½ ì‹œ ì¦‰ì‹œ ë°˜ì˜ë˜ë„ë¡ lastUpdateTime ë¦¬ì…‹
                        this.lastUpdateTime = Date.now();
                    });
                });

                // ESC í‚¤ë¡œ í¬ì»¤ìŠ¤ ëª¨ë“œ ì¢…ë£Œ
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.focusMode) {
                        this.exitFocusMode();
                    }
                });

                // Reset view
                document.getElementById('reset-view').addEventListener('click', () => {
                    this.cameraRotationX = 0.3;
                    this.cameraRotationY = 0;
                    this.cameraDistance = this.baseCameraDistance;
                    this.cameraTarget = null; // íƒ€ê²Ÿ í•´ì œ
                    // íŒ¨ë‹ ì˜¤í”„ì…‹ ì´ˆê¸°í™”
                    if (this.panOffset) {
                        this.panOffset.x = 0;
                        this.panOffset.y = 0;
                        this.panOffset.z = 0;
                    }
                    this.updateCamera();
                });
                
                // Fit to View
                const fitToViewBtn = document.getElementById('fit-to-view');
                if (fitToViewBtn) {
                    fitToViewBtn.addEventListener('click', () => {
                        this.fitToView();
                    });
                }
            }

            setupResizableBottom() {
                const panel = document.getElementById('bottom-panel');
                const handle = document.getElementById('resize-handle');
                const minH = 160; // px
                const maxH = Math.floor(window.innerHeight * 0.8);
                // Load saved height
                const saved = localStorage.getItem('bottomPanelHeight');
                if (saved) panel.style.height = `${parseInt(saved,10)}px`;

                let dragging = false;
                let startY = 0;
                let startH = 0;

                handle.addEventListener('mousedown', (e) => {
                    dragging = true;
                    startY = e.clientY;
                    startH = panel.getBoundingClientRect().height;
                    document.body.style.userSelect = 'none';
                });

                window.addEventListener('mousemove', (e) => {
                    if (!dragging) return;
                    const dy = startY - e.clientY; // drag up increases height
                    let h = startH + dy;
                    h = Math.max(minH, Math.min(maxH, h));
                    panel.style.height = `${h}px`;
                });

                window.addEventListener('mouseup', () => {
                    if (!dragging) return;
                    dragging = false;
                    document.body.style.userSelect = '';
                    const h = panel.getBoundingClientRect().height;
                    localStorage.setItem('bottomPanelHeight', String(Math.round(h)));
                });
            }

            setupAimTraceWheelResize(container) {
                // Aim Traceê°€ í‘œì‹œë  ë•Œ ë§ˆìš°ìŠ¤ íœ ë¡œ bottom-panel ë†’ì´ ì¡°ì ˆ
                const panel = document.getElementById('bottom-panel');
                if (!panel) return;
                
                const minH = 160; // px
                const maxH = Math.floor(window.innerHeight * 0.8);
                
                // ê¸°ì¡´ wheel ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°ë¥¼ ìœ„í•´ í´ë¡  í›„ ì¬ì¶”ê°€
                const wheelHandler = (e) => {
                    // Ctrl í‚¤ë¥¼ ëˆ„ë¥´ê³  ìˆì„ ë•Œë§Œ panel ë†’ì´ ì¡°ì ˆ
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const currentH = panel.getBoundingClientRect().height;
                        const delta = e.deltaY > 0 ? -20 : 20; // ì•„ë˜ë¡œ ìŠ¤í¬ë¡¤ = ë†’ì´ ê°ì†Œ, ìœ„ë¡œ ìŠ¤í¬ë¡¤ = ë†’ì´ ì¦ê°€
                        let newH = currentH + delta;
                        newH = Math.max(minH, Math.min(maxH, newH));
                        
                        panel.style.height = `${newH}px`;
                        localStorage.setItem('bottomPanelHeight', String(Math.round(newH)));
                    }
                };
                
                container.addEventListener('wheel', wheelHandler, { passive: false });
            }

            updateUI() {
                if (!this.data) return;

                const m = this.data.metadata;
                
                // ë§µ ì´ë¦„ ì—…ë°ì´íŠ¸
                const mapName = m.mapName || this.detectedMapName || 'Unknown';
                const mapNameElement = document.getElementById('map-name');
                if (mapNameElement) {
                    mapNameElement.textContent = mapName;
                }
                
                // ë§µ ì •ë³´ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
                const detectedMapNameElement = document.getElementById('detected-map-name');
                if (detectedMapNameElement) {
                    const source = this.detectedMapName ? (this.language === 'ko' ? '(ìœ„ì¹˜ ê¸°ë°˜ ì¶”ë¡ )' : '(Location-based inference)') : 
                                  (this.language === 'ko' ? '(ë°ì´í„° ê¸°ë°˜)' : '(Data-based)');
                    detectedMapNameElement.textContent = `${mapName} ${source}`;
                }
                
                // ë§¤ì¹˜ ì°¸ì—¬ ì •ë³´ ì—…ë°ì´íŠ¸
                // Match ID
                const matchIdElement = document.getElementById('match-id');
                if (matchIdElement && m.matchInfo && m.matchInfo.match_id !== null) {
                    matchIdElement.textContent = m.matchInfo.match_id;
                } else if (matchIdElement) {
                    matchIdElement.textContent = '-';
                }
                
                // ê²Œì„ íƒ€ì… (ì‹¤ì œ ë°ì´í„° ìš°ì„ , ì—†ìœ¼ë©´ Mock ë°ì´í„°)
                const gameTypeElement = document.getElementById('game-type');
                if (gameTypeElement) {
                    // ì‹¤ì œ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ Mock ë°ì´í„° ìƒì„±
                    const gameType = m.matchInfo?.game_type || (() => {
                        const mockData = this.generateMockData ? this.generateMockData('', {}) : null;
                        return mockData && mockData.gameType ? mockData.gameType : '-';
                    })();
                    gameTypeElement.textContent = gameType;
                }
                
                // íŒ€ íƒ€ì… (ì‹¤ì œ ë°ì´í„° ìš°ì„ , ì—†ìœ¼ë©´ Mock ë°ì´í„°)
                const teamTypeElement = document.getElementById('team-type');
                let teamType = '-';
                if (teamTypeElement) {
                    teamType = m.matchInfo?.team_type || (() => {
                        const mockData = this.generateMockData ? this.generateMockData('', {}) : null;
                        return mockData && mockData.teamType ? mockData.teamType : '-';
                    })();
                    teamTypeElement.textContent = teamType;
                }
                
                // íŒ€ ê°œìˆ˜ ê³„ì‚° (íŒ€ íƒ€ì…ì— ë”°ë¼)
                const teamCountElement = document.getElementById('team-count');
                if (teamCountElement && m.players) {
                    const playerCount = m.players.length;
                    let teamCount = '-';
                    
                    if (teamType === 'ì†”ë¡œ') {
                        teamCount = playerCount + 'íŒ€';
                    } else if (teamType === 'ë“€ì˜¤') {
                        teamCount = Math.ceil(playerCount / 2) + 'íŒ€';
                    } else if (teamType === 'íŠ¸ë¦¬ì˜¤') {
                        teamCount = Math.ceil(playerCount / 3) + 'íŒ€';
                    } else if (teamType === 'ìŠ¤ì¿¼ë“œ') {
                        teamCount = Math.ceil(playerCount / 4) + 'íŒ€';
                    } else if (teamType !== '-') {
                        // ì•Œ ìˆ˜ ì—†ëŠ” íŒ€ íƒ€ì…ì´ë©´ ê¸°ë³¸ê°’ìœ¼ë¡œ ê³„ì‚° (ìŠ¤ì¿¼ë“œ ê¸°ì¤€)
                        teamCount = Math.ceil(playerCount / 4) + 'íŒ€';
                    }
                    
                    teamCountElement.textContent = teamCount;
                } else if (teamCountElement) {
                    teamCountElement.textContent = '-';
                }
                
                // ë§¤ì¹˜ ì¢…ë£Œ ì‹œê°
                const matchEndTimeElement = document.getElementById('match-end-time');
                if (matchEndTimeElement) {
                    // Unix timestampë¥¼ KSTë¡œ ë³€í™˜í•˜ì—¬ í‘œì‹œ
                    const formatKSTDateTime = (timestamp) => {
                        const ms = timestamp < 10000000000 ? timestamp * 1000 : timestamp;
                        const date = new Date(ms);
                        const kstDate = new Date(date.getTime() + (9 * 60 * 60 * 1000));
                        return kstDate.toLocaleString(this.language === 'ko' ? 'ko-KR' : 'en-US', {
                            year: 'numeric',
                            month: '2-digit',
                            day: '2-digit',
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit',
                            timeZone: 'Asia/Seoul'
                        });
                    };
                    matchEndTimeElement.textContent = m.time_range.max ? formatKSTDateTime(m.time_range.max) : '-';
                }
                

                // í”Œë ˆì´ì–´ ë¦¬ìŠ¤íŠ¸ (K/D/A)
                const playerList = document.getElementById('player-list');
                playerList.innerHTML = '';
                playerList.style.display = 'grid';
                playerList.style.gridTemplateColumns = 'repeat(2, 1fr)';
                playerList.style.gap = '4px';
                
                m.players.forEach((name, index) => {
                    const stats = m.playerStats[name] || { kills: 0, deaths: 0, assists: 0, team: '' };
                    const assists = stats.assists || 0;
                    
                    // ëª©ì—…: í”Œë ˆì´ì–´ ì´ë¦„ ê¸°ë°˜ìœ¼ë¡œ ì¼ê´€ëœ íŒ€ ë²ˆí˜¸ ìƒì„± (1~íŒ€ê°œìˆ˜)
                    const playerCount = m.players.length;
                    const teamType = m.matchInfo?.team_type || (() => {
                        const mockData = this.generateMockData ? this.generateMockData('', {}) : null;
                        return mockData && mockData.teamType ? mockData.teamType : 'ìŠ¤ì¿¼ë“œ';
                    })();
                    
                    let maxTeams = 1;
                    if (teamType === 'ì†”ë¡œ') {
                        maxTeams = playerCount;
                    } else if (teamType === 'ë“€ì˜¤') {
                        maxTeams = Math.ceil(playerCount / 2);
                    } else if (teamType === 'íŠ¸ë¦¬ì˜¤') {
                        maxTeams = Math.ceil(playerCount / 3);
                    } else if (teamType === 'ìŠ¤ì¿¼ë“œ') {
                        maxTeams = Math.ceil(playerCount / 4);
                    }
                    
                    // í”Œë ˆì´ì–´ ì´ë¦„ì˜ í•´ì‹œê°’ì„ ì‚¬ìš©í•˜ì—¬ ì¼ê´€ëœ íŒ€ ë²ˆí˜¸ ìƒì„±
                    let hash = 0;
                    for (let i = 0; i < name.length; i++) {
                        hash = ((hash << 5) - hash) + name.charCodeAt(i);
                        hash = hash & hash; // Convert to 32bit integer
                    }
                    const teamNumber = (Math.abs(hash) % maxTeams) + 1;
                    
                    const item = document.createElement('div');
                    item.className = `player-item ${stats.team.toLowerCase()}`;
                    item.innerHTML = `
                        <span>${name}, (${teamNumber}), ${stats.kills}/${stats.deaths}/${assists}</span>
                    `;
                    item.style.cursor = 'pointer';
                    item.style.fontSize = '11px';
                    item.style.padding = '4px 6px';
                    item.addEventListener('click', () => {
                        // í”Œë ˆì´ì–´ í´ë¦­ ì‹œ í•´ë‹¹ í”Œë ˆì´ì–´ê°€ ì°¸ì—¬í•œ í‚¬ ì´ë²¤íŠ¸ë¡œ í•„í„°ë§
                        const playerKills = this.data.events.filter(e => 
                            (e.attacker.name === name || e.victim.name === name) &&
                            (e.event_type_lower.includes('kill') || e.event_type_lower.includes('died'))
                        );
                        if (playerKills.length > 0) {
                            this.selectEvent(playerKills[0]);
                        }
                    });
                    playerList.appendChild(item);
                });

                this.updateEventLog();
            }


            populatePlayerPicker() {
                if (!this.data || !this.playerIndex) return;
                const select = document.getElementById('player-select');
                // updateFocusPlayerListê°€ ì´ë¯¸ ì‹¤í–‰ë˜ì–´ í¬ì»¤ìŠ¤ ëª¨ë“œìš© ëª©ë¡ì´ ì±„ì›Œì¡Œë‹¤ë©´ ë®ì–´ì“°ì§€ ì•ŠìŒ
                if (select && select.options.length > 1 && select.options[0].textContent.includes('í”Œë ˆì´ì–´ ì„ íƒ')) {
                    // í¬ì»¤ìŠ¤ ëª¨ë“œìš© ëª©ë¡ì´ ì´ë¯¸ ìˆìœ¼ë¯€ë¡œ ê±´ë„ˆëœ€
                    return;
                }
                // íŠ¹ì • í”Œë ˆì´ì–´ ì‹œì  ë³´ê¸°ìš© (ë³„ë„ ê¸°ëŠ¥ì´ë¯€ë¡œ ë³„ë„ ì²˜ë¦¬ í•„ìš”)
                // í˜„ì¬ëŠ” í¬ì»¤ìŠ¤ ëª¨ë“œê°€ ìš°ì„ ì´ë¯€ë¡œ ì´ í•¨ìˆ˜ëŠ” ë¹„í™œì„±í™”
                // select.innerHTML = '<option value="">Players</option>';
                // Array.from(this.playerIndex.keys()).sort().forEach(name => {
                //     const opt = document.createElement('option');
                //     opt.value = name;
                //     opt.textContent = name;
                //     select.appendChild(opt);
                // });

                select.onchange = () => {
                    this.selectedPlayer = select.value || null;
                };

                document.getElementById('follow-toggle').onclick = () => {
                    if (!this.selectedPlayer) {
                        alert('ë¨¼ì € í”Œë ˆì´ì–´ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
                        return;
                    }
                    this.followPlayer = !this.followPlayer;
                    document.getElementById('follow-toggle').textContent = this.followPlayer ? 'Following' : 'Follow';
                    if (this.followPlayer) {
                        // Follow ëª¨ë“œ: ìë™ ì¤Œ ë„ê³  ì‚¬ìš©ìê°€ ê±°ë¦¬ ì¡°ì •í•˜ë„ë¡ ì„¤ì •
                        this.manualZoomInFollow = true;
                        // Follow ëª¨ë“œ ì‹œì‘ ì‹œ ì¦‰ì‹œ í”Œë ˆì´ì–´ ìœ„ì¹˜ë¡œ ì¹´ë©”ë¼ ì´ë™ (ìŠ¤ì¼€ì¼ ì ìš©)
                        const tickData = this.data.positions[this.currentTick];
                        if (tickData && tickData.players) {
                            // í”Œë ˆì´ì–´ ì´ë¦„ì„ ë¬¸ìì—´ë¡œ ì •í™•íˆ ë¹„êµ (íƒ€ì… ë³€í™˜ ë³´ì¥)
                            const selectedPlayerName = String(this.selectedPlayer);
                            const player = tickData.players.find(p => String(p.name) === selectedPlayerName);
                            if (player && player.position && Array.isArray(player.position)) {
                                const scaledX = (player.position[0] - this.coordinateOffset.x) * this.coordinateScale;
                                const scaledY = (player.position[1] - this.coordinateOffset.y) * this.coordinateScale;
                                const scaledZ = (player.position[2] - this.coordinateOffset.z) * this.coordinateScale;
                                this.cameraTarget = { 
                                    x: scaledX, 
                                    y: scaledZ,
                                    z: scaledY
                                };
                                
                                // ì´ˆê¸° ê±°ë¦¬ëŠ” í˜„ì¬ ê°’ì„ ìœ ì§€í•˜ê³ , ì„¤ì •ëœ ê°’ì´ ì—†ìœ¼ë©´ ì ë‹¹í•œ ê¸°ë³¸ê°’ ì‚¬ìš©
                                if (!Number.isFinite(this.cameraDistance) || this.cameraDistance <= 0) {
                                const container = document.getElementById('canvas-container');
                                const screenWidth = container ? container.clientWidth : 800;
                                const screenHeight = container ? container.clientHeight : 600;
                                const screenMinDim = Math.min(screenWidth, screenHeight);
                                    this.cameraDistance = Math.max(600, screenMinDim * 0.6);
                                }
                                
                                if (this.panOffset) {
                                    this.panOffset.x = 0;
                                    this.panOffset.y = 0;
                                    this.panOffset.z = 0;
                                }
                                
                                console.log('Follow ëª¨ë“œ ì‹œì‘:', {
                                    player: this.selectedPlayer,
                                    scaled_target: this.cameraTarget,
                                    camera_distance: this.cameraDistance,
                                    coordinate_scale: this.coordinateScale
                                });
                                
                                this.updateCamera();
                            }
                        }
                    } else {
                        // Follow ëª¨ë“œ ì¢…ë£Œ ì‹œ ìˆ˜ë™ ì¤Œ í”Œë˜ê·¸ ì´ˆê¸°í™”
                        this.manualZoomInFollow = false;
                        // ê¸°ë³¸ íƒ€ê²Ÿ(ìŠ¤ì¼€ì¼ ì ìš©ëœ ì›ì )ìœ¼ë¡œ ë³µê·€
                        this.cameraTarget = this.defaultTarget || { x: 0, y: 0, z: 0 };
                        if (this.panOffset) {
                            this.panOffset.x = 0;
                            this.panOffset.y = 0;
                            this.panOffset.z = 0;
                        }
                        this.updateCamera();
                    }
                };

                document.getElementById('prev-player-tick').onclick = () => {
                    this.seekToPlayerTick(-1);
                };
                document.getElementById('next-player-tick').onclick = () => {
                    this.seekToPlayerTick(1);
                };
            }
            
            // ì¹´ë©”ë¼ ì¸í¬ íŒ¨ë„ ë“œë˜ê·¸ ê¸°ëŠ¥ ì„¤ì • (populatePlayerPicker ì´í›„ì— í˜¸ì¶œ)
            setupCameraInfoDrag() {
                const cameraInfo = document.getElementById('camera-info');
                if (!cameraInfo) return;
                
                const cameraInfoTitle = document.getElementById('camera-info-title');
                const cameraInfoToggle = document.getElementById('camera-info-toggle');
                
                let isDragging = false;
                let dragStartX = 0;
                let dragStartY = 0;
                let startLeft = 0;
                let startTop = 0;
                let mouseDownX = 0;
                let mouseDownY = 0;
                let hasMoved = false;
                
                // ì €ì¥ëœ ìœ„ì¹˜ ë¶ˆëŸ¬ì˜¤ê¸°
                const savedPosition = localStorage.getItem('cameraInfoPosition');
                if (savedPosition) {
                    try {
                        const pos = JSON.parse(savedPosition);
                        cameraInfo.style.top = pos.top + 'px';
                        cameraInfo.style.right = 'auto';
                        cameraInfo.style.left = pos.left + 'px';
                        cameraInfo.style.bottom = 'auto';
                    } catch (e) {
                        console.warn('ì¹´ë©”ë¼ ì¸í¬ ìœ„ì¹˜ ë³µì› ì‹¤íŒ¨:', e);
                    }
                }
                
                // ì €ì¥ëœ ì ‘ê¸°/í¼ì¹˜ê¸° ìƒíƒœ ë¶ˆëŸ¬ì˜¤ê¸°
                const savedCollapsed = localStorage.getItem('cameraInfoCollapsed');
                if (savedCollapsed === 'true') {
                    cameraInfo.classList.add('collapsed');
                    if (cameraInfoToggle) {
                        cameraInfoToggle.textContent = 'â–¶';
                    }
                }
                
                // ì ‘ê¸°/í¼ì¹˜ê¸° í† ê¸€ ê¸°ëŠ¥
                const toggleCollapse = () => {
                    const isCollapsed = cameraInfo.classList.contains('collapsed');
                    if (isCollapsed) {
                        cameraInfo.classList.remove('collapsed');
                        if (cameraInfoToggle) {
                            cameraInfoToggle.textContent = 'â–¼';
                        }
                        localStorage.setItem('cameraInfoCollapsed', 'false');
                    } else {
                        cameraInfo.classList.add('collapsed');
                        if (cameraInfoToggle) {
                            cameraInfoToggle.textContent = 'â–¶';
                        }
                        localStorage.setItem('cameraInfoCollapsed', 'true');
                    }
                };
                
                cameraInfo.addEventListener('mousedown', (e) => {
                    // í† ê¸€ ì•„ì´ì½˜ì„ í´ë¦­í•œ ê²½ìš° ë“œë˜ê·¸ ì‹œì‘í•˜ì§€ ì•ŠìŒ
                    if (e.target === cameraInfoToggle || e.target.id === 'camera-info-toggle') {
                        toggleCollapse();
                        e.preventDefault();
                        e.stopPropagation();
                        return;
                    }
                    
                    // ì œëª© ì˜ì—­ì´ë‚˜ ë¹ˆ ê³µê°„ì„ í´ë¦­í–ˆì„ ë•Œë§Œ ë“œë˜ê·¸ ì‹œì‘
                    if (e.target === cameraInfo || e.target.id === 'camera-info-title' || e.target.closest('#camera-info-title')) {
                        mouseDownX = e.clientX;
                        mouseDownY = e.clientY;
                        hasMoved = false;
                        
                        const rect = cameraInfo.getBoundingClientRect();
                        const container = document.getElementById('canvas-container');
                        const containerRect = container.getBoundingClientRect();
                        
                        dragStartX = e.clientX;
                        dragStartY = e.clientY;
                        
                        // í˜„ì¬ ìœ„ì¹˜ ê³„ì‚° (right/top ê¸°ì¤€ì„ left/topìœ¼ë¡œ ë³€í™˜)
                        const currentRight = containerRect.width - (rect.right - containerRect.left);
                        const currentTop = rect.top - containerRect.top;
                        
                        startLeft = containerRect.width - currentRight - rect.width;
                        startTop = currentTop;
                        
                        e.preventDefault();
                    }
                });
                
                document.addEventListener('mousemove', (e) => {
                    // ì œëª© ì˜ì—­ì—ì„œ ë§ˆìš°ìŠ¤ê°€ ì›€ì§ì˜€ëŠ”ì§€ í™•ì¸
                    if (mouseDownX !== 0 && mouseDownY !== 0) {
                        const moveDistance = Math.sqrt(
                            Math.pow(e.clientX - mouseDownX, 2) + 
                            Math.pow(e.clientY - mouseDownY, 2)
                        );
                        
                        // 5í”½ì…€ ì´ìƒ ì´ë™í•˜ë©´ ë“œë˜ê·¸ë¡œ ê°„ì£¼
                        if (moveDistance > 5) {
                            hasMoved = true;
                            if (!isDragging) {
                                isDragging = true;
                                cameraInfo.classList.add('dragging');
                            }
                        }
                    }
                    
                    if (!isDragging) return;
                    
                    const container = document.getElementById('canvas-container');
                    const containerRect = container.getBoundingClientRect();
                    const rect = cameraInfo.getBoundingClientRect();
                    
                    const deltaX = e.clientX - dragStartX;
                    const deltaY = e.clientY - dragStartY;
                    
                    let newLeft = startLeft + deltaX;
                    let newTop = startTop + deltaY;
                    
                    // ì»¨í…Œì´ë„ˆ ê²½ê³„ ë‚´ë¡œ ì œí•œ
                    newLeft = Math.max(0, Math.min(newLeft, containerRect.width - rect.width));
                    newTop = Math.max(0, Math.min(newTop, containerRect.height - rect.height));
                    
                    cameraInfo.style.left = newLeft + 'px';
                    cameraInfo.style.top = newTop + 'px';
                    cameraInfo.style.right = 'auto';
                    cameraInfo.style.bottom = 'auto';
                    
                    e.preventDefault();
                });
                
                document.addEventListener('mouseup', (e) => {
                    // ì œëª© ì˜ì—­ì—ì„œ í´ë¦­í–ˆê³ , ë“œë˜ê·¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´ í† ê¸€
                    if (mouseDownX !== 0 && mouseDownY !== 0 && !hasMoved) {
                        const clickedOnTitle = e.target === cameraInfoTitle || 
                                             e.target.closest('#camera-info-title') ||
                                             e.target === cameraInfo ||
                                             (cameraInfoTitle && cameraInfoTitle.contains(e.target));
                        
                        if (clickedOnTitle && e.target !== cameraInfoToggle && e.target.id !== 'camera-info-toggle') {
                            toggleCollapse();
                        }
                    }
                    
                    if (isDragging) {
                        isDragging = false;
                        cameraInfo.classList.remove('dragging');
                        
                        // ìœ„ì¹˜ ì €ì¥
                        const rect = cameraInfo.getBoundingClientRect();
                        const container = document.getElementById('canvas-container');
                        const containerRect = container.getBoundingClientRect();
                        
                        const savedPos = {
                            left: rect.left - containerRect.left,
                            top: rect.top - containerRect.top
                        };
                        
                        try {
                            localStorage.setItem('cameraInfoPosition', JSON.stringify(savedPos));
                        } catch (e) {
                            console.warn('ì¹´ë©”ë¼ ì¸í¬ ìœ„ì¹˜ ì €ì¥ ì‹¤íŒ¨:', e);
                        }
                    }
                    
                    // ì´ˆê¸°í™”
                    mouseDownX = 0;
                    mouseDownY = 0;
                    hasMoved = false;
                });
            }

            seekToPlayerTick(direction) {
                if (!this.selectedPlayer || !this.playerIndex.has(this.selectedPlayer)) return;
                const arr = this.playerIndex.get(this.selectedPlayer);
                if (!arr || arr.length === 0) return;
                // í˜„ì¬ í‹± ê¸°ì¤€ ì´ì „/ë‹¤ìŒ í•­ëª© ì°¾ê¸°
                let idx = arr.findIndex(e => e.tick >= this.data.positions[this.currentTick].tick);
                if (idx === -1) idx = arr.length - 1;
                idx = idx + direction;
                idx = Math.max(0, Math.min(arr.length - 1, idx));
                const target = arr[idx];
                const tickIdx = this.findTickByTime(target.time);
                if (tickIdx !== -1) {
                    this.currentTick = tickIdx;
                    if (this.followPlayer) {
                        this.cameraTarget = { x: target.position[0], y: target.position[2], z: target.position[1] };
                    }
                    this.renderTick(this.currentTick, 0);
                    this.updateTimeDisplay();
                }
            }

            updateEventLog() {
                if (!this.data) return;
                
                const eventLog = document.getElementById('event-log');
                if (!eventLog) return;
                
                // Action Stream íƒ­ì´ í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ ì„¸ë¡œ ë ˆì´ì•„ì›ƒ í´ë˜ìŠ¤ ì¶”ê°€
                const activeTab = document.querySelector('.tab-btn.active');
                if (activeTab) {
                    const tab = activeTab.getAttribute('data-tab');
                    if (tab === 'actions') {
                        eventLog.classList.remove('aim-trace');
                        eventLog.classList.add('action-stream');
                    }
                } else {
                    // ê¸°ë³¸ê°’: Action Stream (ì„¸ë¡œ ë ˆì´ì•„ì›ƒ)
                    eventLog.classList.remove('aim-trace');
                    eventLog.classList.add('action-stream');
                }
                
                eventLog.innerHTML = '';
                
                let eventsToShow = this.data.events;
                
                // í¬ì»¤ìŠ¤ ëª¨ë“œì¸ ê²½ìš° ì‹œê°„ ë²”ìœ„ í•„í„°ë§ ë° kill ì´ë²¤íŠ¸ë§Œ í‘œì‹œ
                if (this.focusMode && this.focusTickRange) {
                    const startT = this.data.positions[this.focusTickRange.startIdx].game_time;
                    const endT = this.data.positions[this.focusTickRange.endIdx].game_time;
                    eventsToShow = this.data.events.filter(e => 
                        e.game_time >= startT && 
                        e.game_time <= endT &&
                        (e.event_type === 'kill' || e.event_type_lower === 'kill')
                    );
                } else {
                    // í˜„ì¬ ì‹œê°„ ê¸°ì¤€ Â±5ì´ˆ ì´ë‚´ ì´ë²¤íŠ¸ í‘œì‹œ
                    const currentTickData = this.data.positions[this.currentTick];
                    const currentTime = currentTickData ? currentTickData.game_time : 0;
                    eventsToShow = this.data.events.filter(e => 
                        Math.abs(e.game_time - currentTime) < 5
                    );
                }
                
                eventsToShow.slice(0, 100).forEach((event, idx) => {
                    const item = document.createElement('div');
                    let className = 'event-item';
                    const isSelected = this.selectedEvent && this.selectedEvent.tick === event.tick;
                    
                    if (event.event_type_lower.includes('kill') || event.event_type_lower.includes('died')) {
                        className += ' kill';
                    } else if (event.event_type_lower.includes('attack')) {
                        className += ' attack';
                    } else if (event.event_type_lower.includes('hit')) {
                        className += ' hit';
                    }
                    
                    if (isSelected) {
                        className += ' selected';
                    }
                    
                    item.className = className;
                    
                    // ACTION STREAM í˜•ì‹: TIMESTAMP PLAYER_ID ì´ë²¤íŠ¸ëª… ì¶”ê°€ì •ë³´
                    const time = this.formatTime(event.game_time);
                    const playerId = event.attacker ? event.attacker.name : 'Unknown';
                    const eventName = event.event_type || 'Unknown Event';
                    const eventNameLower = event.event_type_lower || eventName.toLowerCase();
                    const target = (event.victim && event.victim.name) ? event.victim.name : null;
                    const weapon = event.weapon ? String(event.weapon) : null;
                    const damage = event.damage || null;
                    
                    let html = `<span class="event-time">${time}</span> `;
                    html += `<span class="event-player">${playerId}</span> `;
                    
                    // ì´ë²¤íŠ¸ íƒ€ì…ì— ë”°ë¼ ë‹¤ë¥¸ í˜•ì‹ìœ¼ë¡œ í‘œì‹œ
                    if (eventNameLower.includes('died') || eventNameLower.includes('kill')) {
                        if (target) {
                            html += `<span class="event-action">Died -killed by</span> <span class="event-victim">${target}</span>`;
                        } else {
                            html += `<span class="event-action">${eventName}</span>`;
                        }
                    } else if (eventNameLower.includes('hit')) {
                        html += `<span class="event-action">Hit</span>`;
                        if (target) {
                            html += ` <span class="event-victim">${target}</span>`;
                            if (damage !== null) {
                                html += `-${damage} damage`;
                            }
                        }
                        if (weapon) {
                            html += ` <span class="event-weapon">with weapon ${weapon}</span>`;
                        }
                    } else if (eventNameLower.includes('attack')) {
                        html += `<span class="event-action">initiated an Attack</span>`;
                        if (weapon) {
                            html += ` <span class="event-weapon">with weapon ${weapon}</span>`;
                        }
                    } else {
                        html += `<span class="event-action">${eventName}</span>`;
                        if (target) {
                            html += ` <span class="event-victim">${target}</span>`;
                        }
                        if (weapon) {
                            html += ` <span class="event-weapon">with weapon ${weapon}</span>`;
                        }
                    }
                    
                    item.innerHTML = html;
                    
                    // í´ë¦­ ì´ë²¤íŠ¸ ì¶”ê°€
                    item.addEventListener('click', () => {
                        this.selectEvent(event);
                    });
                    
                    eventLog.appendChild(item);
                });
                
                // ìŠ¤í¬ë¡¤ì„ ë§¨ ìœ„ë¡œ
                eventLog.scrollTop = 0;
            }

            /**
             * Anomaly-centered Focus:
             * anomaly_seq_id êµ¬ê°„(startTick~endTick)ì„ ì¤‘ì‹¬ìœ¼ë¡œ Â±N tickì„ í¬ì»¤ìŠ¤ ë²”ìœ„ë¡œ ì„¤ì •
             */
            setAnomalyFocus(seqInfo, padding = 40) {
                if (!this.data || !this.data.positions || !seqInfo) {
                    return;
                }
                // tick -> index ë§¤í•‘ êµ¬ì„±
                const tickToIndex = new Map();
                for (let i = 0; i < this.data.positions.length; i++) {
                    const t = this.data.positions[i].tick;
                    if (!tickToIndex.has(t)) tickToIndex.set(t, i);
                }

                const startTick = seqInfo.startTick - padding;
                const endTick = seqInfo.endTick + padding;

                // start/end index ì°¾ê¸°
                let startIdx = 0;
                let endIdx = this.data.positions.length - 1;

                // startIdx: startTick ì´ìƒì¸ ì²« index
                for (let i = 0; i < this.data.positions.length; i++) {
                    if (this.data.positions[i].tick >= startTick) {
                        startIdx = i;
                        break;
                    }
                }
                // endIdx: endTick ì´í•˜ì¸ ë§ˆì§€ë§‰ index
                for (let i = this.data.positions.length - 1; i >= 0; i--) {
                    if (this.data.positions[i].tick <= endTick) {
                        endIdx = i;
                        break;
                    }
                }

                const centerIdx = Math.floor((startIdx + endIdx) / 2);

                this.focusMode = true;
                this.focusModeType = 'anomaly';
                this.focusTickRange = { startIdx, endIdx, centerIdx };
                this.focusTimeRange = {
                    start: this.data.positions[startIdx].game_time,
                    end: this.data.positions[endIdx].game_time
                };

                // í¬ì»¤ìŠ¤ êµ¬ê°„ì˜ ì¤‘ì•™ìœ¼ë¡œ íƒ€ì„ë¼ì¸ ì´ë™
                this.currentTick = centerIdx;
                this.playheadTime = this.data.positions[centerIdx].game_time;
                this.lastFrameTime = Date.now();

                // ì„ íƒëœ ì´ë²¤íŠ¸ ì´ˆê¸°í™” (ìˆœìˆ˜ anomaly ì¤‘ì‹¬)
                this.selectedEvent = null;
            }

            selectEvent(event) {
                // fire ì´ë²¤íŠ¸ëŠ” í´ë¦­í•´ë„ ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•ŠìŒ (hitê³¼ killë§Œ ì²˜ë¦¬)
                const eventType = event.event_type || event.event_type_lower || '';
                const eventTypeLower = eventType.toLowerCase();
                if (eventTypeLower === 'fire') {
                    console.log('Fire event clicked - no action taken (only hit and kill events are clickable)');
                    return;
                }
                
                // ê¸°ì¡´ ì„ íƒ í•´ì œ
                if (this.selectedEvent) {
                    document.querySelectorAll('.event-item.selected').forEach(item => {
                        item.classList.remove('selected');
                    });
                }
                
                // ë””ë²„ê¹…: ì´ë²¤íŠ¸ ë°ì´í„° ê²€ì¦
                console.log('=== selectEvent ë””ë²„ê¹… ===');
                console.log('Event:', {
                    tick: event.tick,
                    game_time: event.game_time,
                    event_type: event.event_type,
                    attacker: {
                        name: event.attacker?.name,
                        position: event.attacker?.position,
                        team: event.attacker?.team
                    },
                    victim: {
                        name: event.victim?.name,
                        position: event.victim?.position,
                        team: event.victim?.team
                    },
                    weapon: event.weapon
                });
                
                this.selectedEvent = event;
                
                // í¬ì»¤ìŠ¤ ëª¨ë“œ í™œì„±í™” (Kill-centered Focus: ì´ë²¤íŠ¸ ì „í›„ 100í‹±)
                this.focusMode = true;
                this.focusModeType = 'kill';
                const centerIdx = this.findTickByTime(event.game_time);
                const startIdx = Math.max(0, centerIdx - 100);
                const endIdx = Math.min(this.data.positions.length - 1, centerIdx + 100);
                this.focusTickRange = { startIdx, endIdx, centerIdx };
                this.focusTimeRange = {
                    start: this.data.positions[startIdx].game_time,
                    end: this.data.positions[endIdx].game_time
                };
                
                // í•´ë‹¹ ì‹œê°„ìœ¼ë¡œ ì´ë™
                const targetTick = this.findTickByTime(event.game_time);
                console.log('Target tick:', targetTick, 'for game_time:', event.game_time);
                
                // targetTickì´ ìœ íš¨í•œì§€ í™•ì¸
                if (targetTick === -1 || targetTick < 0 || targetTick >= this.data.positions.length) {
                    console.warn('Target tick not found for game_time:', event.game_time);
                    return; // ìœ íš¨í•˜ì§€ ì•Šì€ í‹±ì´ë©´ ì¢…ë£Œ
                }
                
                this.currentTick = targetTick;
                // playheadTimeë„ ì´ë²¤íŠ¸ ì‹œê°„ìœ¼ë¡œ ì„¤ì • (ì¬ìƒ ì‹œ í•´ë‹¹ ìˆœê°„ì´ ë³´ì´ë„ë¡)
                this.playheadTime = event.game_time;
                this.lastFrameTime = Date.now(); // í”„ë ˆì„ íƒ€ì´ë° ë¦¬ì…‹
                
                // í•´ë‹¹ í‹±ì˜ í”Œë ˆì´ì–´ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                const tickData = this.data.positions[targetTick];
                if (!tickData || !tickData.players) {
                    console.warn('Tick data or players not found for tick:', targetTick);
                    return;
                }
                
                // ë¨¼ì € í•´ë‹¹ í‹±ì˜ players ë°°ì—´ì—ì„œ attackerì™€ victimì˜ ìœ„ì¹˜ë¥¼ ì°¾ì•„ì„œ ë³´ì™„
                // ì´ë ‡ê²Œ í•˜ë©´ ëª¨ë“  ì´ë²¤íŠ¸ íƒ€ì…(fire, hit, kill)ì— ëŒ€í•´ ë™ì¼í•˜ê²Œ ì‘ë™
                if (event.attacker && event.attacker.name) {
                    const attackerInTick = tickData.players.find(p => p.name === event.attacker.name);
                    if (attackerInTick && attackerInTick.position && attackerInTick.position[0] !== null) {
                        // í‹± ë°ì´í„°ì—ì„œ ì°¾ì€ ìœ„ì¹˜ë¡œ ì—…ë°ì´íŠ¸
                        event.attacker.position = attackerInTick.position;
                        if (!event.attacker.team && attackerInTick.team) {
                            event.attacker.team = attackerInTick.team;
                        }
                        console.log('selectEvent: Attacker position ì—…ë°ì´íŠ¸:', {
                            attacker_name: event.attacker.name,
                            position: event.attacker.position
                        });
                    } else if (!event.attacker.position || event.attacker.position[0] === null) {
                        console.warn('Attacker position not found in tick data:', event.attacker.name);
                    }
                }
                
                if (event.victim && event.victim.name) {
                    const victimInTick = tickData.players.find(p => p.name === event.victim.name);
                    if (victimInTick && victimInTick.position && victimInTick.position[0] !== null) {
                        // í‹± ë°ì´í„°ì—ì„œ ì°¾ì€ ìœ„ì¹˜ë¡œ ì—…ë°ì´íŠ¸
                        event.victim.position = victimInTick.position;
                        if (!event.victim.team && victimInTick.team) {
                            event.victim.team = victimInTick.team;
                        }
                        console.log('selectEvent: Victim position ì—…ë°ì´íŠ¸:', {
                            victim_name: event.victim.name,
                            position: event.victim.position
                        });
                    } else if (!event.victim.position || event.victim.position[0] === null) {
                        console.warn('Victim position not found in tick data:', event.victim.name);
                    }
                }
                
                console.log('Tick data:', {
                    tick: tickData.tick,
                    game_time: tickData.game_time,
                    players_count: tickData.players?.length || 0,
                    attacker_found: event.attacker?.name && tickData.players?.find(p => p.name === event.attacker.name) ? 'YES' : 'NO',
                    victim_found: event.victim?.name && tickData.players?.find(p => p.name === event.victim.name) ? 'YES' : 'NO'
                });
                
                // ë‘ í”Œë ˆì´ì–´ì˜ ì¤‘ì•™ ì¢Œí‘œë¥¼ ì‹œë®¬ë ˆì´ì…˜ ì¤‘ì•™ì— ë°°ì¹˜
                // mapBoundsê°€ ì—†ì–´ë„ ì¹´ë©”ë¼ ìœ„ì¹˜ëŠ” ì„¤ì • (ê²€ì€ í™”ë©´ ë°©ì§€)
                console.log('Camera setup check:', {
                    attacker_position: event.attacker?.position,
                    attacker_position_valid: event.attacker?.position?.[0] !== null && event.attacker?.position?.[0] !== undefined,
                    victim_position: event.victim?.position,
                    victim_position_valid: event.victim?.position?.[0] !== null && event.victim?.position?.[0] !== undefined,
                    mapBounds: this.mapBounds ? 'EXISTS' : 'NULL'
                });
                
                // attacker ë˜ëŠ” victimì˜ ìœ„ì¹˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì¹´ë©”ë¼ ì„¤ì •
                // fire ì´ë²¤íŠ¸ì˜ ê²½ìš° attackerë§Œ ìˆì„ ìˆ˜ ìˆìŒ (victim ì—†ìŒ)
                // attackerê°€ ìˆìœ¼ë©´ attackerë¥¼ ìš°ì„ , ì—†ìœ¼ë©´ victim ì‚¬ìš©
                let primaryPlayer = null;
                let secondaryPlayer = null;
                
                // attackerê°€ ìˆê³  ìœ„ì¹˜ê°€ ìˆìœ¼ë©´ ì‚¬ìš©
                if (event.attacker && event.attacker.name && event.attacker.position && event.attacker.position[0] !== null) {
                    primaryPlayer = event.attacker;
                    // victimì´ ìˆê³  ìœ„ì¹˜ê°€ ìˆìœ¼ë©´ secondaryë¡œ ì„¤ì • (fire ì´ë²¤íŠ¸ëŠ” victimì´ ì—†ì„ ìˆ˜ ìˆìŒ)
                    if (event.victim && event.victim.name && event.victim.position && event.victim.position[0] !== null) {
                        secondaryPlayer = event.victim;
                    }
                } 
                // attackerê°€ ì—†ê±°ë‚˜ ìœ„ì¹˜ê°€ ì—†ìœ¼ë©´ victim ì‚¬ìš©
                else if (event.victim && event.victim.name && event.victim.position && event.victim.position[0] !== null) {
                    primaryPlayer = event.victim;
                    secondaryPlayer = null;
                } 
                // attackerì™€ victim ëª¨ë‘ ìœ„ì¹˜ê°€ ì—†ìœ¼ë©´ í•´ë‹¹ í‹±ì˜ ì²« ë²ˆì§¸ í”Œë ˆì´ì–´ ì‚¬ìš©
                else {
                    if (tickData.players && tickData.players.length > 0) {
                        // attacker ì´ë¦„ì´ ìˆìœ¼ë©´ í•´ë‹¹ í”Œë ˆì´ì–´ë¥¼ ìš°ì„  ì°¾ê¸°
                        if (event.attacker && event.attacker.name) {
                            const attackerInTick = tickData.players.find(p => p.name === event.attacker.name && p.position && p.position[0] !== null);
                            if (attackerInTick) {
                                primaryPlayer = {
                                    name: attackerInTick.name,
                                    position: attackerInTick.position,
                                    team: attackerInTick.team
                                };
                                console.log('Using attacker from tick as fallback:', primaryPlayer.name);
                            }
                        }
                        
                        // attackerë¥¼ ì°¾ì§€ ëª»í–ˆìœ¼ë©´ ì²« ë²ˆì§¸ í”Œë ˆì´ì–´ ì‚¬ìš©
                        if (!primaryPlayer) {
                            const firstPlayer = tickData.players.find(p => p.position && p.position[0] !== null);
                            if (firstPlayer) {
                                primaryPlayer = {
                                    name: firstPlayer.name,
                                    position: firstPlayer.position,
                                    team: firstPlayer.team
                                };
                                console.log('Using first player from tick as fallback:', primaryPlayer.name);
                            }
                        }
                    }
                }
                
                console.log('Primary/Secondary player selection:', {
                    primary: primaryPlayer ? primaryPlayer.name : 'NONE',
                    secondary: secondaryPlayer ? secondaryPlayer.name : 'NONE',
                    event_type: event.event_type,
                    attacker_name: event.attacker?.name,
                    victim_name: event.victim?.name
                });
                
                if (primaryPlayer && primaryPlayer.position && primaryPlayer.position[0] !== null) {
                    // ìŠ¤ì¼€ì¼ë§ëœ ì¢Œí‘œ ì‚¬ìš©
                    const primaryPos = {
                        x: (primaryPlayer.position[0] - this.coordinateOffset.x) * this.coordinateScale,
                        y: (primaryPlayer.position[2] - this.coordinateOffset.z) * this.coordinateScale,
                        z: (primaryPlayer.position[1] - this.coordinateOffset.y) * this.coordinateScale
                    };
                    
                    let centerPos = primaryPos;
                    
                    // secondary player (victim ë˜ëŠ” attacker) ìœ„ì¹˜ê°€ ìˆìœ¼ë©´ ì¤‘ì•™ ì¢Œí‘œ ê³„ì‚°
                    if (secondaryPlayer && secondaryPlayer.position && secondaryPlayer.position[0] !== null) {
                        const secondaryPos = {
                            x: (secondaryPlayer.position[0] - this.coordinateOffset.x) * this.coordinateScale,
                            y: (secondaryPlayer.position[2] - this.coordinateOffset.z) * this.coordinateScale,
                            z: (secondaryPlayer.position[1] - this.coordinateOffset.y) * this.coordinateScale
                        };
                        
                        // ë‘ í”Œë ˆì´ì–´ì˜ ì¤‘ì•™ ì¢Œí‘œ ê³„ì‚°
                        centerPos = {
                            x: (primaryPos.x + secondaryPos.x) / 2,
                            y: (primaryPos.y + secondaryPos.y) / 2,
                            z: (primaryPos.z + secondaryPos.z) / 2
                        };
                        
                        // ê±°ë¦¬ ê³„ì‚°í•˜ì—¬ ì ì ˆí•œ ì¹´ë©”ë¼ ê±°ë¦¬ ì„¤ì •
                        const distance = Math.sqrt(
                            Math.pow(primaryPos.x - secondaryPos.x, 2) +
                            Math.pow(primaryPos.y - secondaryPos.y, 2) +
                            Math.pow(primaryPos.z - secondaryPos.z, 2)
                        );
                        
                        // í¬ì»¤ìŠ¤ ëª¨ë“œ: ë” í™•ëŒ€ë˜ì–´ ë³´ì´ë„ë¡ ì¹´ë©”ë¼ ê±°ë¦¬ ì¡°ì • (ì¤‘ì•™ í™”ë©´ì— ë“¤ì–´ì˜¤ê²Œ)
                        // ê±°ë¦¬ì— ë”°ë¼ ì¹´ë©”ë¼ ê±°ë¦¬ ì¡°ì • (ë” ê°€ê¹ê²Œ, ìµœì†Œ 300, ìµœëŒ€ 1200)
                        this.cameraDistance = Math.max(300, Math.min(1200, distance * 0.8));
                    } else {
                        // secondary player ìœ„ì¹˜ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ ê±°ë¦¬ ì‚¬ìš© (í¬ì»¤ìŠ¤ ëª¨ë“œì—ì„œëŠ” ë” ê°€ê¹ê²Œ)
                        const bounds = this.mapBounds;
                        if (bounds) {
                            const maxDim = Math.max(bounds.width, bounds.height, bounds.depth);
                            this.cameraDistance = maxDim * 0.4; // í¬ì»¤ìŠ¤ ëª¨ë“œì—ì„œëŠ” ë” ê°€ê¹ê²Œ
                        } else {
                            this.cameraDistance = 800; // ê¸°ë³¸ ê±°ë¦¬
                        }
                    }
                    
                    // ì¹´ë©”ë¼ ìœ„ì¹˜ë¥¼ ì¤‘ì•™ ì¢Œí‘œ ì¤‘ì‹¬ìœ¼ë¡œ ë°°ì¹˜
                    this.cameraRotationX = 0.4;
                    this.cameraRotationY = Math.PI / 4; // 45ë„ ê°ë„
                    
                    // ì¹´ë©”ë¼ íƒ€ê²Ÿì„ ì¤‘ì•™ ì¢Œí‘œë¡œ ì„¤ì •
                    this.cameraTarget = centerPos;
                    
                    // íŒ¨ë‹ ì˜¤í”„ì…‹ ì´ˆê¸°í™”
                    if (this.panOffset) {
                        this.panOffset.x = 0;
                        this.panOffset.y = 0;
                        this.panOffset.z = 0;
                    }
                    
                    // ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸ (ë Œë”ë§ ì „ì— ë¨¼ì € ì—…ë°ì´íŠ¸í•˜ì—¬ ê²€ì€ í™”ë©´ ë°©ì§€)
                    console.log('Camera target set to:', this.cameraTarget, 'distance:', this.cameraDistance);
                    this.updateCameraToTarget();
                    
                    // ì¹´ë©”ë¼ê°€ ì œëŒ€ë¡œ ì„¤ì •ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ê³  ë Œë”ë§
                    // ì¹´ë©”ë¼ íƒ€ê²Ÿì´ ì„¤ì •ë˜ì—ˆìœ¼ë©´ ë Œë”ë§ ìˆ˜í–‰
                    if (this.cameraTarget) {
                        // ë Œë”ë§ ìˆ˜í–‰ (ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸ í›„)
                        if (targetTick !== -1 && targetTick >= 0 && targetTick < this.data.positions.length) {
                            // í˜„ì¬ í‹±ì„ í™•ì‹¤íˆ ì„¤ì •
                            this.currentTick = targetTick;
                            
                            // playheadTimeë„ ì´ë²¤íŠ¸ ì‹œê°„ìœ¼ë¡œ ì„¤ì •
                            this.playheadTime = event.game_time;
                            this.lastFrameTime = Date.now();
                            
                            // ì¦‰ì‹œ ë Œë”ë§ ìˆ˜í–‰ (ë³´ê°„ ì—†ì´ í•´ë‹¹ í‹±ìœ¼ë¡œ ë°”ë¡œ ì´ë™)
                            this.renderTick(this.currentTick, 0);
                            this.updateTimeDisplay();
                            
                            // ì´ë²¤íŠ¸ ë Œë”ë§ (hitê³¼ kill ì´ë²¤íŠ¸ ì‹œê°í™”)
                            const eventGameTime = event.game_time;
                            this.renderEvents(eventGameTime);
                            
                            console.log('selectEvent: ë Œë”ë§ ì™„ë£Œ', {
                                event_type: event.event_type,
                                targetTick: targetTick,
                                currentTick: this.currentTick,
                                cameraTarget: this.cameraTarget
                            });
                        } else {
                            console.warn('selectEvent: Invalid targetTick:', targetTick, 'positions length:', this.data.positions.length);
                        }
                    } else {
                        console.error('Camera target not set, cannot render');
                    }
                } else {
                    console.warn('Primary player position is null, using fallback camera');
                    // mapBoundsê°€ ì—†ê±°ë‚˜ í”Œë ˆì´ì–´ ìœ„ì¹˜ê°€ ì—†ì„ ë•Œ ê¸°ë³¸ ì¹´ë©”ë¼ ì„¤ì •
                    if (this.mapBounds) {
                        const bounds = this.mapBounds;
                        this.cameraTarget = {
                            x: bounds.centerX || 0,
                            y: bounds.centerZ || 0,
                            z: bounds.centerY || 0
                        };
                        const maxDim = Math.max(bounds.width || 1000, bounds.height || 1000, bounds.depth || 1000);
                        this.cameraDistance = maxDim * 0.4;
                        this.cameraRotationX = 0.4;
                        this.cameraRotationY = Math.PI / 4;
                        console.log('Fallback camera (mapBounds):', this.cameraTarget, 'distance:', this.cameraDistance);
                        this.updateCameraToTarget();
                    } else {
                        // mapBoundsê°€ ì—†ì–´ë„ ê¸°ë³¸ ì¹´ë©”ë¼ ì„¤ì •
                        console.warn('No mapBounds, using default camera at origin');
                        this.cameraTarget = { x: 0, y: 0, z: 0 };
                        this.cameraDistance = 1000;
                        this.cameraRotationX = 0.4;
                        this.cameraRotationY = Math.PI / 4;
                        this.updateCameraToTarget();
                    }
                    
                    // fallback ì¹´ë©”ë¼ ì„¤ì • í›„ì—ë„ ë Œë”ë§ ì‹œë„
                    if (targetTick !== -1 && targetTick >= 0 && targetTick < this.data.positions.length) {
                        this.currentTick = targetTick;
                        this.renderTick(this.currentTick, 0);
                        this.updateTimeDisplay();
                        const eventGameTime = event.game_time;
                        this.renderEvents(eventGameTime);
                    }
                }
                
                // ì´ë²¤íŠ¸ ë¡œê·¸ ì—…ë°ì´íŠ¸
                this.updateEventLog();
                
                // í¬ì»¤ìŠ¤ ëª¨ë“œ í‘œì‹œ
                this.showFocusModeIndicator();
                // Aim Trace íƒ­ì´ ì—´ë ¤ìˆë‹¤ë©´ ê°±ì‹ 
                const activeTabEl = document.querySelector('.tab-btn.active');
                const activeTab = activeTabEl ? activeTabEl.getAttribute('data-tab') : null;
                if (activeTab === 'aim') this.renderAimTrace();
            }
            
            updateCameraToTarget() {
                if (!this.cameraTarget) {
                    console.warn('updateCameraToTarget: cameraTarget is null');
                    return;
                }
                
                // mapBoundsê°€ ì—†ì–´ë„ ì¹´ë©”ë¼ ì„¤ì • ê°€ëŠ¥í•˜ë„ë¡ ìˆ˜ì •
                const target = this.cameraTarget;
                
                // cameraDistanceê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìœ¼ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©
                if (!this.cameraDistance || this.cameraDistance <= 0) {
                    if (this.mapBounds) {
                        const bounds = this.mapBounds;
                        const maxDim = Math.max(bounds.width || 1000, bounds.height || 1000, bounds.depth || 1000);
                        this.cameraDistance = maxDim * 0.4;
                    } else {
                        this.cameraDistance = 800; // ê¸°ë³¸ ê±°ë¦¬
                    }
                }
                
                // cameraRotationì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìœ¼ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©
                if (this.cameraRotationX === undefined || this.cameraRotationX === null) {
                    this.cameraRotationX = 0.4;
                }
                if (this.cameraRotationY === undefined || this.cameraRotationY === null) {
                    this.cameraRotationY = Math.PI / 4;
                }
                
                const x = target.x + this.cameraDistance * Math.sin(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                const y = target.y + this.cameraDistance * Math.sin(this.cameraRotationX);
                const z = target.z + this.cameraDistance * Math.cos(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                
                // íŒ¨ë‹ ì˜¤í”„ì…‹ ì ìš©
                this.camera.position.set(
                    x + (this.panOffset ? this.panOffset.x : 0),
                    y + (this.panOffset ? this.panOffset.y : 0),
                    z + (this.panOffset ? this.panOffset.z : 0)
                );
                this.camera.lookAt(
                    target.x + (this.panOffset ? this.panOffset.x : 0),
                    target.y + (this.panOffset ? this.panOffset.y : 0),
                    target.z + (this.panOffset ? this.panOffset.z : 0)
                );
                
                console.log('updateCameraToTarget completed:', {
                    target: target,
                    cameraPosition: this.camera.position,
                    cameraDistance: this.cameraDistance,
                    mapBounds: this.mapBounds ? 'EXISTS' : 'NULL'
                });
            }

            findTickByTime(targetTime) {
                if (!this.data) return -1;
                
                let closestTick = 0;
                let minDiff = Infinity;
                
                this.data.positions.forEach((pos, idx) => {
                    const diff = Math.abs(pos.game_time - targetTime);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestTick = idx;
                    }
                });
                
                return closestTick;
            }

            showFocusModeIndicator() {
                // í¬ì»¤ìŠ¤ ëª¨ë“œ ì¸ë””ì¼€ì´í„° í‘œì‹œ
                const focusControls = document.getElementById('focus-controls');
                const timeDisplay = document.getElementById('time-display');
                
                if (this.focusMode && this.focusTimeRange) {
                    focusControls.classList.add('show');
                    const range = this.focusTimeRange.end - this.focusTimeRange.start;
                    const info = document.getElementById('focus-info');
                    info.textContent = `Focus: ${this.formatTime(this.focusTimeRange.start)} - ${this.formatTime(this.focusTimeRange.end)} (${this.formatTime(range)})`;
                    timeDisplay.style.color = '#4a90e2';
                    timeDisplay.style.fontWeight = 'bold';
                } else {
                    focusControls.classList.remove('show');
                    timeDisplay.style.color = '';
                    timeDisplay.style.fontWeight = '';
                }
            }

            exitFocusMode() {
                this.focusMode = false;
                this.focusModeType = 'anomaly';
                this.focusTickRange = null;
                this.focusTimeRange = null;
                this.focusPlayerId = null;
                this.selectedEvent = null;
                this.selectedAnomalySeq = null; // ì„ íƒëœ ì´ìƒ êµ¬ê°„
                
                // UI ì—…ë°ì´íŠ¸
                const focusControls = document.getElementById('focus-controls');
                const focusModeContent = document.getElementById('focus-mode-content');
                const playerSelect = document.getElementById('player-select');
                
                if (focusControls) {
                    focusControls.style.display = 'none';
                    focusControls.classList.remove('show');
                }
                if (focusModeContent) focusModeContent.style.display = 'none';
                if (playerSelect) playerSelect.value = '';
                
                // í˜„ì¬ ì‹œì ì„ ìœ ì§€í•œ ì±„ ë Œë”ë§
                if (this.data && this.data.positions && this.currentTick !== undefined) {
                    this.renderTick(this.currentTick, 0);
                    this.updateTimeDisplay();
                }
                
                // Action Stream ë ˆì´ì•„ì›ƒ ì›ë˜ëŒ€ë¡œ ë³µì› (ìœ„ì•„ë˜ ë ˆì´ì•„ì›ƒ)
                const eventLog = document.getElementById('event-log');
                const activeTab = document.querySelector('.tab-btn.active');
                if (eventLog && activeTab) {
                    const tab = activeTab.getAttribute('data-tab');
                    if (tab === 'actions') {
                        eventLog.classList.remove('aim-trace');
                        eventLog.classList.add('action-stream');
                    } else if (tab === 'aim') {
                        eventLog.classList.remove('action-stream');
                        eventLog.classList.add('aim-trace');
                    }
                }
                
                // ì´ë²¤íŠ¸ ë¡œê·¸ ì—…ë°ì´íŠ¸ (í¬ì»¤ìŠ¤ ëª¨ë“œ ì¢…ë£Œ ì‹œ ì›ë˜ëŒ€ë¡œ)
                this.updateEventLog();
                
                // updateEventLog í›„ì— ìœ„ì•„ë˜ ë ˆì´ì•„ì›ƒ ê°•ì œ ì ìš© (ìµœì´ˆ ë¶„ì„ ì‹œì™€ ë™ì¼í•˜ê²Œ)
                setTimeout(() => {
                    if (eventLog && activeTab) {
                        const tab = activeTab.getAttribute('data-tab');
                        if (tab === 'actions') {
                            // ìœ„ì•„ë˜ ë ˆì´ì•„ì›ƒ ë³´ì¥ (ìµœì´ˆ ë¶„ì„ ì‹œì™€ ë™ì¼)
                            eventLog.style.display = 'block';
                            eventLog.style.whiteSpace = 'normal';
                            eventLog.style.overflow = 'auto';
                            eventLog.style.overflowX = 'hidden';
                            eventLog.style.overflowY = 'auto';
                            eventLog.style.flexDirection = '';
                            eventLog.style.flexWrap = '';
                            // ëª¨ë“  event-itemë„ ìœ„ì•„ë˜ ë ˆì´ì•„ì›ƒ ë³´ì¥
                            const eventItems = eventLog.querySelectorAll('.event-item');
                            eventItems.forEach(item => {
                                item.style.display = 'block';
                                item.style.whiteSpace = 'normal';
                                item.style.flexShrink = '';
                                item.style.flexGrow = '';
                                item.style.marginBottom = '2px';
                                item.style.width = 'auto';
                                item.style.minWidth = '';
                                item.style.maxWidth = '';
                            });
                        }
                    }
                }, 0);
                
                // ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸ (í˜„ì¬ ì‹œì  ìœ ì§€)
                if (this.cameraTarget) {
                    this.updateCameraToTarget();
                } else {
                    this.updateCamera();
                }
                
                this.showFocusModeIndicator();
                this.updateEventLog();
                
                // í˜„ì¬ ì‹œì ì—ì„œ ìì—°ìŠ¤ëŸ½ê²Œ ì¬ìƒ ì‹œì‘
                if (!this.isPlaying) {
                    this.isPlaying = true;
                    document.getElementById('play-btn').textContent = 'â¸';
                    this.lastFrameTime = Date.now();
                    this.playheadTime = this.data.positions[this.currentTick]?.game_time || 0;
                }
            }

            renderTick(tickIndex, interpolation = 0) {
                if (!this.data || !this.data.positions) {
                    console.warn('renderTick: data ë˜ëŠ” positionsê°€ ì—†ìŠµë‹ˆë‹¤');
                    return;
                }

                const tickData = this.data.positions[tickIndex];
                if (!tickData) {
                    console.warn('renderTick: tickDataê°€ ì—†ìŠµë‹ˆë‹¤', { tickIndex, totalPositions: this.data.positions.length });
                    // ì–´ë–¤ í‹±ì—ì„œë„ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ë™ì  ì˜¤ë¸Œì íŠ¸ ì „ë¶€ ì •ë¦¬
                    this.playerObjects.forEach(obj => this.scene.remove(obj));
                    this.playerLabels.forEach(obj => this.scene.remove(obj));
                    this.eventMarkers.forEach(m => this.scene.remove(m));
                    this.playerObjects.clear();
                    this.playerLabels.clear();
                    this.eventMarkers = [];
                    return;
                }

                if (!tickData.players || tickData.players.length === 0) {
                    console.warn('renderTick: playersê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤', { tickIndex, tick: tickData.tick });
                    // í”Œë ˆì´ì–´ê°€ ì—†ì–´ë„ ê¸°ì¡´ ì˜¤ë¸Œì íŠ¸ëŠ” ì œê±°
                    this.playerObjects.forEach(obj => this.scene.remove(obj));
                    this.playerLabels.forEach(obj => this.scene.remove(obj));
                    this.eventMarkers.forEach(m => this.scene.remove(m));
                    this.playerObjects.clear();
                    this.playerLabels.clear();
                    this.eventMarkers = [];
                    return;
                }

                // ë‹¤ìŒ í‹± ë°ì´í„° ë° ë³´ê°„ ë¹„ìœ¨ ê³„ì‚° (ë¶€ë“œëŸ¬ìš´ ì´ë™ìš©)
                const nextTickData = this.data.positions[Math.min(tickIndex + 1, this.data.positions.length - 1)];
                const lerpT = Math.max(0, Math.min(1, Number.isFinite(interpolation) ? interpolation : 0));

                // í¬ì»¤ìŠ¤ ëª¨ë“œì¼ ë•ŒëŠ” ì„ íƒëœ ì‹œê°„ êµ¬ê°„ì— í¬í•¨ë˜ëŠ” í‹±ë§Œ ë Œë”
                if (this.focusMode && this.focusTickRange) {
                    // í‹± ì¸ë±ìŠ¤ ê¸°ë°˜ìœ¼ë¡œ ì²´í¬ (ë” ì •í™•í•¨)
                    if (tickIndex < this.focusTickRange.startIdx || tickIndex > this.focusTickRange.endIdx) {
                        // í¬ì»¤ìŠ¤ ë²”ìœ„ ë°–ì´ë©´ í”Œë ˆì´ì–´/ë¼ë²¨/ì´ë²¤íŠ¸ ëª¨ë‘ ìˆ¨ê¹€
                        this.playerObjects.forEach(obj => this.scene.remove(obj));
                        this.playerLabels.forEach(obj => this.scene.remove(obj));
                        this.playerObjects.clear();
                        this.playerLabels.clear();
                        this.renderEvents(null); // ì´ë²¤íŠ¸ ëª¨ë‘ ì œê±°
                        return;
                    }
                }

                // ë””ë²„ê¹… ì œê±° (ì„±ëŠ¥ ìµœì í™”)

                // ê¸°ì¡´ ì˜¤ë¸Œì íŠ¸ ì œê±° (ì”ìƒ ë°©ì§€ - ì™„ì „íˆ ì œê±°)
                // playerObjects ì œê±° (ë” ê°•ë ¥í•œ ì œê±° ë¡œì§)
                if (this.playerObjects && this.playerObjects.size > 0) {
                    const objectsToRemove = Array.from(this.playerObjects.values());
                    objectsToRemove.forEach(obj => {
                        if (obj) {
                            try {
                                // sceneì—ì„œ ì§ì ‘ ì œê±° (ì—¬ëŸ¬ ë°©ë²• ì‹œë„)
                                if (this.scene.children.includes(obj)) {
                                    this.scene.remove(obj);
                                }
                                // scene.children ë°°ì—´ì—ì„œ ì§ì ‘ ì œê±°
                                const index = this.scene.children.indexOf(obj);
                                if (index !== -1) {
                                    this.scene.children.splice(index, 1);
                                }
                                // parentì—ì„œë„ ì œê±°
                            if (obj.parent) {
                                obj.parent.remove(obj);
                            }
                            } catch (e) {
                                console.warn('í”Œë ˆì´ì–´ ì˜¤ë¸Œì íŠ¸ ì œê±° ì¤‘ ì˜¤ë¥˜:', e);
                            }
                            // ë©”ì‹œì˜ ì§€ì˜¤ë©”íŠ¸ë¦¬ì™€ ë¨¸í‹°ë¦¬ì–¼ ì •ë¦¬
                            try {
                            if (obj.geometry) {
                                obj.geometry.dispose();
                            }
                            if (obj.material) {
                                if (Array.isArray(obj.material)) {
                                    obj.material.forEach(mat => {
                                        if (mat) mat.dispose();
                                    });
                                } else {
                                    obj.material.dispose();
                                }
                                }
                            } catch (e) {
                                console.warn('í”Œë ˆì´ì–´ ì˜¤ë¸Œì íŠ¸ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì¤‘ ì˜¤ë¥˜:', e);
                            }
                        }
                    });
                    this.playerObjects.clear();
                }
                
                // ì¶”ê°€ ì•ˆì „ì¥ì¹˜: sceneì—ì„œ ë‚¨ì•„ìˆëŠ” ëª¨ë“  í”Œë ˆì´ì–´ ë©”ì‹œ ì œê±°
                // ì´ëŠ” ì´ì „ í‹±ì—ì„œ ì œê±°ë˜ì§€ ì•Šì€ í”Œë ˆì´ì–´ ì˜¤ë¸Œì íŠ¸ë“¤ì„ ì •ë¦¬í•˜ê¸° ìœ„í•¨
                const meshesToRemove = [];
                for (let i = this.scene.children.length - 1; i >= 0; i--) {
                    const child = this.scene.children[i];
                    if (child instanceof THREE.Mesh) {
                        // í”Œë ˆì´ì–´ ë©”ì‹œì¸ì§€ í™•ì¸ (SphereGeometry ë˜ëŠ” ConeGeometry)
                        const isPlayerMesh = child.geometry && (
                            child.geometry instanceof THREE.SphereGeometry ||
                            child.geometry instanceof THREE.ConeGeometry
                        );
                        // ë˜ëŠ” playerObjectsì— ì—†ëŠ” ë©”ì‹œ ì¤‘ì—ì„œ ì‘ì€ í¬ê¸°ì˜ ê²ƒë“¤ (í”Œë ˆì´ì–´ í›„ë³´)
                        const isSmallMesh = child.scale && (
                            (child.scale.x < 50 && child.scale.y < 50 && child.scale.z < 50) ||
                            (child.geometry && child.geometry.type === 'SphereGeometry' && child.geometry.parameters && child.geometry.parameters.radius < 50) ||
                            (child.geometry && child.geometry.type === 'ConeGeometry')
                        );
                        if (isPlayerMesh || (isSmallMesh && !this.playerObjects.has(child.userData?.playerName))) {
                            // playerObjectsì— ì—†ëŠ” í”Œë ˆì´ì–´ ë©”ì‹œë©´ ì œê±° ëŒ€ìƒ
                            let shouldRemove = false;
                            if (isPlayerMesh) {
                                shouldRemove = true;
                            } else if (isSmallMesh) {
                                // playerObjectsì— ì—†ëŠ”ì§€ í™•ì¸
                                let found = false;
                                this.playerObjects.forEach((mesh, playerName) => {
                                    if (mesh === child) {
                                        found = true;
                                    }
                                });
                                if (!found) {
                                    shouldRemove = true;
                                }
                            }
                            if (shouldRemove) {
                                meshesToRemove.push(child);
                            }
                        }
                    }
                }
                meshesToRemove.forEach(mesh => {
                    try {
                        if (mesh.parent) {
                            mesh.parent.remove(mesh);
                        }
                        if (this.scene.children.includes(mesh)) {
                            this.scene.remove(mesh);
                        }
                        const index = this.scene.children.indexOf(mesh);
                        if (index !== -1) {
                            this.scene.children.splice(index, 1);
                        }
                        if (mesh.geometry) {
                            mesh.geometry.dispose();
                        }
                        if (mesh.material) {
                            if (Array.isArray(mesh.material)) {
                                mesh.material.forEach(mat => mat.dispose());
                            } else {
                                mesh.material.dispose();
                            }
                        }
                    } catch (e) {
                        console.warn('ì¶”ê°€ í”Œë ˆì´ì–´ ë©”ì‹œ ì œê±° ì¤‘ ì˜¤ë¥˜:', e);
                    }
                });
                
                // playerLabels ì œê±° (ë” ê°•ë ¥í•œ ì œê±° ë¡œì§)
                if (this.playerLabels && this.playerLabels.size > 0) {
                    const labelsToRemove = Array.from(this.playerLabels.values());
                    labelsToRemove.forEach(obj => {
                        if (obj) {
                            try {
                                // sceneì—ì„œ ì§ì ‘ ì œê±° (ì—¬ëŸ¬ ë°©ë²• ì‹œë„)
                                if (this.scene.children.includes(obj)) {
                                    this.scene.remove(obj);
                                }
                                // scene.children ë°°ì—´ì—ì„œ ì§ì ‘ ì œê±°
                                const index = this.scene.children.indexOf(obj);
                                if (index !== -1) {
                                    this.scene.children.splice(index, 1);
                                }
                                // parentì—ì„œë„ ì œê±°
                            if (obj.parent) {
                                obj.parent.remove(obj);
                            }
                            } catch (e) {
                                console.warn('ë¼ë²¨ ì œê±° ì¤‘ ì˜¤ë¥˜:', e);
                            }
                            // ìŠ¤í”„ë¼ì´íŠ¸ì˜ ë¨¸í‹°ë¦¬ì–¼ê³¼ í…ìŠ¤ì²˜ ì •ë¦¬
                            try {
                            if (obj.material) {
                                if (obj.material.map) {
                                    obj.material.map.dispose();
                                }
                                obj.material.dispose();
                                }
                            } catch (e) {
                                console.warn('ë¼ë²¨ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì¤‘ ì˜¤ë¥˜:', e);
                            }
                        }
                    });
                    this.playerLabels.clear();
                }
                
                // ì¶”ê°€ ì•ˆì „ì¥ì¹˜: sceneì—ì„œ ë‚¨ì•„ìˆëŠ” ëª¨ë“  í”Œë ˆì´ì–´ ë¼ë²¨ ìŠ¤í”„ë¼ì´íŠ¸ ì œê±°
                // ì´ëŠ” ì´ì „ í‹±ì—ì„œ ì œê±°ë˜ì§€ ì•Šì€ ë¼ë²¨ë“¤ì„ ì •ë¦¬í•˜ê¸° ìœ„í•¨
                const spritesToRemove = [];
                for (let i = this.scene.children.length - 1; i >= 0; i--) {
                    const child = this.scene.children[i];
                    if (child instanceof THREE.Sprite) {
                        // í”Œë ˆì´ì–´ ë¼ë²¨ì¸ì§€ í™•ì¸ (userData ë˜ëŠ” material íŠ¹ì„±ìœ¼ë¡œ íŒë‹¨)
                        const isPlayerLabel = child.userData && child.userData.isPlayerLabel;
                        // ë˜ëŠ” playerLabelsì— ì—†ëŠ” ìŠ¤í”„ë¼ì´íŠ¸ ì¤‘ì—ì„œ ì‘ì€ í¬ê¸°ì˜ ê²ƒë“¤ (ë¼ë²¨ í›„ë³´)
                        const isSmallSprite = child.scale && child.scale.y < 20; // ë¼ë²¨ì€ ì‘ì€ ìŠ¤í”„ë¼ì´íŠ¸
                        if (isPlayerLabel || (isSmallSprite && !this.playerLabels.has(child.userData?.playerName))) {
                            spritesToRemove.push(child);
                        }
                    }
                }
                spritesToRemove.forEach(sprite => {
                    try {
                        if (sprite.parent) {
                            sprite.parent.remove(sprite);
                        }
                        if (this.scene.children.includes(sprite)) {
                            this.scene.remove(sprite);
                        }
                        const index = this.scene.children.indexOf(sprite);
                        if (index !== -1) {
                            this.scene.children.splice(index, 1);
                        }
                        if (sprite.material && sprite.material.map) {
                            sprite.material.map.dispose();
                        }
                        if (sprite.material) {
                            sprite.material.dispose();
                        }
                    } catch (e) {
                        console.warn('ì¶”ê°€ ë¼ë²¨ ì œê±° ì¤‘ ì˜¤ë¥˜:', e);
                    }
                });
                
                // í”Œë ˆì´ì–´ íŠ¸ë ˆì¼ë„ ì œê±° (ì”ìƒ ë°©ì§€)
                if (this.playerTrails && this.playerTrails.size > 0) {
                    const trailsToRemove = Array.from(this.playerTrails.values());
                    trailsToRemove.forEach(trailData => {
                        if (trailData && trailData.line) {
                            if (trailData.line.parent) {
                                trailData.line.parent.remove(trailData.line);
                            }
                            if (this.scene.children.includes(trailData.line)) {
                                this.scene.remove(trailData.line);
                            }
                            if (trailData.line.geometry) {
                                trailData.line.geometry.dispose();
                            }
                            if (trailData.line.material) {
                                trailData.line.material.dispose();
                            }
                        }
                    });
                    this.playerTrails.clear();
                }

                // í”Œë ˆì´ì–´ ë Œë”ë§
                // í¬ì»¤ìŠ¤ ëª¨ë“œì—ì„œ victimì´ tickData.playersì— ì—†ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ, event.victimì„ ê°•ì œë¡œ ì¶”ê°€
                const playersToRender = [...tickData.players];
                if (this.focusMode && this.selectedEvent && this.selectedEvent.victim) {
                    const victimName = this.selectedEvent.victim.name;
                    const victimInPlayers = playersToRender.find(p => p.name === victimName);
                    // victimì´ playersì— ì—†ê³ , event.victimì— positionì´ ìˆìœ¼ë©´ ê°•ì œë¡œ ì¶”ê°€
                    if (!victimInPlayers && this.selectedEvent.victim.position && this.selectedEvent.victim.position[0] !== null) {
                        // event.victim ì •ë³´ë¥¼ ì‚¬ìš©í•˜ì—¬ ê°€ìƒì˜ í”Œë ˆì´ì–´ ê°ì²´ ìƒì„±
                        const virtualVictim = {
                            name: victimName,
                            position: this.selectedEvent.victim.position,
                            team: this.selectedEvent.victim.team || 'T',
                            weapon: this.selectedEvent.victim.weapon,
                            health: 0 // ì‚¬ë§ ìƒíƒœë¡œ í‘œì‹œí•˜ë˜ ë Œë”ë§ì€ í•¨
                        };
                        playersToRender.push(virtualVictim);
                    }
                }
                
                for (let i = 0; i < playersToRender.length; i++) {
                    const player = playersToRender[i];
                    
                    // ì‚¬ë§í•œ í”Œë ˆì´ì–´ëŠ” ì‹œë®¬ë ˆì´ì…˜ì—ì„œ ì œì™¸ (ë Œë”ë§ ë° ë¼ë²¨ ë¹„í‘œì‹œ)
                    // ë‹¨, í¬ì»¤ìŠ¤ ëª¨ë“œì—ì„œ victimì€ ê°•ì œë¡œ í‘œì‹œ
                    const isDead = player.health !== null && player.health <= 0;
                    const isForcedVictim = (this.focusMode && this.selectedEvent && this.selectedEvent.victim && this.selectedEvent.victim.name === player.name);
                    if (isDead && !isForcedVictim) {
                        continue;
                    }
                    
                    // ìœ„ì¹˜ ë°ì´í„° ê²€ì¦
                    if (!player.position || !Array.isArray(player.position) || player.position.length < 3) {
                        console.error('í”Œë ˆì´ì–´ ìœ„ì¹˜ ë°ì´í„° ì˜¤ë¥˜:', player.name, player.position);
                        continue;
                    }
                    
                    const posX = player.position[0];
                    const posY = player.position[1];
                    const posZ = player.position[2];
                    
                    if (Number.isNaN(posX) || Number.isNaN(posY) || Number.isNaN(posZ)) {
                        console.error('í”Œë ˆì´ì–´ ìœ„ì¹˜ì— NaN:', player.name, { posX, posY, posZ });
                        continue;
                    }
                    
                    const isCT = player.team === 'CT';
                    const baseColor = isCT ? 0x5b9bd5 : 0xff6b6b;
                    
                    // í¬ì»¤ìŠ¤ ëª¨ë“œì¼ ë•Œ ì´ë²¤íŠ¸ì™€ ê´€ë ¨ ì—†ëŠ” í”Œë ˆì´ì–´ëŠ” íšŒìƒ‰/íˆ¬ëª… ì²˜ë¦¬
                    let color = baseColor;
                    let opacity = 1.0;
                    let isFocusedPlayer = false;
                    
                    if (this.focusMode && this.selectedEvent) {
                        const isAttacker = this.selectedEvent.attacker && this.selectedEvent.attacker.name === player.name;
                        const isVictim = this.selectedEvent.victim && this.selectedEvent.victim.name === player.name;
                        isFocusedPlayer = isAttacker || isVictim;
                        
                        if (!isFocusedPlayer) {
                            // ê´€ë ¨ ì—†ëŠ” í”Œë ˆì´ì–´: íšŒìƒ‰ìœ¼ë¡œ ë³€ê²½í•˜ê³  íˆ¬ëª…ë„ ë‚®ì¶¤
                            color = 0x666666; // íšŒìƒ‰
                            opacity = 0.3; // íˆ¬ëª…ë„ 30%
                        }
                    }
                    
                    // CTëŠ” ì›í˜•, TëŠ” ì‚¼ê°í˜•
                    // ë§µ í¬ê¸°ì— ë¹„ë¡€í•˜ì—¬ í”Œë ˆì´ì–´ í¬ê¸° ì¡°ì • (ì •ê·œí™”ëœ í¬ê¸° ì‚¬ìš©)
                    const mapSize = this.mapBounds ? Math.max(this.mapBounds.width, this.mapBounds.depth, this.mapBounds.height) : 1000;
                    // ì •ê·œí™”ëœ í¬ê¸° ì‚¬ìš© (ë” ì¼ê´€ëœ í¬ê¸°)
                    const normalizedMapSize = this.mapBounds?.normalizedWidth || mapSize;
                    // í”Œë ˆì´ì–´ í¬ê¸° ì¡°ì • (ê°€ì‹œì„± í–¥ìƒ)
                    const playerScale = Math.max(0.25, Math.min(0.6, normalizedMapSize / 5000)); // í¬ê¸° ì¦ê°€
                    const baseSize = 5 * playerScale; // ê¸°ë³¸ í¬ê¸° ì¦ê°€
                    let geometry;
                    if (isCT) {
                        geometry = new THREE.SphereGeometry(baseSize, 16, 16);
                    } else {
                        geometry = new THREE.ConeGeometry(baseSize, baseSize * 2, 3);
                        geometry.rotateX(-Math.PI / 2);
                    }
                    
                    const material = new THREE.MeshPhongMaterial({ 
                        color: color,
                        emissive: isFocusedPlayer ? baseColor : 0x333333,
                        emissiveIntensity: isFocusedPlayer ? 0.4 : 0.1,
                        transparent: opacity < 1.0,
                        opacity: opacity
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);

                    // ë³´ê°„: ë‹¤ìŒ í‹± ë°ì´í„°ê°€ ìˆìœ¼ë©´ ì„ í˜• ë³´ê°„í•˜ì—¬ ë¶€ë“œëŸ½ê²Œ ì´ë™
                    let interpX = posX;
                    let interpY = posY;
                    let interpZ = posZ;
                    if (nextTickData && nextTickData.players && lerpT > 0 && lerpT < 1) {
                        const nextPlayer = nextTickData.players.find(p => 
                            p.name === player.name &&
                            p.position && Array.isArray(p.position) && p.position.length >= 3
                        );
                        if (nextPlayer) {
                            const nPosX = nextPlayer.position[0];
                            const nPosY = nextPlayer.position[1];
                            const nPosZ = nextPlayer.position[2];
                            if (!Number.isNaN(nPosX) && !Number.isNaN(nPosY) && !Number.isNaN(nPosZ)) {
                                interpX = posX + (nPosX - posX) * lerpT;
                                interpY = posY + (nPosY - posY) * lerpT;
                                interpZ = posZ + (nPosZ - posZ) * lerpT;
                            }
                        }
                    }

                    // ì¢Œí‘œ ìŠ¤ì¼€ì¼ë§ ì ìš©: í™”ë©´ í¬ê¸°ì— ë§ê²Œ ì¢Œí‘œ ì¡°ì •
                    const scaledX = (interpX - this.coordinateOffset.x) * this.coordinateScale;
                    const scaledY = (interpY - this.coordinateOffset.y) * this.coordinateScale;
                    const scaledZ = (interpZ - this.coordinateOffset.z) * this.coordinateScale;
                    // ê¸°ì¡´ í”Œë ˆì´ì–´ ì˜¤ë¸Œì íŠ¸ê°€ ìˆìœ¼ë©´ ë¨¼ì € ì œê±° (ì¤‘ë³µ ë°©ì§€)
                    const existingMesh = this.playerObjects.get(player.name);
                    if (existingMesh) {
                        try {
                            if (this.scene.children.includes(existingMesh)) {
                                this.scene.remove(existingMesh);
                            }
                            const index = this.scene.children.indexOf(existingMesh);
                            if (index !== -1) {
                                this.scene.children.splice(index, 1);
                            }
                            if (existingMesh.parent) {
                                existingMesh.parent.remove(existingMesh);
                            }
                            if (existingMesh.geometry) {
                                existingMesh.geometry.dispose();
                            }
                            if (existingMesh.material) {
                                if (Array.isArray(existingMesh.material)) {
                                    existingMesh.material.forEach(mat => mat.dispose());
                                } else {
                                    existingMesh.material.dispose();
                                }
                            }
                        } catch (e) {
                            console.warn('ê¸°ì¡´ í”Œë ˆì´ì–´ ì˜¤ë¸Œì íŠ¸ ì œê±° ì¤‘ ì˜¤ë¥˜:', e);
                        }
                        this.playerObjects.delete(player.name);
                    }
                    
                    // Three.js ì¢Œí‘œê³„: positionì€ [X, Z, Y] í˜•ì‹ì´ë¯€ë¡œ [0], [2], [1] ìˆœì„œë¡œ ì„¤ì •
                    mesh.position.set(scaledX, scaledZ, scaledY);
                    // í”Œë ˆì´ì–´ ë©”ì‹œ ì‹ë³„ì„ ìœ„í•œ userData ì¶”ê°€
                    mesh.userData.isPlayerMesh = true;
                    mesh.userData.playerName = player.name;
                    this.scene.add(mesh);
                    this.playerObjects.set(player.name, mesh);
                    
                    // ë””ë²„ê¹… ì œê±° (ì„±ëŠ¥ ìµœì í™”)

                    // í”Œë ˆì´ì–´ ID / ë¬´ê¸° ë¼ë²¨ (ì—¬ë°± ìµœì†Œ, ì»´íŒ©íŠ¸ ë°•ìŠ¤)
                    const weaponId = (player.weapon !== undefined && player.weapon !== null && !Number.isNaN(player.weapon))
                        ? player.weapon
                        : null;
                    // DEAD ìƒíƒœ í…ìŠ¤íŠ¸ëŠ” ì‹œë®¬ë ˆì´ì…˜ì—ì„œ ì œì™¸
                    const isDeadForLabel = false;
                    
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    // í°íŠ¸ ë° í…ìŠ¤íŠ¸ ì„¤ì •
                    const idFont = 'bold 13px Arial';
                    const weaponFont = '11px Arial';
                    const idText = String(player.name);
                    const weaponText = weaponId !== null ? `W:${weaponId}` : 'W:-';
                    
                    ctx.font = idFont;
                    const idWidth = ctx.measureText(idText).width;
                    ctx.font = weaponFont;
                    const weaponWidth = ctx.measureText(weaponText).width;
                    
                    const paddingX = 6;
                    const paddingY = 3;
                    const lineGap = 2;
                    const boxWidth = Math.ceil(Math.max(idWidth, weaponWidth) + paddingX * 2);
                    const boxHeight = Math.ceil(13 + 11 + lineGap + paddingY * 2);
                    
                    canvas.width = boxWidth;
                    canvas.height = boxHeight;
                    
                    // ë‹¤ì‹œ í°íŠ¸ ì„¤ì •(ìº”ë²„ìŠ¤ ë¦¬ì‚¬ì´ì¦ˆ ì‹œ ì´ˆê¸°í™”ë˜ë¯€ë¡œ)
                    ctx.font = idFont;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    
                    // í¬ì»¤ìŠ¤ ëª¨ë“œì—ì„œ ê´€ë ¨ ì—†ëŠ” í”Œë ˆì´ì–´ ë¼ë²¨ë„ íˆ¬ëª… ì²˜ë¦¬
                    const labelOpacity = (this.focusMode && this.selectedEvent && !isFocusedPlayer) ? 0.3 : 1.0;
                    
                    // ê¹”ë”í•œ ë°˜íˆ¬ëª… ë°•ìŠ¤ ë°°ê²½
                    ctx.fillStyle = `rgba(0, 0, 0, ${0.8 * labelOpacity})`;
                    ctx.fillRect(0, 0, boxWidth, boxHeight);
                    
                    // ì–‡ì€ í…Œë‘ë¦¬
                    const borderColor = isFocusedPlayer ? (isCT ? '#5b9bd5' : '#ff6b6b') : '#666666';
                    ctx.strokeStyle = borderColor;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(0.5, 0.5, boxWidth - 1, boxHeight - 1);
                    
                    // 1ì¤„: ID
                    const textColor = isFocusedPlayer ? '#ffffff' : '#999999';
                    ctx.fillStyle = textColor;
                    const centerX = boxWidth / 2;
                    let textY = paddingY;
                    ctx.fillText(idText, centerX, textY);
                    
                    // 2ì¤„: ë¬´ê¸° (ì•„ë˜ì— ì‘ê²Œ)
                    ctx.font = weaponFont;
                    textY += 13 + lineGap;
                    ctx.fillStyle = isFocusedPlayer ? '#cccccc' : '#777777';
                    ctx.fillText(weaponText, centerX, textY);
                    
                    // ê¸°ì¡´ ë¼ë²¨ì´ ìˆìœ¼ë©´ ë¨¼ì € ì œê±° (ì¤‘ë³µ ë°©ì§€)
                    const existingLabel = this.playerLabels.get(player.name);
                    if (existingLabel) {
                        try {
                            if (this.scene.children.includes(existingLabel)) {
                                this.scene.remove(existingLabel);
                            }
                            const index = this.scene.children.indexOf(existingLabel);
                            if (index !== -1) {
                                this.scene.children.splice(index, 1);
                            }
                            if (existingLabel.parent) {
                                existingLabel.parent.remove(existingLabel);
                            }
                            if (existingLabel.material) {
                                if (existingLabel.material.map) {
                                    existingLabel.material.map.dispose();
                                }
                                existingLabel.material.dispose();
                            }
                        } catch (e) {
                            console.warn('ê¸°ì¡´ ë¼ë²¨ ì œê±° ì¤‘ ì˜¤ë¥˜:', e);
                        }
                        this.playerLabels.delete(player.name);
                    }
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                        map: texture,
                        transparent: true,
                        opacity: labelOpacity,
                        depthTest: false
                    }));
                    // ë¼ë²¨ ì‹ë³„ì„ ìœ„í•œ userData ì¶”ê°€
                    sprite.userData.isPlayerLabel = true;
                    sprite.userData.playerName = player.name;
                    
                    // ì›ë¿” ê³ ì • ë°°ì¹˜: í”Œë ˆì´ì–´ ì •ë³´ ë°•ìŠ¤ë¥¼ í”Œë ˆì´ì–´ í‘œì‹ ë°”ë¡œ ìœ„ì— ê³ ì • ë°°ì¹˜
                    const labelYOffset = 12; // ê³ ì • ì˜¤í”„ì…‹ (í”Œë ˆì´ì–´ í‘œì‹ ë°”ë¡œ ìœ„)
                    
                    // ìŠ¤ì¼€ì¼ëœ ì¢Œí‘œ ê¸°ì¤€ìœ¼ë¡œ ë¼ë²¨ ìœ„ì¹˜ ì„¤ì •
                    sprite.position.set(scaledX, scaledZ + labelYOffset, scaledY);
                    // ìº”ë²„ìŠ¤ ë¹„ìœ¨ì— ë§ì¶˜ ìŠ¤í”„ë¼ì´íŠ¸ í¬ê¸° (ì•„ì£¼ ì‘ê²Œ)
                    const spriteHeight = 10;
                    const spriteWidth = spriteHeight * (boxWidth / boxHeight);
                    sprite.scale.set(spriteWidth, spriteHeight, 1);
                    this.scene.add(sprite);
                    this.playerLabels.set(player.name, sprite);
                    
                    // íŠ¸ë ˆì¼ ì—…ë°ì´íŠ¸ ì œê±° (ì”ìƒ ë¬¸ì œ ë°©ì§€)
                    // this.updateTrail(player.name, player.position, color);
                }

                this.renderEvents(tickData.game_time);
                this.updateEventLog();
                
                // ë¯¸ë‹ˆë§µ ì—…ë°ì´íŠ¸ ë¹„í™œì„±í™” (ë©”ì¸ ë·°ê°€ 2Dì´ë¯€ë¡œ ë¶ˆí•„ìš”)
                // this.updateMinimap();
            }
            
            initMinimap() {
                const minimap = document.getElementById('minimap');
                const minimapCanvas = document.getElementById('minimap-canvas');
                if (!minimap || !minimapCanvas || !this.mapBounds) return;
                
                minimap.style.display = 'block';
                minimapCanvas.width = 250;
                minimapCanvas.height = 250;
                
                // ë¯¸ë‹ˆë§µ í´ë¦­ ì´ë²¤íŠ¸ ì¶”ê°€
                minimapCanvas.addEventListener('click', (e) => {
                    this.handleMinimapClick(e, minimapCanvas);
                });
                
                // ë¯¸ë‹ˆë§µì— ë§ˆìš°ìŠ¤ í˜¸ë²„ ì‹œ ì»¤ì„œ ë³€ê²½
                minimapCanvas.style.cursor = 'pointer';
                
                this.updateMinimap();
            }
            
            handleMinimapClick(e, canvas) {
                if (!this.mapBounds || !this.data) return;
                
                const rect = canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                
                const bounds = this.mapBounds;
                const pathWidth = bounds.pathWidth || bounds.width;
                const pathDepth = bounds.pathDepth || bounds.depth;
                const pathMinX = bounds.pathMinX !== undefined ? bounds.pathMinX : bounds.minX;
                const pathMinZ = bounds.pathMinZ !== undefined ? bounds.pathMinZ : bounds.minZ;
                
                const scaleX = canvas.width / pathWidth;
                const scaleY = canvas.height / pathDepth;
                const scale = Math.min(scaleX, scaleY);
                
                const offsetX = (canvas.width - pathWidth * scale) / 2;
                const offsetY = (canvas.height - pathDepth * scale) / 2;
                
                // í´ë¦­í•œ ìœ„ì¹˜ë¥¼ ì›”ë“œ ì¢Œí‘œë¡œ ë³€í™˜
                const worldX = pathMinX + (clickX - offsetX) / scale;
                const worldZ = pathMinZ + (clickY - offsetY) / scale;
                
                // í´ë¦­í•œ ìœ„ì¹˜ ê·¼ì²˜ì˜ í”Œë ˆì´ì–´ ì°¾ê¸°
                if (this.data.positions && this.currentTick < this.data.positions.length) {
                    const tickData = this.data.positions[this.currentTick];
                    if (tickData && tickData.players) {
                        let closestPlayer = null;
                        let minDistance = Infinity;
                        
                        tickData.players.forEach(player => {
                            if (!player.position || !Array.isArray(player.position)) return;
                            
                            const playerX = player.position[0];
                            const playerZ = player.position[1]; // Three.js Zì¶•
                            const distance = Math.sqrt(
                                Math.pow(playerX - worldX, 2) + 
                                Math.pow(playerZ - worldZ, 2)
                            );
                            
                            // í´ë¦­ ë°˜ê²½ ë‚´ì˜ í”Œë ˆì´ì–´ ì°¾ê¸° (ë¯¸ë‹ˆë§µ ìŠ¤ì¼€ì¼ ê¸°ì¤€)
                            const clickRadius = 50 / scale; // ì•½ 50í”½ì…€ ë°˜ê²½
                            if (distance < clickRadius && distance < minDistance) {
                                minDistance = distance;
                                closestPlayer = player;
                            }
                        });
                        
                        if (closestPlayer) {
                            // ê°€ì¥ ê°€ê¹Œìš´ í”Œë ˆì´ì–´ë¥¼ ì„ íƒí•˜ê³  ì¹´ë©”ë¼ ì´ë™
                            const select = document.getElementById('player-select');
                            if (select) {
                                select.value = closestPlayer.name;
                                this.selectedPlayer = closestPlayer.name;
                            }
                            
                            // ì¹´ë©”ë¼ë¥¼ í•´ë‹¹ í”Œë ˆì´ì–´ ìœ„ì¹˜ë¡œ ì´ë™
                            this.cameraTarget = {
                                x: closestPlayer.position[0],
                                y: closestPlayer.position[2],
                                z: closestPlayer.position[1]
                            };
                            
                            // ì ì ˆí•œ ê±°ë¦¬ ì„¤ì •
                            const mapSize = this.mapBounds ? Math.max(this.mapBounds.width, this.mapBounds.depth) : 1000;
                            this.cameraDistance = Math.max(500, Math.min(5000, mapSize * 0.15));
                            
                            // íŒ¨ë‹ ì˜¤í”„ì…‹ ì´ˆê¸°í™”
                            if (this.panOffset) {
                                this.panOffset.x = 0;
                                this.panOffset.y = 0;
                                this.panOffset.z = 0;
                            }
                            
                            this.updateCamera();
                        } else {
                            // í”Œë ˆì´ì–´ê°€ ì—†ìœ¼ë©´ í´ë¦­í•œ ìœ„ì¹˜ë¡œ ì¹´ë©”ë¼ ì´ë™
                            this.cameraTarget = {
                                x: worldX,
                                y: bounds.centerZ || 0,
                                z: worldZ
                            };
                            
                            const mapSize = this.mapBounds ? Math.max(this.mapBounds.width, this.mapBounds.depth) : 1000;
                            this.cameraDistance = Math.max(500, Math.min(5000, mapSize * 0.15));
                            
                            if (this.panOffset) {
                                this.panOffset.x = 0;
                                this.panOffset.y = 0;
                                this.panOffset.z = 0;
                            }
                            
                            this.updateCamera();
                        }
                    }
                }
            }
            
            updateMinimap() {
                const minimapCanvas = document.getElementById('minimap-canvas');
                if (!minimapCanvas || !this.mapBounds || !this.data) return;
                
                const ctx = minimapCanvas.getContext('2d');
                const bounds = this.mapBounds;
                
                // ì‹¤ì œ í”Œë ˆì´ì–´ ê²½ë¡œ ê²½ê³„ ì‚¬ìš© (ì „ì²´ ë§µì´ ì•„ë‹Œ)
                const pathWidth = bounds.pathWidth || bounds.width;
                const pathDepth = bounds.pathDepth || bounds.depth;
                const pathMinX = bounds.pathMinX !== undefined ? bounds.pathMinX : bounds.minX;
                const pathMinZ = bounds.pathMinZ !== undefined ? bounds.pathMinZ : bounds.minZ;
                const pathMaxX = bounds.pathMaxX !== undefined ? bounds.pathMaxX : bounds.maxX;
                const pathMaxZ = bounds.pathMaxZ !== undefined ? bounds.pathMaxZ : bounds.maxZ;
                
                const scaleX = minimapCanvas.width / pathWidth;
                const scaleY = minimapCanvas.height / pathDepth;
                const scale = Math.min(scaleX, scaleY);
                
                // ë°°ê²½
                ctx.fillStyle = '#1a1f2e';
                ctx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);
                
                // ì‹¤ì œ í”Œë ˆì´ì–´ ê²½ë¡œ ê²½ê³„ ë°•ìŠ¤ í‘œì‹œ
                ctx.strokeStyle = '#4a90e2';
                ctx.lineWidth = 2;
                const offsetX = (minimapCanvas.width - pathWidth * scale) / 2;
                const offsetY = (minimapCanvas.height - pathDepth * scale) / 2;
                ctx.strokeRect(
                    offsetX,
                    offsetY,
                    pathWidth * scale,
                    pathDepth * scale
                );
                
                // í”Œë ˆì´ì–´ ê²½ë¡œë¥¼ ë¯¸ë‹ˆë§µì— ê·¸ë¦¬ê¸° (ì „ì²´ ê²½ë¡œ - ë” ëª…í™•í•˜ê²Œ)
                if (this.playerPathLines && this.playerPathLines.size > 0) {
                    this.playerPathLines.forEach((line, playerName) => {
                        const geometry = line.geometry;
                        if (!geometry || !geometry.attributes || !geometry.attributes.position) return;
                        
                        const positions = geometry.attributes.position.array;
                        const isCT = !playerName.startsWith('-');
                        
                        // ê²½ë¡œë¥¼ ë” ëª…í™•í•˜ê²Œ í‘œì‹œ (íˆ¬ëª…ë„ ì¦ê°€ ë° ì„  ë‘ê»˜ ì¦ê°€)
                        ctx.strokeStyle = isCT ? 'rgba(91, 155, 213, 0.6)' : 'rgba(255, 107, 107, 0.6)'; // 0.3 -> 0.6ë¡œ ì¦ê°€
                        ctx.lineWidth = 2; // 1 -> 2ë¡œ ì¦ê°€
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.beginPath();
                        
                        let firstPoint = true;
                        for (let i = 0; i < positions.length; i += 3) {
                            const x = offsetX + (positions[i] - pathMinX) * scale;
                            const y = offsetY + (positions[i + 2] - pathMinZ) * scale; // Three.jsëŠ” [X, Z, Y] ìˆœì„œ
                            
                            if (firstPoint) {
                                ctx.moveTo(x, y);
                                firstPoint = false;
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.stroke();
                    });
                }
                
                // í˜„ì¬ í‹±ê¹Œì§€ì˜ í”Œë ˆì´ì–´ ê²½ë¡œë¥¼ ì‹œê°„ìˆœìœ¼ë¡œ í‘œì‹œ (ê³¼ê±° ê²½ë¡œëŠ” ë” íˆ¬ëª…í•˜ê²Œ)
                // ì„±ëŠ¥ ìµœì í™”: ëª¨ë“  í‹±ì„ ë Œë”ë§í•˜ì§€ ì•Šê³  ìƒ˜í”Œë§
                if (this.data && this.data.positions && this.currentTick > 0) {
                    const sampleInterval = Math.max(1, Math.floor(this.currentTick / 200)); // ìµœëŒ€ 200ê°œ í¬ì¸íŠ¸ë§Œ í‘œì‹œ
                    
                    // ê° í‹±ë³„ë¡œ í”Œë ˆì´ì–´ ê²½ë¡œë¥¼ ì‹œê°„ì— ë”°ë¼ ê·¸ë¦¬ê¸° (ìƒ˜í”Œë§)
                    for (let tickIdx = 0; tickIdx <= this.currentTick; tickIdx += sampleInterval) {
                        if (tickIdx >= this.data.positions.length) break;
                        
                        const tickData = this.data.positions[tickIdx];
                        if (!tickData || !tickData.players) continue;
                        
                        // ì‹œê°„ì— ë”°ë¥¸ íˆ¬ëª…ë„ ê³„ì‚° (ìµœê·¼ í‹±ì¼ìˆ˜ë¡ ë” ì§„í•˜ê²Œ)
                        const timeRatio = tickIdx / Math.max(1, this.currentTick);
                        const alpha = 0.15 + (timeRatio * 0.35); // 0.15 ~ 0.5 ë²”ìœ„
                        
                        tickData.players.forEach(player => {
                            if (!player.position || !Array.isArray(player.position)) return;
                            
                            const isCT = !player.name.startsWith('-');
                            const x = offsetX + (player.position[0] - pathMinX) * scale;
                            const y = offsetY + (player.position[2] - pathMinZ) * scale;
                            
                            // ê³¼ê±° ìœ„ì¹˜ë¥¼ ì‘ì€ ì ìœ¼ë¡œ í‘œì‹œ
                            ctx.fillStyle = isCT ? `rgba(91, 155, 213, ${alpha})` : `rgba(255, 107, 107, ${alpha})`;
                            ctx.beginPath();
                            ctx.arc(x, y, 1.5, 0, Math.PI * 2);
                            ctx.fill();
                        });
                    }
                }
                
                // í˜„ì¬ í‹±ì˜ í”Œë ˆì´ì–´ í‘œì‹œ (í° ì ìœ¼ë¡œ)
                if (this.data && this.data.positions && this.currentTick < this.data.positions.length) {
                    const tickData = this.data.positions[this.currentTick];
                    if (tickData && tickData.players) {
                        tickData.players.forEach(player => {
                            if (!player.position || !Array.isArray(player.position)) return;
                            
                            const x = offsetX + (player.position[0] - pathMinX) * scale;
                            const y = offsetY + (player.position[2] - pathMinZ) * scale;
                            
                            // í”Œë ˆì´ì–´ ìœ„ì¹˜ë¥¼ ë” í¬ê³  ëª…í™•í•˜ê²Œ í‘œì‹œ
                            const isCT = !player.name.startsWith('-');
                            
                            // ì™¸ê³½ì„  ë¨¼ì € ê·¸ë¦¬ê¸° (ë” í¬ê²Œ)
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(x, y, 6, 0, Math.PI * 2);
                            ctx.stroke();
                            
                            // í”Œë ˆì´ì–´ ì  ê·¸ë¦¬ê¸°
                            ctx.fillStyle = isCT ? '#5b9bd5' : '#ff6b6b';
                            ctx.beginPath();
                            ctx.arc(x, y, 5, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // ë‚´ë¶€ í•˜ì´ë¼ì´íŠ¸
                            ctx.fillStyle = '#ffffff';
                            ctx.beginPath();
                            ctx.arc(x, y, 2, 0, Math.PI * 2);
                            ctx.fill();
                        });
                    }
                }
                
                // ì¹´ë©”ë¼ ì‹œì•¼ í‘œì‹œ (ê°„ë‹¨í•œ ì›) - ì‹¤ì œ ê²½ë¡œ ì¤‘ì‹¬ ì‚¬ìš©
                if (this.mapBounds) {
                    const pathCenterX = bounds.pathCenterX !== undefined ? bounds.pathCenterX : bounds.centerX;
                    const pathCenterZ = bounds.pathCenterZ !== undefined ? bounds.pathCenterZ : bounds.centerZ;
                    const centerX = offsetX + (pathCenterX - pathMinX) * scale;
                    const centerY = offsetY + (pathCenterZ - pathMinZ) * scale;
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 20, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            fitToView() {
                if (!this.data || !this.data.positions || !this.mapBounds) return;
                
                // ì‹¤ì œ í”Œë ˆì´ì–´ ê²½ë¡œ ê²½ê³„ ì‚¬ìš© (ì „ì²´ ë§µì´ ì•„ë‹Œ)
                const bounds = this.mapBounds;
                if (bounds.pathWidth && bounds.pathDepth && bounds.pathHeight) {
                    // ì‹¤ì œ ê²½ë¡œ ê²½ê³„ê°€ ìˆìœ¼ë©´ ê·¸ê²ƒì„ ì‚¬ìš©
                    const pathCenterX = bounds.pathCenterX;
                    const pathCenterY = bounds.pathCenterY;
                    const pathCenterZ = bounds.pathCenterZ;
                    const pathWidth = bounds.pathWidth;
                    const pathHeight = bounds.pathHeight;
                    const pathDepth = bounds.pathDepth;
                    const maxDim = Math.max(pathWidth, pathHeight, pathDepth);
                    
                    // ì¹´ë©”ë¼ë¥¼ ê²½ë¡œ ì¤‘ì‹¬ìœ¼ë¡œ ì„¤ì •
                    this.cameraTarget = { x: pathCenterX, y: pathCenterZ, z: pathCenterY };
                    // ê²½ë¡œ ì˜ì—­ì„ ë”± ë§ê²Œ ë³´ì´ë„ë¡ ì¹´ë©”ë¼ ê±°ë¦¬ ê³„ì‚°
                    // Three.js ì¹´ë©”ë¼ì˜ ì‹œì•¼ê°ì„ ê³ ë ¤í•˜ì—¬ ê±°ë¦¬ ê³„ì‚°
                    const fov = this.camera.fov * (Math.PI / 180);
                    const aspect = this.camera.aspect;
                    const container = document.getElementById('canvas-container');
                    const viewHeight = container ? container.clientHeight : 600;
                    const viewWidth = container ? container.clientWidth : 800;
                    
                    // ê²½ë¡œ ì˜ì—­ì´ í™”ë©´ì— ë”± ë§ë„ë¡ ê±°ë¦¬ ê³„ì‚°
                    const distanceX = (pathWidth / 2) / Math.tan(fov / 2) / aspect;
                    const distanceZ = (pathDepth / 2) / Math.tan(fov / 2);
                    const distanceY = (pathHeight / 2) / Math.tan(fov / 2);
                    this.cameraDistance = Math.max(distanceX, distanceZ, distanceY) * 1.1; // 10% ì—¬ìœ  ê³µê°„
                } else {
                    // ê²½ë¡œ ê²½ê³„ê°€ ì—†ìœ¼ë©´ í˜„ì¬ í‹±ì˜ í”Œë ˆì´ì–´ ìœ„ì¹˜ ì‚¬ìš©
                    const tickData = this.data.positions[this.currentTick];
                    if (!tickData || !tickData.players || tickData.players.length === 0) {
                        const maxDim = Math.max(bounds.width, bounds.depth, bounds.height);
                        this.cameraDistance = maxDim * 1.5;
                        this.cameraTarget = null;
                    } else {
                        let minX = Infinity, maxX = -Infinity;
                        let minY = Infinity, maxY = -Infinity;
                        let minZ = Infinity, maxZ = -Infinity;
                        
                        tickData.players.forEach(player => {
                            if (!player.position || !Array.isArray(player.position)) return;
                            const x = player.position[0];
                            const y = player.position[1];
                            const z = player.position[2];
                            if (!Number.isNaN(x)) { minX = Math.min(minX, x); maxX = Math.max(maxX, x); }
                            if (!Number.isNaN(y)) { minY = Math.min(minY, y); maxY = Math.max(maxY, y); }
                            if (!Number.isNaN(z)) { minZ = Math.min(minZ, z); maxZ = Math.max(maxZ, z); }
                        });
                        
                        if (minX !== Infinity) {
                            const centerX = (minX + maxX) / 2;
                            const centerY = (minY + maxY) / 2;
                            const centerZ = (minZ + maxZ) / 2;
                            const width = maxX - minX;
                            const height = maxY - minY;
                            const depth = maxZ - minZ;
                            const maxDim = Math.max(width, height, depth);
                            
                            this.cameraTarget = { x: centerX, y: centerZ, z: centerY };
                            this.cameraDistance = maxDim * 1.5;
                        } else {
                            this.cameraTarget = null;
                            this.cameraDistance = bounds.width * 1.5;
                        }
                    }
                }
                this.cameraRotationX = 0.4;
                this.cameraRotationY = Math.PI / 4;
                
                // íŒ¨ë‹ ì˜¤í”„ì…‹ ì´ˆê¸°í™”
                if (this.panOffset) {
                    this.panOffset.x = 0;
                    this.panOffset.y = 0;
                    this.panOffset.z = 0;
                }
                
                this.updateCamera();
                
                // ë¡œê·¸ ì¶œë ¥ (ë³€ìˆ˜ ìŠ¤ì½”í”„ í™•ì¸)
                if (bounds.pathWidth && bounds.pathDepth && bounds.pathHeight) {
                    console.log('Fit to View ì™„ë£Œ (ê²½ë¡œ ê²½ê³„ ì‚¬ìš©):', {
                        center: { x: bounds.pathCenterX, y: bounds.pathCenterZ, z: bounds.pathCenterY },
                        size: { width: bounds.pathWidth, height: bounds.pathHeight, depth: bounds.pathDepth },
                        cameraDistance: this.cameraDistance
                    });
                } else {
                    const tickData = this.data.positions[this.currentTick];
                    if (tickData && tickData.players && tickData.players.length > 0) {
                        let minX = Infinity, maxX = -Infinity;
                        let minY = Infinity, maxY = -Infinity;
                        let minZ = Infinity, maxZ = -Infinity;
                        tickData.players.forEach(player => {
                            if (!player.position || !Array.isArray(player.position)) return;
                            const x = player.position[0];
                            const y = player.position[1];
                            const z = player.position[2];
                            if (!Number.isNaN(x)) { minX = Math.min(minX, x); maxX = Math.max(maxX, x); }
                            if (!Number.isNaN(y)) { minY = Math.min(minY, y); maxY = Math.max(maxY, y); }
                            if (!Number.isNaN(z)) { minZ = Math.min(minZ, z); maxZ = Math.max(maxZ, z); }
                        });
                        if (minX !== Infinity) {
                            console.log('Fit to View ì™„ë£Œ (í˜„ì¬ í‹± í”Œë ˆì´ì–´ ì‚¬ìš©):', {
                                center: { x: (minX + maxX) / 2, y: (minZ + maxZ) / 2, z: (minY + maxY) / 2 },
                                size: { width: maxX - minX, height: maxY - minY, depth: maxZ - minZ },
                                cameraDistance: this.cameraDistance
                            });
                        }
                    } else {
                        console.log('Fit to View ì™„ë£Œ (ë§µ ì¤‘ì‹¬ ì‚¬ìš©):', {
                            center: { x: bounds.centerX, y: bounds.centerZ, z: bounds.centerY },
                            size: { width: bounds.width, height: bounds.height, depth: bounds.depth },
                            cameraDistance: this.cameraDistance
                        });
                    }
                }
            }

            calculateFullMapBoundsAndScale() {
                // ëª¨ë“  í‹±ì˜ ëª¨ë“  í”Œë ˆì´ì–´ ìœ„ì¹˜ë¥¼ ì‚¬ìš©í•´ ì „ì²´ ë§µ ë²”ìœ„ë¥¼ ê³„ì‚°í•˜ê³  ìŠ¤ì¼€ì¼/ì˜¤í”„ì…‹ì„ ì„¤ì •
                if (!this.data || !this.data.positions || this.data.positions.length === 0) {
                    console.warn('calculateFullMapBoundsAndScale: ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤');
                    return;
                }

                let fullMinX = Infinity, fullMaxX = -Infinity;
                let fullMinY = Infinity, fullMaxY = -Infinity;
                let fullMinZ = Infinity, fullMaxZ = -Infinity;

                for (let i = 0; i < this.data.positions.length; i++) {
                    const tickData = this.data.positions[i];
                    if (!tickData || !tickData.players) continue;

                    for (let j = 0; j < tickData.players.length; j++) {
                        const p = tickData.players[j];
                        if (!p.position || !Array.isArray(p.position) || p.position.length < 3) continue;
                        const x = p.position[0];
                        const y = p.position[1];
                        const z = p.position[2];
                        if (!Number.isNaN(x)) { fullMinX = Math.min(fullMinX, x); fullMaxX = Math.max(fullMaxX, x); }
                        if (!Number.isNaN(y)) { fullMinY = Math.min(fullMinY, y); fullMaxY = Math.max(fullMaxY, y); }
                        if (!Number.isNaN(z)) { fullMinZ = Math.min(fullMinZ, z); fullMaxZ = Math.max(fullMaxZ, z); }
                    }
                }

                if (fullMinX === Infinity) {
                    console.warn('calculateFullMapBoundsAndScale: í”Œë ˆì´ì–´ ì¢Œí‘œê°€ ì—†ìŠµë‹ˆë‹¤');
                    return;
                }

                const fullWidth = fullMaxX - fullMinX;
                const fullHeight = fullMaxY - fullMinY;
                const fullDepth = fullMaxZ - fullMinZ;
                const fullRange = Math.max(fullWidth, fullHeight, fullDepth);

                const container = document.getElementById('canvas-container');
                const screenWidth = container ? container.clientWidth : 800;
                const screenHeight = container ? container.clientHeight : 600;
                const screenMinDim = Math.min(screenWidth, screenHeight);
                const targetScreenSize = screenMinDim * 0.8;
                this.coordinateScale = targetScreenSize / Math.max(fullRange, 1);

                const centerX = (fullMinX + fullMaxX) / 2;
                const centerY = (fullMinY + fullMaxY) / 2;
                const centerZ = (fullMinZ + fullMaxZ) / 2;
                this.coordinateOffset = { x: centerX, y: centerY, z: centerZ };
                this.cameraTarget = { x: 0, y: 0, z: 0 };
                this.defaultTarget = { x: 0, y: 0, z: 0 };

                if (this.mapBounds) {
                    this.mapBounds.fullPathMinX = fullMinX;
                    this.mapBounds.fullPathMaxX = fullMaxX;
                    this.mapBounds.fullPathMinY = fullMinY;
                    this.mapBounds.fullPathMaxY = fullMaxY;
                    this.mapBounds.fullPathMinZ = fullMinZ;
                    this.mapBounds.fullPathMaxZ = fullMaxZ;
                    this.mapBounds.fullPathCenterX = centerX;
                    this.mapBounds.fullPathCenterY = centerY;
                    this.mapBounds.fullPathCenterZ = centerZ;
                    this.mapBounds.fullPathWidth = fullWidth;
                    this.mapBounds.fullPathHeight = fullHeight;
                    this.mapBounds.fullPathDepth = fullDepth;
                }

                console.log('ì „ì²´ í”Œë ˆì´ì–´ ê²½ë¡œ ë²”ìœ„ ê³„ì‚° ì™„ë£Œ:', {
                    X: [fullMinX.toFixed(2), fullMaxX.toFixed(2), fullWidth.toFixed(2)],
                    Y: [fullMinY.toFixed(2), fullMaxY.toFixed(2), fullHeight.toFixed(2)],
                    Z: [fullMinZ.toFixed(2), fullMaxZ.toFixed(2), fullDepth.toFixed(2)],
                    fullRange: fullRange.toFixed(2),
                    screenSize: `${screenWidth}x${screenHeight}`,
                    scaleFactor: this.coordinateScale.toFixed(6),
                    offset: this.coordinateOffset
                });
            }

            renderAllPlayerPaths() {
                // ê¸°ì¡´ ê²½ë¡œ ë¼ì¸ ì œê±°
                if (this.playerPathLines) {
                    this.playerPathLines.forEach(line => this.scene.remove(line));
                    this.playerPathLines.clear();
                } else {
                    this.playerPathLines = new Map();
                }
                
                if (!this.data || !this.data.positions) {
                    console.warn('renderAllPlayerPaths: ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤');
                    return;
                }
                
                console.log('=== ëª¨ë“  í”Œë ˆì´ì–´ ê²½ë¡œ ë Œë”ë§ ì‹œì‘ ===');
                
                // ê° í”Œë ˆì´ì–´ë³„ë¡œ ê²½ë¡œ ìˆ˜ì§‘
                const playerPaths = new Map();
                
                for (let i = 0; i < this.data.positions.length; i++) {
                    const tickData = this.data.positions[i];
                    if (!tickData || !tickData.players) continue;
                    
                    for (let j = 0; j < tickData.players.length; j++) {
                        const player = tickData.players[j];
                        if (!player.position || !Array.isArray(player.position) || player.position.length < 3) continue;
                        
                        if (!playerPaths.has(player.name)) {
                            playerPaths.set(player.name, []);
                        }
                        
                        const posX = player.position[0];
                        const posY = player.position[1];
                        const posZ = player.position[2];
                        
                        if (!Number.isNaN(posX) && !Number.isNaN(posY) && !Number.isNaN(posZ)) {
                            // ì¢Œí‘œ ìŠ¤ì¼€ì¼ë§ ì ìš©
                            const scaledX = (posX - this.coordinateOffset.x) * this.coordinateScale;
                            const scaledY = (posY - this.coordinateOffset.y) * this.coordinateScale;
                            const scaledZ = (posZ - this.coordinateOffset.z) * this.coordinateScale;
                            // Three.js ì¢Œí‘œê³„: [X, Z, Y]
                            playerPaths.get(player.name).push(new THREE.Vector3(scaledX, scaledZ, scaledY));
                        }
                    }
                }
                
                console.log('ê²½ë¡œ ìˆ˜ì§‘ ì™„ë£Œ:', playerPaths.size, 'ëª…ì˜ í”Œë ˆì´ì–´');
                
                // ì‹¤ì œ í”Œë ˆì´ì–´ ê²½ë¡œì˜ ê²½ê³„ ê³„ì‚° (ëª¨ë“  ê²½ë¡œ í¬ì¸íŠ¸ë¥¼ ê¸°ë°˜ìœ¼ë¡œ)
                let pathMinX = Infinity, pathMaxX = -Infinity;
                let pathMinY = Infinity, pathMaxY = -Infinity;
                let pathMinZ = Infinity, pathMaxZ = -Infinity;
                
                playerPaths.forEach((points, playerName) => {
                    points.forEach(point => {
                        if (!Number.isNaN(point.x)) {
                            pathMinX = Math.min(pathMinX, point.x);
                            pathMaxX = Math.max(pathMaxX, point.x);
                        }
                        if (!Number.isNaN(point.y)) {
                            pathMinY = Math.min(pathMinY, point.y);
                            pathMaxY = Math.max(pathMaxY, point.y);
                        }
                        if (!Number.isNaN(point.z)) {
                            pathMinZ = Math.min(pathMinZ, point.z);
                            pathMaxZ = Math.max(pathMaxZ, point.z);
                        }
                    });
                });
                
                // ê²½ë¡œ ê²½ê³„ë¥¼ mapBoundsì— ì—…ë°ì´íŠ¸ (ì‹¤ì œ ì´ë™ ì˜ì—­)
                if (pathMinX !== Infinity && this.mapBounds) {
                    this.mapBounds.pathMinX = pathMinX;
                    this.mapBounds.pathMaxX = pathMaxX;
                    this.mapBounds.pathMinY = pathMinY;
                    this.mapBounds.pathMaxY = pathMaxY;
                    this.mapBounds.pathMinZ = pathMinZ;
                    this.mapBounds.pathMaxZ = pathMaxZ;
                    this.mapBounds.pathCenterX = (pathMinX + pathMaxX) / 2;
                    this.mapBounds.pathCenterY = (pathMinY + pathMaxY) / 2;
                    this.mapBounds.pathCenterZ = (pathMinZ + pathMaxZ) / 2;
                    this.mapBounds.pathWidth = pathMaxX - pathMinX;
                    this.mapBounds.pathHeight = pathMaxY - pathMinY;
                    this.mapBounds.pathDepth = pathMaxZ - pathMinZ;
                    
                    console.log('ì‹¤ì œ í”Œë ˆì´ì–´ ê²½ë¡œ ê²½ê³„:', {
                        X: [pathMinX.toFixed(1), pathMaxX.toFixed(1), (pathMaxX - pathMinX).toFixed(1)],
                        Y: [pathMinY.toFixed(1), pathMaxY.toFixed(1), (pathMaxY - pathMinY).toFixed(1)],
                        Z: [pathMinZ.toFixed(1), pathMaxZ.toFixed(1), (pathMaxZ - pathMinZ).toFixed(1)]
                    });
                }
                
                // ê° í”Œë ˆì´ì–´ì˜ ê²½ë¡œë¥¼ ë¼ì¸ìœ¼ë¡œ ë Œë”ë§
                let pathCount = 0;
                playerPaths.forEach((points, playerName) => {
                    if (points.length < 2) return;
                    
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    // ëª¨ë“  í”Œë ˆì´ì–´ ê²½ë¡œë¥¼ í°ìƒ‰ ì‹¤ì„ ìœ¼ë¡œ í†µì¼
                    const material = new THREE.LineBasicMaterial({ 
                        color: 0xffffff, // í°ìƒ‰
                        opacity: 0.8,
                        transparent: true,
                        linewidth: 1.5
                    });
                    const line = new THREE.Line(geometry, material);
                    this.scene.add(line);
                    this.playerPathLines.set(playerName, line);
                    pathCount++;
                    
                    // ì²« ë²ˆì§¸ í”Œë ˆì´ì–´ì˜ ê²½ë¡œ ì •ë³´ ì¶œë ¥
                    if (pathCount === 1) {
                        console.log(`ì²« ë²ˆì§¸ í”Œë ˆì´ì–´ (${playerName}) ê²½ë¡œ:`, {
                            points_count: points.length,
                            first_point: { x: points[0].x, y: points[0].y, z: points[0].z },
                            last_point: { x: points[points.length - 1].x, y: points[points.length - 1].y, z: points[points.length - 1].z }
                        });
                    }
                });
                
                console.log('ê²½ë¡œ ë Œë”ë§ ì™„ë£Œ:', pathCount, 'ê°œ ê²½ë¡œ');
            }

            updateTrail(playerName, position, color) {
                if (!this.playerTrails.has(playerName)) {
                    const trailGeometry = new THREE.BufferGeometry();
                    const trailMaterial = new THREE.LineBasicMaterial({ 
                        color: color,
                        opacity: 0.4,
                        transparent: true,
                        linewidth: 2
                    });
                    const trail = new THREE.Line(trailGeometry, trailMaterial);
                    this.scene.add(trail);
                    this.playerTrails.set(playerName, {
                        line: trail,
                        points: []
                    });
                }

                const trail = this.playerTrails.get(playerName);
                trail.points.push(new THREE.Vector3(position[0], position[2], position[1]));
                
                if (trail.points.length > 100) {
                    trail.points.shift();
                }

                trail.line.geometry.setFromPoints(trail.points);
            }

            renderEvents(gameTime) {
                this.eventMarkers.forEach(m => this.scene.remove(m));
                this.eventMarkers = [];

                if (!this.data || !this.data.events) return;
                if (gameTime === null || gameTime === undefined) return;

                this.data.events.forEach(event => {
                    // ë””ë²„ê¹…: 60587 í”Œë ˆì´ì–´ ì´ë²¤íŠ¸ë§Œ ë¡œê·¸
                    if (event.attacker?.name === '60587' || event.victim?.name === '60587') {
                        console.log('=== renderEvents ë””ë²„ê¹… (60587) ===', {
                            event_tick: event.tick,
                            event_game_time: event.game_time,
                            gameTime: gameTime,
                            attacker: {
                                name: event.attacker?.name,
                                position: event.attacker?.position
                            },
                            victim: {
                                name: event.victim?.name,
                                position: event.victim?.position
                            },
                            focusMode: this.focusMode,
                            selectedEvent_tick: this.selectedEvent?.tick,
                            selectedEvent_game_time: this.selectedEvent?.game_time
                        });
                    }
                    
                    // victimì˜ positionì´ nullì´ë©´ í•´ë‹¹ í‹±ì˜ playersì—ì„œ ì°¾ì•„ì„œ ë³´ì™„
                    if (event.victim && event.victim.name && (!event.victim.position || event.victim.position[0] === null)) {
                        const tickIndex = this.findTickByTime(event.game_time);
                        if (tickIndex !== -1) {
                            const tickData = this.data.positions[tickIndex];
                            if (tickData && tickData.players) {
                                const victimInTick = tickData.players.find(p => p.name === event.victim.name);
                                if (victimInTick && victimInTick.position) {
                                    console.log('Victim position ë³´ì™„:', {
                                        victim_name: event.victim.name,
                                        original_position: event.victim.position,
                                        found_position: victimInTick.position
                                    });
                                    event.victim.position = victimInTick.position;
                                    // team ì •ë³´ë„ ë³´ì™„
                                    if (!event.victim.team && victimInTick.team) {
                                        event.victim.team = victimInTick.team;
                                    }
                                }
                            }
                        }
                    }
                    
                    // attackerì˜ positionì´ nullì´ë©´ í•´ë‹¹ í‹±ì˜ playersì—ì„œ ì°¾ì•„ì„œ ë³´ì™„
                    if (event.attacker && event.attacker.name && (!event.attacker.position || event.attacker.position[0] === null)) {
                        const tickIndex = this.findTickByTime(event.game_time);
                        if (tickIndex !== -1) {
                            const tickData = this.data.positions[tickIndex];
                            if (tickData && tickData.players) {
                                const attackerInTick = tickData.players.find(p => p.name === event.attacker.name);
                                if (attackerInTick && attackerInTick.position) {
                                    console.log('Attacker position ë³´ì™„:', {
                                        attacker_name: event.attacker.name,
                                        original_position: event.attacker.position,
                                        found_position: attackerInTick.position
                                    });
                                    event.attacker.position = attackerInTick.position;
                                    // team ì •ë³´ë„ ë³´ì™„
                                    if (!event.attacker.team && attackerInTick.team) {
                                        event.attacker.team = attackerInTick.team;
                                    }
                                }
                            }
                        }
                    }
                    let timeDiff = Math.abs(event.game_time - gameTime);
                    // ì •í™•íˆ í•´ë‹¹ í‹±ì—ë§Œ í‘œì‹œ (0.05ì´ˆ ì´ë‚´, ì•½ 3í‹±)
                    // í¬ì»¤ìŠ¤ ëª¨ë“œì¼ ë•ŒëŠ” ì„ íƒëœ ì´ë²¤íŠ¸ë§Œ í‘œì‹œ
                    let timeMatch = false;
                    if (this.focusMode && this.selectedEvent) {
                        // í¬ì»¤ìŠ¤ ëª¨ë“œ: ì„ íƒëœ ì´ë²¤íŠ¸ì™€ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” ê²½ìš°ë§Œ í‘œì‹œ
                        // game_timeì„ ìš°ì„ ì ìœ¼ë¡œ í™•ì¸í•˜ê³ , tickë„ í™•ì¸ (tickì´ ì—†ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ)
                        timeMatch = Math.abs(event.game_time - this.selectedEvent.game_time) < 0.01;
                        const tickMatch = (this.selectedEvent.tick === undefined || event.tick === undefined) 
                            ? true  // tick ì •ë³´ê°€ ì—†ìœ¼ë©´ timeMatchë§Œ í™•ì¸
                            : (event.tick === this.selectedEvent.tick);
                        
                        // game_timeì´ ì¼ì¹˜í•˜ë©´ í‘œì‹œ (tickì€ ë³´ì¡° í™•ì¸)
                        if (!timeMatch) {
                            return; // ì„ íƒëœ ì´ë²¤íŠ¸ê°€ ì•„ë‹ˆë©´ ìŠ¤í‚µ
                        }
                        // timeMatchê°€ trueì´ë©´ tickMatchì™€ ê´€ê³„ì—†ì´ í‘œì‹œ (tick ì •ë³´ê°€ ë¶€ì •í™•í•  ìˆ˜ ìˆìŒ)
                        // í¬ì»¤ìŠ¤ ëª¨ë“œì—ì„œ ì„ íƒëœ ì´ë²¤íŠ¸ëŠ” timeDiff ì¡°ê±´ ë¬´ì‹œí•˜ê³  í‘œì‹œ
                        timeDiff = 0; // ê°•ì œë¡œ ì¡°ê±´ í†µê³¼
                    }
                    
                    // kill/hit ì´ë²¤íŠ¸ í‘œì‹œ
                    const isKillEvent = (event.event_type_lower || '').includes('kill') || (event.event_type_lower || '').includes('died');
                    const isHitEvent = (event.event_type_lower || '').includes('hit');
                    const isEventToShow = isKillEvent || isHitEvent;
                    
                    // í¬ì»¤ìŠ¤ ëª¨ë“œì¼ ë•ŒëŠ” timeDiff ì¡°ê±´ì„ ì™„í™” (ì„ íƒëœ ì´ë²¤íŠ¸ëŠ” í™•ì‹¤íˆ í‘œì‹œ)
                    // í¬ì»¤ìŠ¤ ëª¨ë“œì—ì„œ ì„ íƒëœ ì´ë²¤íŠ¸ëŠ” timeDiff ì¡°ê±´ ì™„ì „íˆ ë¬´ì‹œ
                    const shouldShow = (this.focusMode && this.selectedEvent && timeMatch) 
                        ? true  // í¬ì»¤ìŠ¤ ëª¨ë“œì—ì„œ ì„ íƒëœ ì´ë²¤íŠ¸ëŠ” ë¬´ì¡°ê±´ í‘œì‹œ
                        : (timeDiff < 0.05);  // ì¼ë°˜ ëª¨ë“œëŠ” ê¸°ì¡´ ì¡°ê±´ ìœ ì§€
                    
                    // kill/hit ì´ë²¤íŠ¸ë§Œ í‘œì‹œ
                    if (!isEventToShow) return;
                    
                    if (shouldShow && event.attacker && event.attacker.position && event.attacker.position[0] !== null) {
                        // ìŠ¤ì¼€ì¼ë§ëœ ì¢Œí‘œ ì‚¬ìš©
                        const attackerScaledX = (event.attacker.position[0] - this.coordinateOffset.x) * this.coordinateScale;
                        const attackerScaledY = (event.attacker.position[1] - this.coordinateOffset.y) * this.coordinateScale;
                        const attackerScaledZ = (event.attacker.position[2] - this.coordinateOffset.z) * this.coordinateScale;
                        
                        // kill/hit ì´ë²¤íŠ¸ì¼ ë•Œ ê³µê²©ì í”Œë ˆì´ì–´ë¥¼ ì› í…Œë‘ë¦¬ë¡œ ê°ì‹¸ê¸°
                        // í”Œë ˆì´ì–´ í¬ê¸°ì— ë§ì¶° ë§ ë°˜ì§€ë¦„ ë™ì ìœ¼ë¡œ ì¡°ì •
                        if (isKillEvent || isHitEvent) {
                        const mapSizeForRing = this.mapBounds ? Math.max(this.mapBounds.width, this.mapBounds.depth, this.mapBounds.height) : 1000;
                        const normalizedMapSizeForRing = this.mapBounds?.normalizedWidth || mapSizeForRing;
                        const playerScaleForRing = Math.max(0.25, Math.min(0.6, normalizedMapSizeForRing / 5000));
                        const baseSizeForRing = 5 * playerScaleForRing;
                        const innerRadius = baseSizeForRing * 2.0;
                        const outerRadius = baseSizeForRing * 2.4;

                        // ê³µê²©ì: ë¹¨ê°„ ë§ (attacker ë°•ìŠ¤ ìƒ‰ìƒê³¼ ë™ì¼: rgba(255, 77, 79))
                        const attackerRing = new THREE.Mesh(
                            new THREE.RingGeometry(innerRadius, outerRadius, 32),
                            new THREE.MeshPhongMaterial({ 
                                color: 0xff4d4f, // rgba(255, 77, 79) = 0xff4d4f
                                emissive: 0xff4d4f,
                                emissiveIntensity: 0.7,
                            side: THREE.DoubleSide
                            })
                        );
                        attackerRing.position.set(
                            attackerScaledX,
                            attackerScaledZ, // Three.js Yì¶•
                            attackerScaledY  // Three.js Zì¶•
                        );
                        attackerRing.rotation.x = -Math.PI / 2;
                        this.scene.add(attackerRing);
                        this.eventMarkers.push(attackerRing);
                        }

                        // Attacker ë¼ë²¨ì€ victimì´ ìˆì„ ë•Œë§Œ ìƒì„± (ìˆ˜í‰ ë°°ì¹˜ë¥¼ ìœ„í•´)
                        // ì•„ë˜ victim ë¸”ë¡ì—ì„œ ì²˜ë¦¬

                        // kill/hit ì´ë²¤íŠ¸ì´ê³  victimì´ ìˆì„ ë•Œë§Œ ì—°ê²°ì„ ê³¼ dead/hit ë°•ìŠ¤ í‘œì‹œ
                        console.log('Event check:', {
                            isKillEvent: isKillEvent,
                            isHitEvent: isHitEvent,
                            victim_name: event.victim?.name,
                            victim_position: event.victim?.position,
                            victim_position_valid: event.victim?.position?.[0] !== null && event.victim?.position?.[0] !== undefined
                        });
                        
                        if ((isKillEvent || isHitEvent) && event.victim && event.victim.position && event.victim.position[0] !== null) {
                            const victimScaledX = (event.victim.position[0] - this.coordinateOffset.x) * this.coordinateScale;
                            const victimScaledY = (event.victim.position[1] - this.coordinateOffset.y) * this.coordinateScale;
                            const victimScaledZ = (event.victim.position[2] - this.coordinateOffset.z) * this.coordinateScale;
                            
                            // í”¼ê²©ì ë§ ì¶”ê°€ (kill: ë…¸ë€ìƒ‰, hit: ì£¼í™©ìƒ‰)
                            const mapSizeForRing = this.mapBounds ? Math.max(this.mapBounds.width, this.mapBounds.depth, this.mapBounds.height) : 1000;
                            const normalizedMapSizeForRing = this.mapBounds?.normalizedWidth || mapSizeForRing;
                            const playerScaleForRing = Math.max(0.25, Math.min(0.6, normalizedMapSizeForRing / 5000));
                            const baseSizeForRing = 5 * playerScaleForRing;
                            const innerRadius = baseSizeForRing * 2.0;
                            const outerRadius = baseSizeForRing * 2.4;
                            // kill: ë…¸ë€ìƒ‰, hit: ì£¼í™©ìƒ‰
                            const victimRingColor = isKillEvent ? 0xffd93d : 0xffa500;
                            const victimRing = new THREE.Mesh(
                                new THREE.RingGeometry(innerRadius, outerRadius, 32),
                                new THREE.MeshPhongMaterial({ 
                                    color: victimRingColor,
                                    emissive: victimRingColor,
                                    emissiveIntensity: 0.7,
                                    side: THREE.DoubleSide
                                })
                            );
                            victimRing.position.set(
                                victimScaledX,
                                victimScaledZ, // Three.js Yì¶•
                                victimScaledY  // Three.js Zì¶•
                            );
                            victimRing.rotation.x = -Math.PI / 2;
                            this.scene.add(victimRing);
                            this.eventMarkers.push(victimRing);
                            
                            // í”Œë ˆì´ì–´ ëª¨ë¸ì˜ ì‹¤ì œ ì¤‘ì•™ ë†’ì´ ê³„ì‚°
                            const mapSize = this.mapBounds ? Math.max(this.mapBounds.width, this.mapBounds.depth, this.mapBounds.height) : 1000;
                            const normalizedMapSize = this.mapBounds?.normalizedWidth || mapSize;
                            const playerScale = Math.max(0.15, Math.min(0.4, normalizedMapSize / 5000));
                            const baseSize = 3.5 * playerScale;
                            
                            // attackerì™€ victimì˜ team ì •ë³´ í™•ì¸í•˜ì—¬ ëª¨ë¸ ì¤‘ì•™ ë†’ì´ ê³„ì‚°
                            const attackerIsCT = event.attacker.team === 'CT';
                            const victimIsCT = event.victim.team === 'CT';
                            
                            // CTëŠ” êµ¬ì²´(ì¤‘ì‹¬ = scaledZ), TëŠ” ì›ë¿”(ì¤‘ì‹¬ = scaledZ + baseSize)
                            const attackerCenterY = attackerIsCT ? attackerScaledZ : attackerScaledZ + baseSize;
                            const victimCenterY = victimIsCT ? victimScaledZ : victimScaledZ + baseSize;
                            
                            // ìƒë‹¨ ë¼ë²¨ ìœ„ì¹˜ (ë‘ í”Œë ˆì´ì–´ì˜ ì¤‘ê°„ ì§€ì  ìœ„ì— ê°™ì€ ë†’ì´ë¡œ ìˆ˜í‰ ë°°ì¹˜)
                            // í”Œë ˆì´ì–´ ì •ë³´ ë°•ìŠ¤ ìœ„ì— ìì—°ìŠ¤ëŸ½ê²Œ ë°°ì¹˜ë˜ë„ë¡ ì¡°ì •
                            const maxPlayerHeight = Math.max(
                                attackerIsCT ? baseSize : (baseSize * 2),
                                victimIsCT ? baseSize : (baseSize * 2)
                            );
                            const playerInfoBoxHeight = 10; // í”Œë ˆì´ì–´ ì •ë³´ ë°•ìŠ¤ ë†’ì´ (ìŠ¤í”„ë¼ì´íŠ¸ í¬ê¸°)
                            const LABEL_Y_OFFSET = maxPlayerHeight * 0.5 + playerInfoBoxHeight + 25; // í”Œë ˆì´ì–´ í‘œì‹ ìœ„ + ì •ë³´ ë°•ìŠ¤ + ì—¬ìœ  ê³µê°„
                            const midX = (attackerScaledX + victimScaledX) / 2;
                            const midZ = (attackerScaledZ + victimScaledZ) / 2;
                            const midY = (attackerScaledY + victimScaledY) / 2;
                            const labelHeight = Math.max(attackerScaledZ, victimScaledZ) + LABEL_Y_OFFSET;
                            
                            // ATTACKER ë°•ìŠ¤ëŠ” ì™¼ìª½, DEAD ë°•ìŠ¤ëŠ” ì˜¤ë¥¸ìª½ì— ë°°ì¹˜
                            const labelSpacing = 80; // ë‘ ë°•ìŠ¤ ì‚¬ì´ ê°„ê²©
                            const attackerLabelX = midX - labelSpacing / 2;
                            const victimLabelX = midX + labelSpacing / 2;
                            const attackerLabelTopY = labelHeight;
                            const victimLabelTopY = labelHeight;
                            
                            // Attacker ë¼ë²¨ ìƒì„± (victimì´ ìˆì„ ë•Œë§Œ, ìˆ˜í‰ ë°°ì¹˜ë¥¼ ìœ„í•´)
                            // í¬ì»¤ìŠ¤ ëª¨ë“œì—ì„œ ì„ íƒëœ ì´ë²¤íŠ¸ëŠ” timeDiff ì¡°ê±´ ë¬´ì‹œ
                            const shouldShowAttackerLabel = (this.focusMode && this.selectedEvent && timeMatch) 
                                ? true 
                                : (timeDiff < 2.0);
                            if (shouldShowAttackerLabel) {
                            const fadeStart = 1.5;
                            const fadeEnd = 2.0;
                            let opacity = 1.0;
                            
                            if (timeDiff > fadeStart) {
                                opacity = 1.0 - ((timeDiff - fadeStart) / (fadeEnd - fadeStart));
                                opacity = Math.max(0, opacity);
                            }
                            
                            if (opacity > 0) {
                                const attackerCanvas = document.createElement('canvas');
                                const attackerCtx = attackerCanvas.getContext('2d');
                                
                                // í…ìŠ¤íŠ¸ í¬ê¸° ì¸¡ì •í•˜ì—¬ ë™ì  í¬ê¸° ê³„ì‚°
                                attackerCtx.font = 'bold 16px Arial';
                                const attackerText = 'ATTACKER';
                                const attackerTextWidth = attackerCtx.measureText(attackerText).width;
                                
                                attackerCtx.font = 'bold 14px Arial';
                                const nameText = event.attacker.name || 'Unknown';
                                const nameTextWidth = attackerCtx.measureText(nameText).width;
                                
                                attackerCtx.font = '12px Arial';
                                const weaponText = event.weapon ? `Weapon: ${event.weapon}` : '';
                                const weaponTextWidth = weaponText ? attackerCtx.measureText(weaponText).width : 0;
                                
                                const padding = 8;
                                const lineHeight = 18;
                                const maxWidth = Math.max(attackerTextWidth, nameTextWidth, weaponTextWidth) + padding * 2;
                                const height = (weaponText ? 3 : 2) * lineHeight + padding * 2;
                                
                                attackerCanvas.width = maxWidth;
                                attackerCanvas.height = height;
                                
                                    // ë°°ê²½
                                    attackerCtx.fillStyle = `rgba(255, 77, 79, ${0.25 * opacity})`; // ì—°í•œ ë¹¨ê°„ ë°°ê²½
                                attackerCtx.fillRect(0, 0, attackerCanvas.width, attackerCanvas.height);
                                
                                // ê·¸ë¦¼ì íš¨ê³¼
                                attackerCtx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                                attackerCtx.shadowBlur = 4;
                                attackerCtx.shadowOffsetX = 2;
                                attackerCtx.shadowOffsetY = 2;
                                
                                    // í…Œë‘ë¦¬ (ê³µê²©ì: ë¹¨ê°„ìƒ‰)
                                    attackerCtx.strokeStyle = `rgba(255, 77, 79, ${opacity})`;
                                attackerCtx.lineWidth = 3;
                                attackerCtx.strokeRect(2, 2, attackerCanvas.width - 4, attackerCanvas.height - 4);
                                
                                // ê·¸ë¦¼ì íš¨ê³¼ ì´ˆê¸°í™”
                                attackerCtx.shadowColor = 'transparent';
                                attackerCtx.shadowBlur = 0;
                                attackerCtx.shadowOffsetX = 0;
                                attackerCtx.shadowOffsetY = 0;
                                
                                let yPos = padding + 14;
                                
                                    // ATTACKER í…ìŠ¤íŠ¸ (í°ìƒ‰)
                                    attackerCtx.fillStyle = `rgba(255, 255, 255, ${opacity})`; // í°ìƒ‰
                                attackerCtx.font = 'bold 18px Arial';
                                attackerCtx.textAlign = 'center';
                                // í…ìŠ¤íŠ¸ ê·¸ë¦¼ì
                                attackerCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                                attackerCtx.shadowBlur = 2;
                                attackerCtx.fillText('ATTACKER', attackerCanvas.width / 2, yPos);
                                attackerCtx.shadowColor = 'transparent';
                                attackerCtx.shadowBlur = 0;
                                
                                    // ê³µê²©ì ì´ë¦„ (í°ìƒ‰)
                                yPos += lineHeight;
                                    attackerCtx.fillStyle = `rgba(255, 255, 255, ${opacity})`; // í°ìƒ‰
                                attackerCtx.font = 'bold 16px Arial';
                                attackerCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                                attackerCtx.shadowBlur = 2;
                                attackerCtx.fillText(nameText, attackerCanvas.width / 2, yPos);
                                attackerCtx.shadowColor = 'transparent';
                                attackerCtx.shadowBlur = 0;
                                
                                    // ë¬´ê¸° ì •ë³´ (í°ìƒ‰)
                                if (event.weapon) {
                                    yPos += lineHeight;
                                        attackerCtx.fillStyle = `rgba(255, 255, 255, ${opacity})`; // í°ìƒ‰
                                    attackerCtx.font = 'bold 13px Arial';
                                    attackerCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                                    attackerCtx.shadowBlur = 2;
                                    attackerCtx.fillText(`Weapon: ${event.weapon}`, attackerCanvas.width / 2, yPos);
                                    attackerCtx.shadowColor = 'transparent';
                                    attackerCtx.shadowBlur = 0;
                                }
                                
                                const attackerTex = new THREE.CanvasTexture(attackerCanvas);
                                const attackerSprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                                    map: attackerTex, 
                                    transparent: true,
                                    opacity: opacity,
                                    depthTest: false
                                }));
                                    // ìƒë‹¨ ë¼ë²¨ ìœ„ì¹˜ì— ìˆ˜í‰ìœ¼ë¡œ ë°°ì¹˜ (attackerëŠ” ì™¼ìª½)
                                attackerSprite.position.set(
                                        attackerLabelX,
                                        attackerLabelTopY,
                                        midY
                                    );
                                    // ì‚´ì§ ë” í¬ê²Œ ìŠ¤ì¼€ì¼ë§í•˜ì—¬ í‚¤ì›Œë“œ íš¨ê³¼ ê°•í™”
                                    attackerSprite.scale.set(maxWidth * 0.14, height * 0.14, 1);
                                this.scene.add(attackerSprite);
                                this.eventMarkers.push(attackerSprite);
                            }
                        }

                            // ìƒë‹¨ ATTACKER â†” DEAD ë¼ë²¨ ì‚¬ì´ ë¹¨ê°„ ì„  (êµ¬ì¡° ìƒë‹¨ ì—°ê²°)
                            const topLineGeom = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(attackerLabelX, attackerLabelTopY, midY),
                                new THREE.Vector3(victimLabelX, victimLabelTopY, midY)
                            ]);
                            const topLineMat = new THREE.LineBasicMaterial({
                                color: 0xff0000,
                                opacity: 0.9,
                                transparent: true,
                                linewidth: 2
                            });
                            const topLine = new THREE.Line(topLineGeom, topLineMat);
                            this.scene.add(topLine);
                            this.eventMarkers.push(topLine);
                            
                            // ìƒë‹¨ ë¼ë²¨ê³¼ í”Œë ˆì´ì–´ë¥¼ ì—°ê²°í•˜ëŠ” íŒŒë€ìƒ‰ ë¼ì¸ (ATTACKER/dead êµ¬ì¡°ë¥¼ í•˜ë‹¨ í”Œë ˆì´ì–´ì™€ ë¶„ë¦¬í•´ ì‹œê°í™”)
                            const linkMaterial = new THREE.LineBasicMaterial({
                                color: 0x2a6f9b,
                                opacity: 0.9,
                                transparent: true,
                                linewidth: 2
                            });

                            // ê³µê²©ì: ìƒë‹¨ ë¼ë²¨ â†’ í”Œë ˆì´ì–´ ì¤‘ì‹¬
                            const attackerLinkGeom = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(attackerLabelX, attackerLabelTopY, midY),
                                new THREE.Vector3(attackerScaledX, attackerCenterY, attackerScaledY)
                            ]);
                            const attackerLink = new THREE.Line(attackerLinkGeom, linkMaterial);
                            this.scene.add(attackerLink);
                            this.eventMarkers.push(attackerLink);

                            // í”¼ê²©ì: ìƒë‹¨ ë¼ë²¨ â†’ í”Œë ˆì´ì–´ ì¤‘ì‹¬
                            const victimLinkGeom = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(victimLabelX, victimLabelTopY, midY),
                                new THREE.Vector3(victimScaledX, victimCenterY, victimScaledY)
                            ]);
                            const victimLink = new THREE.Line(victimLinkGeom, linkMaterial);
                            this.scene.add(victimLink);
                            this.eventMarkers.push(victimLink);
                            
                            // src-trg ë¹¨ê°„ìƒ‰ ì—°ê²°ì„  (í”Œë ˆì´ì–´ ëª¨ë¸ ì¤‘ì•™ë¼ë¦¬ ì§ì ‘ ì—°ê²°)
                            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(
                                    attackerScaledX,
                                    attackerCenterY, // í”Œë ˆì´ì–´ ëª¨ë¸ ì¤‘ì•™ ë†’ì´
                                    attackerScaledY
                                ),
                                new THREE.Vector3(
                                    victimScaledX,
                                    victimCenterY, // í”Œë ˆì´ì–´ ëª¨ë¸ ì¤‘ì•™ ë†’ì´
                                    victimScaledY
                                )
                            ]);
                            const lineMaterial = new THREE.LineBasicMaterial({ 
                                color: 0xff0000, // ì§„í•œ ë¹¨ê°„ìƒ‰
                                opacity: 0.9,
                                transparent: true,
                                linewidth: 3 // ë” ë‘ê»ê²Œ
                            });
                            const line = new THREE.Line(lineGeometry, lineMaterial);
                            this.scene.add(line);
                            this.eventMarkers.push(line);

                            // Victim 'DEAD'/'VICTIM' label with HEADSHOT and weapon info
                            // ì •í™•íˆ í•´ë‹¹ í‹±ì—ë§Œ í‘œì‹œí•˜ê³  2ì´ˆê°„ í˜ì´ë“œì•„ì›ƒ
                            // í¬ì»¤ìŠ¤ ëª¨ë“œì—ì„œ ì„ íƒëœ ì´ë²¤íŠ¸ëŠ” timeDiff ì¡°ê±´ ë¬´ì‹œ
                            const shouldShowDeadLabel = (this.focusMode && this.selectedEvent && timeMatch) 
                                ? true 
                                : (timeDiff < 2.0);
                            if (shouldShowDeadLabel) {
                                const fadeStart = 1.5; // 1.5ì´ˆ í›„ë¶€í„° í˜ì´ë“œ ì‹œì‘
                                const fadeEnd = 2.0; // 2ì´ˆì— ì™„ì „íˆ ì‚¬ë¼ì§
                                let opacity = 1.0;
                                
                                if (timeDiff > fadeStart) {
                                    opacity = 1.0 - ((timeDiff - fadeStart) / (fadeEnd - fadeStart));
                                    opacity = Math.max(0, opacity);
                                }
                                
                                if (opacity > 0) {
                                    const canvas = document.createElement('canvas');
                                    const ctx = canvas.getContext('2d');
                                    
                                    // í…ìŠ¤íŠ¸ í¬ê¸° ì¸¡ì •í•˜ì—¬ ë™ì  í¬ê¸° ê³„ì‚°
                                    ctx.font = 'bold 16px Arial';
                                    const deadText = isKillEvent ? 'DEAD' : 'VICTIM';
                                    const deadTextWidth = ctx.measureText(deadText).width;
                                    
                                    ctx.font = 'bold 12px Arial';
                                    const headshotText = event.headshot ? 'HEADSHOT' : '';
                                    const headshotTextWidth = headshotText ? ctx.measureText(headshotText).width : 0;
                                    
                                    ctx.font = '12px Arial';
                                    const victimText = `victim: ${event.victim.name || 'Unknown'}`;
                                    const victimTextWidth = ctx.measureText(victimText).width;
                                    
                                    const weaponText = event.weapon ? `by ${event.weapon}` : '';
                                    const weaponTextWidth = weaponText ? ctx.measureText(weaponText).width : 0;
                                    
                                    const padding = 8;
                                    const lineHeight = 18;
                                    const maxWidth = Math.max(deadTextWidth, headshotTextWidth, victimTextWidth, weaponTextWidth) + padding * 2;
                                    let height = padding * 2 + 16; // DEAD
                                    if (event.headshot) height += lineHeight;
                                    height += lineHeight; // victim
                                    if (event.weapon) height += lineHeight;
                                    
                                    canvas.width = maxWidth;
                                    canvas.height = height;
                                    
                                    // ë°°ê²½ (kill: ë…¸ë€ìƒ‰, hit: ì£¼í™©ìƒ‰)
                                    const bgColor = isKillEvent ? 'rgba(255, 217, 61, ' : 'rgba(255, 165, 0, ';
                                    ctx.fillStyle = bgColor + (0.25 * opacity) + ')';
                                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                                    
                                    // ê·¸ë¦¼ì íš¨ê³¼
                                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                                    ctx.shadowBlur = 4;
                                    ctx.shadowOffsetX = 2;
                                    ctx.shadowOffsetY = 2;
                                    
                                    // í…Œë‘ë¦¬ (kill: ë…¸ë€ìƒ‰, hit: ì£¼í™©ìƒ‰)
                                    const borderColor = isKillEvent ? 'rgba(255, 217, 61, ' : 'rgba(255, 165, 0, ';
                                    ctx.strokeStyle = borderColor + opacity + ')';
                                    ctx.lineWidth = 3;
                                    ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
                                    
                                    // ê·¸ë¦¼ì íš¨ê³¼ ì´ˆê¸°í™”
                                    ctx.shadowColor = 'transparent';
                                    ctx.shadowBlur = 0;
                                    ctx.shadowOffsetX = 0;
                                    ctx.shadowOffsetY = 0;
                                    
                                    let yPos = padding + 14;
                                    
                                    // DEAD/VICTIM í…ìŠ¤íŠ¸ (í°ìƒ‰)
                                    ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`; // í°ìƒ‰
                                    ctx.font = 'bold 18px Arial';
                                    ctx.textAlign = 'center';
                                    // í…ìŠ¤íŠ¸ ê·¸ë¦¼ì
                                    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                                    ctx.shadowBlur = 2;
                                    ctx.fillText(deadText, canvas.width / 2, yPos);
                                    ctx.shadowColor = 'transparent';
                                    ctx.shadowBlur = 0;
                                    
                                    // HEADSHOT í‘œì‹œ (í—¤ë“œìƒ·ì¸ ê²½ìš°, í°ìƒ‰)
                                    if (event.headshot) {
                                        yPos += lineHeight;
                                        ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`; // í°ìƒ‰
                                        ctx.font = 'bold 14px Arial';
                                        ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                                        ctx.shadowBlur = 2;
                                        ctx.fillText('HEADSHOT', canvas.width / 2, yPos);
                                        ctx.shadowColor = 'transparent';
                                        ctx.shadowBlur = 0;
                                    }
                                    
                                    // victim ì´ë¦„ (í°ìƒ‰)
                                    yPos += lineHeight;
                                    ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`; // í°ìƒ‰
                                    ctx.font = 'bold 14px Arial';
                                    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                                    ctx.shadowBlur = 2;
                                    ctx.fillText(victimText, canvas.width / 2, yPos);
                                    ctx.shadowColor = 'transparent';
                                    ctx.shadowBlur = 0;
                                    
                                    // ë¬´ê¸° ì •ë³´ (victimì´ ì£½ì€ ë¬´ê¸°, í°ìƒ‰)
                                    if (event.weapon) {
                                        yPos += lineHeight;
                                        ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`; // í°ìƒ‰
                                        ctx.font = 'bold 13px Arial';
                                        ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                                        ctx.shadowBlur = 2;
                                        ctx.fillText(weaponText, canvas.width / 2, yPos);
                                        ctx.shadowColor = 'transparent';
                                        ctx.shadowBlur = 0;
                                    }
                                    
                                    const tex = new THREE.CanvasTexture(canvas);
                                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                                        map: tex, 
                                        transparent: true,
                                        opacity: opacity,
                                        depthTest: false // í•­ìƒ ì•ì— í‘œì‹œ
                                    }));
                                    // ìƒë‹¨ ë¼ë²¨ ìœ„ì¹˜ì— ìˆ˜í‰ìœ¼ë¡œ ë°°ì¹˜ (deadëŠ” ì˜¤ë¥¸ìª½)
                                    sprite.position.set(
                                        victimLabelX,
                                        victimLabelTopY,
                                        midY
                                    );
                                    // DEAD ë°•ìŠ¤ë„ ì¡°ê¸ˆ ë” í¬ê²Œ
                                    sprite.scale.set(maxWidth * 0.14, height * 0.14, 1);
                                    this.scene.add(sprite);
                                    this.eventMarkers.push(sprite);
                                }
                            }
                        }
                        // í•œ í”„ë ˆì„ì— í•˜ë‚˜ì˜ ì£¼ìš” ì´ë²¤íŠ¸ë§Œ í‘œì‹œ (ì”ìƒ/ëˆ„ì  ë°©ì§€)
                        return;
                    }
                });
            }

            togglePlay() {
                this.isPlaying = !this.isPlaying;
                document.getElementById('play-btn').textContent = this.isPlaying ? 'â¸' : 'â–¶';
            }

            seekTo(percent) {
                if (!this.data) return;
                const maxTick = this.data.positions.length - 1;
                this.currentTick = Math.floor(percent * maxTick);
                // íƒ€ì„ë¼ì¸ ì í”„ ì‹œì—ëŠ” ë³´ê°„ ì—†ì´ í•´ë‹¹ í‹±ìœ¼ë¡œ ë°”ë¡œ ì´ë™
                this.renderTick(this.currentTick, 0);
                this.updateTimeDisplay();
            }

            updateTimeDisplay() {
                if (!this.data) return;
                
                const tickData = this.data.positions[this.currentTick];
                if (tickData) {
                    const m = this.data.metadata;
                    const currentTime = tickData.game_time - m.time_range.min;
                    const totalTime = m.time_range.max - m.time_range.min;
                    
                    document.getElementById('time-display').textContent = 
                        `${this.formatTime(currentTime)} / ${this.formatTime(totalTime)}`;
                    
                    const progress = (this.currentTick / (this.data.positions.length - 1)) * 100;
                    document.getElementById('timeline-progress').style.width = `${progress}%`;
                }
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                const ms = Math.floor((seconds % 1) * 1000);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
            }

            animate(now) {
                // requestAnimationFrame ê¸°ë°˜ ë©”ì¸ ë£¨í”„
                requestAnimationFrame((t) => this.animate(t));

                // ì²« í”„ë ˆì„ì—ì„œëŠ” nowê°€ ì—†ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ performance.now() ì‚¬ìš©
                if (now === undefined) {
                    now = performance.now();
                }

                if (this.updateCamera) {
                    this.updateCamera();
                }

                if (this.isPlaying && this.data) {
                    if (!this.lastUpdateTime) {
                        this.lastUpdateTime = now;
                    }

                    // delta ê³„ì‚° ë° ìƒí•œ(clamp)
                    let delta = now - this.lastUpdateTime;
                    if (delta < 0 || !Number.isFinite(delta)) delta = 0;
                    delta = Math.min(delta, 50); // ìµœëŒ€ 50msê¹Œì§€ë§Œ ì¸ì •
                    this.lastUpdateTime = now;

                    // ëˆ„ì  ì‹œê°„ì— delta ì¶”ê°€
                    this.timeAccumulator = (this.timeAccumulator || 0) + delta;
                    const maxTicksPerFrame = 5; // í•œ í”„ë ˆì„ë‹¹ ìµœëŒ€ ì²˜ë¦¬ í‹± ìˆ˜
                    let ticksProcessed = 0;

                    // í‹± ì—…ë°ì´íŠ¸ ë£¨í”„ (update ë‹¨ê³„)
                    while (this.timeAccumulator > 0 && ticksProcessed < maxTicksPerFrame) {
                    const tickData = this.data.positions[this.currentTick];
                    const nextTickData = this.data.positions[this.currentTick + 1];
                        if (!tickData || !nextTickData) break;

                        let tickInterval = (nextTickData.game_time - tickData.game_time) * 1000; // ms
                        if (!(tickInterval > 0) || Number.isNaN(tickInterval)) {
                            tickInterval = 16.67; // fallback: 60fps ê¸°ì¤€
                        }
                        const targetInterval = tickInterval / this.playSpeed;

                        if (this.timeAccumulator < targetInterval) {
                            break; // ë‹¤ìŒ í‹±ìœ¼ë¡œ ë„˜ì–´ê°ˆ ë§Œí¼ ì‹œê°„ ëˆ„ì  ì•ˆ ë¨
                        }

                        // í•œ í‹± ì†Œë¹„
                        this.timeAccumulator -= targetInterval;
                        this.currentTick += 1;
                        ticksProcessed++;

                        // í¬ì»¤ìŠ¤ ëª¨ë“œì¸ ê²½ìš° ë²”ìœ„ ì²´í¬ (í‹± ê¸°ë°˜)
                        if (this.focusMode && this.focusTickRange) {
                            if (this.currentTick > this.focusTickRange.endIdx) {
                                this.currentTick = this.focusTickRange.startIdx;
                                this.isPlaying = false;
                                document.getElementById('play-btn').textContent = 'â–¶';
                                break;
                            }
                        }

                        if (this.currentTick >= this.data.positions.length) {
                            this.currentTick = this.data.positions.length - 1;
                            this.isPlaying = false;
                            document.getElementById('play-btn').textContent = 'â–¶';
                            break;
                        }
                    }

                    // í˜„ì¬ í‹±ê³¼ ë‹¤ìŒ í‹± ì‚¬ì´ì˜ ë³´ê°„ ë¹„ìœ¨ ê³„ì‚° (render ë‹¨ê³„ìš©)
                    let interpolation = 0;
                    const curTickDataForInterp = this.data.positions[this.currentTick];
                    const nextTickDataForInterp = this.data.positions[this.currentTick + 1];
                    if (curTickDataForInterp && nextTickDataForInterp) {
                        let tickInterval = (nextTickDataForInterp.game_time - curTickDataForInterp.game_time) * 1000;
                        if (!(tickInterval > 0) || Number.isNaN(tickInterval)) {
                            tickInterval = 16.67;
                        }
                        const targetInterval = tickInterval / this.playSpeed;
                        if (targetInterval > 0) {
                            interpolation = Math.max(0, Math.min(1, this.timeAccumulator / targetInterval));
                        }
                    }

                    // ì¬ìƒ ì¤‘ì—ëŠ” í•­ìƒ í˜„ì¬ í‹±ì„ ë Œë”ë§
                    if (this.currentTick < this.data.positions.length) {
                        // Follow selected player if enabled
                            if (this.followPlayer && this.selectedPlayer) {
                            // í˜„ì¬ í‹±ì˜ í”Œë ˆì´ì–´ ë°ì´í„°ì—ì„œ ì§ì ‘ ì°¾ê¸°
                            const tickData = this.data.positions[this.currentTick];
                            if (tickData && tickData.players) {
                                // í”Œë ˆì´ì–´ ì´ë¦„ì„ ë¬¸ìì—´ë¡œ ì •í™•íˆ ë¹„êµ (íƒ€ì… ë³€í™˜ ë³´ì¥)
                                const selectedPlayerName = String(this.selectedPlayer);
                                const player = tickData.players.find(p => String(p.name) === selectedPlayerName);
                                
                                // ë””ë²„ê¹…: í”Œë ˆì´ì–´ ì°¾ê¸° í™•ì¸
                                if (!player && this.selectedPlayer) {
                                    console.log('FOLLOW ëª¨ë“œ: í”Œë ˆì´ì–´ë¥¼ ì°¾ì§€ ëª»í•¨', {
                                        selectedPlayer: this.selectedPlayer,
                                        selectedPlayerType: typeof this.selectedPlayer,
                                        availablePlayers: tickData.players.map(p => ({ name: p.name, nameType: typeof p.name }))
                                    });
                                }
                                
                                    if (player && player.position && Array.isArray(player.position)) {
                                    // í”Œë ˆì´ì–´ ìœ„ì¹˜ë¥¼ ì¹´ë©”ë¼ íƒ€ê²Ÿìœ¼ë¡œ ì„¤ì • (ìŠ¤ì¼€ì¼ë§ëœ ì¢Œí‘œ ì‚¬ìš©)
                                        const scaledX = (player.position[0] - this.coordinateOffset.x) * this.coordinateScale;
                                        const scaledY = (player.position[1] - this.coordinateOffset.y) * this.coordinateScale;
                                        const scaledZ = (player.position[2] - this.coordinateOffset.z) * this.coordinateScale;
                                    this.cameraTarget = { 
                                        x: scaledX, // X
                                        y: scaledZ, // Three.js Yì¶• (ë†’ì´)
                                        z: scaledY  // Three.js Zì¶•
                                    };
                                    
                                    // ìŠ¤ì¼€ì¼ë§ëœ ì¢Œí‘œë¡œ í˜„ì¬ í‹±ì˜ ëª¨ë“  í”Œë ˆì´ì–´ X, Z ë²”ìœ„ë¥¼ ê³„ì‚°
                                    let minX = Infinity, maxX = -Infinity;
                                    let minZ = Infinity, maxZ = -Infinity;
                                    
                                    for (let i = 0; i < tickData.players.length; i++) {
                                        const p = tickData.players[i];
                                        if (p.position && Array.isArray(p.position)) {
                                            // ìŠ¤ì¼€ì¼ë§ëœ ì¢Œí‘œ ì‚¬ìš©
                                            const scaledX = (p.position[0] - this.coordinateOffset.x) * this.coordinateScale;
                                            const scaledZ = (p.position[1] - this.coordinateOffset.z) * this.coordinateScale;
                                            if (!Number.isNaN(scaledX)) {
                                                minX = Math.min(minX, scaledX);
                                                maxX = Math.max(maxX, scaledX);
                                            }
                                            if (!Number.isNaN(scaledZ)) {
                                                minZ = Math.min(minZ, scaledZ);
                                                maxZ = Math.max(maxZ, scaledZ);
                                            }
                                        }
                                    }
                                    
                                    // ìˆ˜ë™ ì¤Œ ì¡°ì •ì´ ì—†ì„ ë•Œë§Œ ìë™ìœ¼ë¡œ ì¹´ë©”ë¼ ê±°ë¦¬ ê³„ì‚°
                                    // í•˜ì§€ë§Œ manualZoomInFollowê°€ trueì—¬ë„ ìµœì†Œ ê±°ë¦¬ëŠ” ë³´ì¥
                                    if (!this.manualZoomInFollow) {
                                    // X, Z ë²”ìœ„ì— ë§ì¶°ì„œ ì¹´ë©”ë¼ ê±°ë¦¬ ê³„ì‚° (2D ë·°)
                                    if (minX !== Infinity && minZ !== Infinity) {
                                        const width = Math.max(maxX - minX, 100);
                                        const depth = Math.max(maxZ - minZ, 100);
                                            
                                            // ì‹¤ì œ í™”ë©´ í¬ê¸°ë¥¼ ê°€ì ¸ì™€ì„œ ì¹´ë©”ë¼ ê±°ë¦¬ ê³„ì‚°
                                            const container = document.getElementById('canvas-container');
                                            const screenWidth = container ? container.clientWidth : 800;
                                            const screenHeight = container ? container.clientHeight : 600;
                                            
                                        const fov = this.camera.fov * (Math.PI / 180);
                                            const aspect = screenWidth / screenHeight;
                                            
                                            // í™”ë©´ í¬ê¸°ì— ë§ì¶°ì„œ í”Œë ˆì´ì–´ ë²”ìœ„ë¥¼ í™”ë©´ì— ë§ê²Œ ì¡°ì •
                                            // FOLLOW ëª¨ë“œ: ì „ì²´ ë§µì´ ë³´ì´ë„ë¡ ë” ë„“ì€ ë²”ìœ„ ì‚¬ìš©
                                            const targetScreenRatio = 0.5; // í™”ë©´ì˜ 50%ë¥¼ ì‚¬ìš© (ë” ë„“ì€ ë·°)
                                            
                                            const distanceX = (width / 2) / Math.tan(fov / 2) / aspect / targetScreenRatio;
                                            const distanceZ = (depth / 2) / Math.tan(fov / 2) / targetScreenRatio;
                                            
                                            let calculatedDistance = Math.max(distanceX, distanceZ);
                                            
                                            // í”Œë ˆì´ì–´ ë²”ìœ„ê°€ ë„ˆë¬´ ë„“ì„ ë•Œë¥¼ ëŒ€ë¹„í•œ ì²˜ë¦¬
                                            const playerRange = Math.max(width, depth);
                                            const screenMinDim = Math.min(screenWidth, screenHeight);
                                            const maxVisibleRange = screenMinDim * 2.0;
                                            
                                            // í”Œë ˆì´ì–´ ë²”ìœ„ê°€ í™”ë©´ë³´ë‹¤ ë„ˆë¬´ ë„“ìœ¼ë©´ ê°•ì œë¡œ ì¤Œ ì¸
                                            if (playerRange > maxVisibleRange) {
                                                const scaleFactor = maxVisibleRange / playerRange;
                                                const scaledWidth = width * scaleFactor;
                                                const scaledDepth = depth * scaleFactor;
                                                
                                                const scaledDistanceX = (scaledWidth / 2) / Math.tan(fov / 2) / aspect / targetScreenRatio;
                                                const scaledDistanceZ = (scaledDepth / 2) / Math.tan(fov / 2) / targetScreenRatio;
                                                calculatedDistance = Math.max(scaledDistanceX, scaledDistanceZ);
                                            }
                                            
                                            // ìµœì†Œ/ìµœëŒ€ ê±°ë¦¬ ì œí•œ
                                            // FOLLOW ëª¨ë“œ: ì „ì²´ ë§µì´ ë³´ì´ë„ë¡ ìµœì†Œ ê±°ë¦¬ë¥¼ ëŠ˜ë¦¼
                                            const minDistance = Math.max(500, screenMinDim * 0.8); // ìµœì†Œ ê±°ë¦¬ ì¦ê°€
                                            const maxDistance = screenMinDim * 8.0; // ìµœëŒ€ ê±°ë¦¬ë„ ì¦ê°€
                                            
                                            // mapBoundsë¥¼ ê³ ë ¤í•˜ì—¬ ì „ì²´ ë§µì´ ë³´ì´ë„ë¡ ì¡°ì •
                                            let finalDistance = Math.max(minDistance, Math.min(calculatedDistance, maxDistance));
                                            
                                            // mapBoundsê°€ ìˆìœ¼ë©´ ì „ì²´ ë§µì´ ë³´ì´ë„ë¡ ì¶”ê°€ ì¡°ì •
                                            if (this.mapBounds) {
                                                const mapSize = Math.max(this.mapBounds.width, this.mapBounds.depth);
                                                const normalizedMapSize = this.mapBounds.normalizedWidth || mapSize;
                                                // ì „ì²´ ë§µì´ ë³´ì´ë„ë¡ í•„ìš”í•œ ìµœì†Œ ê±°ë¦¬ ê³„ì‚°
                                                const requiredDistance = normalizedMapSize * 0.6;
                                                // ê³„ì‚°ëœ ê±°ë¦¬ì™€ í•„ìš”í•œ ê±°ë¦¬ ì¤‘ ë” í° ê°’ ì‚¬ìš©
                                                finalDistance = Math.max(finalDistance, requiredDistance);
                                            }
                                            
                                            this.cameraDistance = finalDistance;
                                    } else {
                                        // í”Œë ˆì´ì–´ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ ê±°ë¦¬ (ì „ì²´ ë§µì´ ë³´ì´ë„ë¡)
                                        if (this.mapBounds) {
                                            const mapSize = Math.max(this.mapBounds.width, this.mapBounds.depth, this.mapBounds.height);
                                            const normalizedMapSize = this.mapBounds.normalizedWidth || mapSize;
                                            this.cameraDistance = Math.max(800, Math.min(3000, normalizedMapSize * 0.8));
                                        } else {
                                            const screenMinDim = Math.min(
                                                document.getElementById('canvas-container')?.clientWidth || 800,
                                                document.getElementById('canvas-container')?.clientHeight || 600
                                            );
                                            this.cameraDistance = Math.max(800, screenMinDim * 1.2);
                                        }
                                        }
                                    } else {
                                        // manualZoomInFollowê°€ trueì¼ ë•ŒëŠ” ì‚¬ìš©ìê°€ ì„¤ì •í•œ ê±°ë¦¬ë¥¼ ìœ ì§€
                                        // ìµœì†Œ ê±°ë¦¬ë§Œ ë³´ì¥ (ë„ˆë¬´ ì‘ìœ¼ë©´ ì•ˆì „í•œ ìµœì†Œê°’ìœ¼ë¡œë§Œ ì„¤ì •)
                                        if (!Number.isFinite(this.cameraDistance) || this.cameraDistance <= 0) {
                                            const container = document.getElementById('canvas-container');
                                            const screenWidth = container ? container.clientWidth : 800;
                                            const screenHeight = container ? container.clientHeight : 600;
                                            const screenMinDim = Math.min(screenWidth, screenHeight);
                                            this.cameraDistance = Math.max(600, screenMinDim * 0.6);
                                        }
                                        // ì´ë¯¸ ì„¤ì •ëœ ê±°ë¦¬ê°€ ìˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ìœ ì§€ (ìë™ ê³„ì‚° ì•ˆ í•¨)
                                    }
                                    
                                    // ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸ (í”Œë ˆì´ì–´ë¥¼ ì°¾ì•˜ì„ ë•Œ)
                                    this.updateCamera();
                                    
                                    // íŒ¨ë‹ ì˜¤í”„ì…‹ì€ ìœ ì§€ (Shiftë¡œ íŒ¨ë‹ ê°€ëŠ¥í•˜ë„ë¡)
                                    // Follow ëª¨ë“œ ì‹œì‘ ì‹œì—ë§Œ ì´ˆê¸°í™”
                                } else {
                                    // í”Œë ˆì´ì–´ë¥¼ ì°¾ì§€ ëª»í–ˆì„ ë•Œë„ ì¹´ë©”ë¼ ê±°ë¦¬ ë³´ì¥
                                    if (!Number.isFinite(this.cameraDistance) || this.cameraDistance <= 0 || this.cameraDistance < 200) {
                                        const container = document.getElementById('canvas-container');
                                        const screenWidth = container ? container.clientWidth : 800;
                                        const screenHeight = container ? container.clientHeight : 600;
                                        const screenMinDim = Math.min(screenWidth, screenHeight);
                                        this.cameraDistance = Math.max(600, screenMinDim * 0.6);
                                    }
                                    // ì¹´ë©”ë¼ íƒ€ê²Ÿì´ ì—†ìœ¼ë©´ ê¸°ë³¸ íƒ€ê²Ÿ ì‚¬ìš©
                                    if (!this.cameraTarget) {
                                        this.cameraTarget = this.defaultTarget || { x: 0, y: 0, z: 0 };
                                    }
                                    this.updateCamera();
                                }
                            }
                        }
                        // ë³´ê°„ ë¹„ìœ¨ì„ ë„˜ê²¨ì„œ ë¶€ë“œëŸ½ê²Œ ì´ë™
                        this.renderTick(this.currentTick, interpolation);
                        this.updateTimeDisplay();
                        // Aim trace ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ (íƒ­ì´ ì—´ë ¤ìˆì„ ë•Œ)
                        const activeTabEl3 = document.querySelector('.tab-btn.active');
                        const activeTab3 = activeTabEl3 ? activeTabEl3.getAttribute('data-tab') : null;
                        if (activeTab3 === 'aim') this.renderAimTrace();
                    }
                }

                this.renderer.render(this.scene, this.camera);
                    
                    // ì¹´ë©”ë¼ ì •ë³´ ì—…ë°ì´íŠ¸ (ë§¤ í”„ë ˆì„ë§ˆë‹¤)
                    if (this.updateCameraInfo) {
                        this.updateCameraInfo();
                    }
            }
        }

        // ì¦‰ì‹œ ì‹¤í–‰í•˜ì—¬ ì´ˆê¸°í™” ë³´ì¥
        (function() {
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
            new CombatSimulation();
        });
            } else {
                // DOMì´ ì´ë¯¸ ë¡œë“œëœ ê²½ìš° ì¦‰ì‹œ ì‹¤í–‰
                new CombatSimulation();
            }
        })();
    </script>
</body>
</html>

