<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRUMB ‚Äî Combat Replay Unified Monitoring & Behavior-analysis</title>
    <link rel="icon" type="image/png" href="crumb_logo.png" onerror="this.href='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üçû</text></svg>'">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0f1419;
            color: #fff;
            overflow: hidden;
        }

        #top-nav {
            height: 50px;
            background: #1a1f2e;
            border-bottom: 1px solid #2a2f3e;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 30px;
            position: relative;
            z-index: 1000;
            width: 100%;
        }

        #brand-logo {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-right: 30px;
            padding-right: 30px;
            border-right: 1px solid #2a2f3e;
        }

        #brand-logo img {
            height: 32px;
            width: auto;
            object-fit: contain;
        }

        #brand-text {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        #brand-name {
            font-size: 13px;
            font-weight: 600;
            color: #fff;
            letter-spacing: 0.5px;
        }

        #brand-tagline {
            font-size: 10px;
            color: #8a8fa5;
            font-style: italic;
        }

        .nav-item {
            padding: 8px 16px;
            cursor: pointer;
            color: #8a8fa5;
            font-size: 14px;
            transition: color 0.2s;
        }

        .nav-item:hover {
            color: #fff;
        }

        .nav-item.active {
            color: #4a90e2;
            border-bottom: 2px solid #4a90e2;
        }

        #container {
            display: flex;
            height: calc(100vh - 50px);
            visibility: visible;
        }

        #sidebar {
            width: 350px;
            background: #1a1f2e;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #2a2f3e;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            background: #0a0e15;
            display: block;
            visibility: visible;
        }


        #dashboard-view {
            flex: 1;
            padding: 20px 40px 40px 40px;
            overflow-y: auto;
            overflow-x: hidden;
            background: #0f1419;
            display: block;
            height: calc(100vh - 50px);
        }

        #dashboard-view.hidden {
            display: none;
        }

        #dashboard-content {
            max-width: 1000px;
            margin: 0 auto;
            color: #fff;
            padding-right: 20px;
        }

        #dashboard-content h1 {
            font-size: 32px;
            margin-bottom: 20px;
            color: #fff;
        }

        #dashboard-content h2 {
            font-size: 24px;
            margin-top: 30px;
            margin-bottom: 15px;
            color: #4a90e2;
            border-bottom: 2px solid #2a2f3e;
            padding-bottom: 10px;
        }

        #dashboard-content h3 {
            font-size: 18px;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #8a8fa5;
        }

        #dashboard-content h4 {
            font-size: 16px;
            margin-top: 15px;
            margin-bottom: 8px;
            color: #6a6f85;
            font-weight: 600;
        }

        #dashboard-content p {
            line-height: 1.6;
            color: #c0c5d0;
            margin-bottom: 10px;
        }

        #dashboard-content strong {
            color: #fff;
            font-weight: 600;
        }

        #dashboard-content ul, #dashboard-content ol {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        #dashboard-content li {
            line-height: 1.6;
            color: #c0c5d0;
            margin-bottom: 2px;
        }

        #dashboard-content code {
            background: #1a1f2e;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #4a90e2;
        }

        #dashboard-content pre {
            background: #1a1f2e;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
        }

        #dashboard-content pre code {
            background: none;
            padding: 0;
            color: #c0c5d0;
        }

        #dashboard-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }

        #dashboard-content table th,
        #dashboard-content table td {
            border: 1px solid #2a2f3e;
            padding: 10px;
            text-align: left;
        }

        #dashboard-content table th {
            background: #1a1f2e;
            color: #4a90e2;
        }

        #canvas {
            width: 100%;
            height: 100%;
        }

        /* GitHub CSV ÏÑ†ÌÉù ÌåùÏóÖ */
        #csv-popup {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        #csv-popup.active {
            display: flex;
        }

        #csv-popup-content {
            background: #1a1f2e;
            border: 1px solid #2a2f3e;
            border-radius: 8px;
            padding: 20px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        #csv-popup-content h3 {
            margin-top: 0;
            color: #fff;
            margin-bottom: 15px;
        }

        #csv-file-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #csv-file-list li {
            padding: 12px;
            margin-bottom: 8px;
            background: #2a2f3e;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            color: #fff;
        }

        #csv-file-list li:hover {
            background: #3a3f4e;
        }

        #csv-popup-close {
            margin-top: 15px;
            padding: 10px 20px;
            background: #4a90e2;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        #csv-popup-close:hover {
            background: #5aa0f2;
        }

        #bottom-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 300px;
            background: rgba(26, 31, 46, 0.98);
            border-top: 1px solid #2a2f3e;
            display: flex;
            flex-direction: column;
        }

        /* drag handle to resize bottom panel */
        #resize-handle {
            height: 6px;
            cursor: ns-resize;
            background: linear-gradient(180deg, #2a2f3e, #1a1f2e);
        }
        #resize-handle:hover {
            background: linear-gradient(180deg, #3a3f4e, #1f2738);
        }

        #controls {
            padding: 15px 20px;
            border-bottom: 1px solid #2a2f3e;
        }

        #event-tabs {
            display: flex;
            gap: 10px;
            padding: 10px 20px;
            border-bottom: 1px solid #2a2f3e;
            background: #1a1f2e;
        }

        .tab-btn {
            padding: 8px 16px;
            background: transparent;
            border: none;
            color: #8a8fa5;
            cursor: pointer;
            font-size: 13px;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab-btn:hover {
            color: #fff;
        }

        .tab-btn.active {
            color: #4a90e2;
            border-bottom-color: #4a90e2;
        }

        #event-log {
            flex: 1;
            overflow-y: auto;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }

        .event-item {
            padding: 6px 8px;
            margin-bottom: 4px;
            background: #2a2f3e;
            border-radius: 3px;
            color: #8a8fa5;
            border-left: 3px solid transparent;
            cursor: pointer;
            transition: background 0.2s;
        }

        .event-item:hover {
            background: #3a3f4e;
        }

        .event-item.selected {
            background: #4a4f5e;
            border-left-color: #4a90e2;
        }

        .event-item.kill {
            border-left-color: #ff6b6b;
        }

        .event-item.attack {
            border-left-color: #ffa500;
        }

        .event-item.hit {
            border-left-color: #4a90e2;
        }

        .event-time {
            color: #6b9bd5;
            font-weight: 600;
        }

        .event-player {
            color: #4a90e2;
            font-weight: 500;
        }

        .event-victim {
            color: #ff6b6b;
            font-weight: 500;
        }

        .event-action {
            color: #8a8fa5;
        }

        .event-weapon {
            color: #ffa500;
            font-style: italic;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .play-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #4a90e2;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .play-btn:hover {
            background: #5aa0f2;
        }

        .timeline {
            flex: 1;
            height: 6px;
            background: #2a2f3e;
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }

        .timeline-progress {
            height: 100%;
            background: #4a90e2;
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s;
        }

        .time-display {
            min-width: 100px;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .speed-btn {
            padding: 5px 10px;
            background: #2a2f3e;
            border: 1px solid #3a3f4e;
            color: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
        }

        .speed-btn.active {
            background: #4a90e2;
            border-color: #4a90e2;
        }

        .sidebar-section {
            margin-bottom: 25px;
        }

        .sidebar-section h3 {
            font-size: 12px;
            color: #8a8fa5;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #2a2f3e;
            font-size: 12px;
        }

        .stat-label {
            color: #8a8fa5;
        }

        .stat-value {
            color: #fff;
            font-weight: 500;
        }

        .stat-group {
            margin-bottom: 15px;
        }

        .stat-group-title {
            font-size: 11px;
            color: #6a6f85;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #file-input {
            margin-bottom: 20px;
            padding: 12px;
            background: #2a2f3e;
            border-radius: 6px;
            border: 1px solid #3a3f4e;
        }

        #file-input input[type="file"] {
            color: white;
            font-size: 12px;
        }

        #loading {
            text-align: center;
            padding: 20px;
            color: #8a8fa5;
            font-size: 14px;
        }

        .player-item {
            padding: 8px;
            margin-bottom: 5px;
            background: #2a2f3e;
            border-radius: 4px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-item.ct {
            border-left: 3px solid #5b9bd5;
        }

        .player-item.terrorist {
            border-left: 3px solid #ff6b6b;
        }

        .player-kd {
            font-size: 11px;
            color: #8a8fa5;
        }

        #map-info {
            background: #2a2f3e;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
        }

        #map-info-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        #map-bounds {
            font-size: 11px;
            color: #8a8fa5;
            font-family: 'Courier New', monospace;
        }

        #focus-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(26, 31, 46, 0.95);
            padding: 15px;
            border-radius: 8px;
            display: none;
            z-index: 100;
        }

        #focus-controls.show {
            display: block;
        }

        #focus-controls button {
            padding: 8px 16px;
            background: #4a90e2;
            border: none;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 10px;
        }

        #focus-controls button:hover {
            background: #5aa0f2;
        }

        #focus-info {
            font-size: 12px;
            color: #8a8fa5;
            margin-bottom: 10px;
        }

        /* Kill event picker (top-left of canvas) */
        #event-picker {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(26, 31, 46, 0.95);
            border: 1px solid #2a2f3e;
            border-radius: 8px;
            padding: 10px;
            display: flex;
            gap: 8px;
            align-items: center;
            z-index: 120;
        }

        #event-picker select, #event-picker button {
            background: #2a2f3e;
            border: 1px solid #3a3f4e;
            color: #fff;
            border-radius: 4px;
            padding: 6px 8px;
            font-size: 12px;
        }

        #event-picker button.primary {
            background: #4a90e2;
            border-color: #4a90e2;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="top-nav">
        <div id="brand-logo">
            <img id="brand-image" src="crumb_logo.png" alt="CRUMB Logo" onerror="this.style.display='none'">
            <div id="brand-text">
                <div id="brand-name">CRUMB ‚Äî Combat Replay Unified Monitoring & Behavior-analysis</div>
                <div id="brand-tagline">"Follow every trace." üçû</div>
            </div>
        </div>
        <div class="nav-item active">Info</div>
        <div class="nav-item">3D ÏãúÎÆ¨Î†àÏù¥ÏÖò Î∂ÑÏÑù</div>
        <div class="nav-item" id="report-tab">Î∂ÑÏÑù Î≥¥Í≥†ÏÑú</div>
        <div class="nav-item" id="lang-toggle" style="margin-left: auto; cursor: pointer; padding: 8px 12px; background: #2a2f3e; border-radius: 4px;">üåê EN</div>
    </div>

    <div id="container" style="display: none;">
        <div id="sidebar">
            <div class="sidebar-section">
                <h3>File Load</h3>
                <div id="file-input">
                    <button id="select-csv-btn" style="width: 100%; padding: 10px; background: #4a90e2; color: #fff; border: none; border-radius: 4px; cursor: pointer; margin-bottom: 10px;">ÌååÏùº ÏÑ†ÌÉù</button>
                    <div id="selected-file" style="font-size: 12px; color: #8a8fa5; margin-bottom: 10px;">ÏÑ†ÌÉùÎêú ÌååÏùº ÏóÜÏùå</div>
                    <input type="file" id="csv-file" accept=".csv" style="display: none;" />
                    <div id="loading" style="display: none;">CSV ÌååÏùº Ï≤òÎ¶¨ Ï§ë...</div>
                </div>
            </div>


            

            <div class="sidebar-section">
                <h3>Statistics</h3>
                
                <div class="stat-group">
                    <div class="stat-group-title">Title</div>
                    <div class="stat-item">
                        <span class="stat-label">Name:</span>
                        <span class="stat-value" id="game-name">CS2</span>
                    </div>
                </div>

                <div class="stat-group">
                    <div class="stat-group-title">Game</div>
                    <div class="stat-item">
                        <span class="stat-label">Match ID:</span>
                        <span class="stat-value" id="match-id">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Start time:</span>
                        <span class="stat-value" id="start-time">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Length:</span>
                        <span class="stat-value" id="game-length">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Players:</span>
                        <span class="stat-value" id="total-players">-</span>
                    </div>
                    <div class="stat-item" style="display: none;">
                        <span class="stat-label">Server:</span>
                        <span class="stat-value" id="server-info">-</span>
                    </div>
                    <div class="stat-item" style="display: none;">
                        <span class="stat-label">Game Mode:</span>
                        <span class="stat-value" id="game-mode">-</span>
                    </div>
                </div>

                <div class="stat-group">
                    <div class="stat-group-title">Match</div>
                    <div class="stat-item">
                        <span class="stat-label">Match Start Time:</span>
                        <span class="stat-value" id="match-start-time">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Match Length:</span>
                        <span class="stat-value" id="match-length">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Map Name:</span>
                        <span class="stat-value" id="map-name">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Total Events:</span>
                        <span class="stat-value" id="total-events">-</span>
                    </div>
                    <div class="stat-item" style="display: none;">
                        <span class="stat-label">Match Mode:</span>
                        <span class="stat-value" id="match-mode">-</span>
                    </div>
                </div>

                <div id="map-info">
                    <div id="map-info-title">Map Bounds</div>
                    <div id="map-bounds">Calculating...</div>
                    <div id="map-info-text" style="margin-top: 10px; padding: 10px; background: #1a1f2e; border-radius: 4px; font-size: 11px; color: #8a8fa5;">
                        <div style="margin-bottom: 5px;"><strong id="map-rendering-label">Îßµ Î†åÎçîÎßÅ Ï†ïÎ≥¥:</strong></div>
                        <div id="current-map-text">ÌòÑÏû¨ Îßµ: <span id="detected-map-name">-</span></div>
                        <div id="map-geometry-text" style="margin-top: 5px;">Îßµ ÏßÄÏò§Î©îÌä∏Î¶¨ Îç∞Ïù¥ÌÑ∞Îäî CS2 Í≤åÏûÑ ÌååÏùº(.bsp)ÏóêÏÑú Ï∂îÏ∂úÌïòÍ±∞ÎÇò</div>
                        <div id="map-api-text">Ïô∏Î∂Ä Îßµ Îç∞Ïù¥ÌÑ∞ APIÎ•º ÏÇ¨Ïö©Ìï¥Ïïº Ìï©ÎãàÎã§.</div>
                        <div id="map-note-text" style="margin-top: 5px; color: #4a90e2;">Ï∞∏Í≥†: ÌòÑÏû¨Îäî ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπò Í∏∞Î∞ò Í≤ΩÍ≥ÑÎßå ÌëúÏãúÎê©ÎãàÎã§.</div>
                    </div>
                </div>

                <div class="stat-group">
                    <div class="stat-group-title">Players (K/D Ratio)</div>
                    <div style="font-size: 10px; color: #6a6f85; margin-bottom: 8px; font-style: italic;">
                        K/D: Kills / Deaths - Click to filter
                    </div>
                    <div id="player-list"></div>
                </div>
            </div>
        </div>

        <div id="canvas-container">
            <canvas id="canvas"></canvas>
            <div id="event-picker">
                <select id="kill-select">
                    <option value="">Kill events will appear here</option>
                </select>
                <button id="go-kill" class="primary">Go</button>
                <button id="reset-view">Reset View</button>

                <span style="width:12px"></span>
                <select id="player-select">
                    <option value="">Players</option>
                </select>
                <button id="prev-player-tick">Prev</button>
                <button id="next-player-tick">Next</button>
                <button id="follow-toggle">Follow</button>
            </div>
            <div id="focus-controls">
                <div id="focus-info">Focus Mode: Event selected</div>
                <button id="exit-focus-btn">Exit Focus Mode</button>
            </div>
        </div>
    </div>

    

    <div id="bottom-panel">
        <div id="resize-handle" title="Drag to resize"></div>
        <div id="controls">
            <div class="control-group">
                <button class="play-btn" id="play-btn">‚ñ∂</button>
                <div class="timeline" id="timeline">
                    <div class="timeline-progress" id="timeline-progress"></div>
                </div>
                <div class="time-display" id="time-display">00:00 / 00:00</div>
                <div class="speed-control">
                    <button class="speed-btn" data-speed="0.5">0.5x</button>
                    <button class="speed-btn active" data-speed="1">1x</button>
                    <button class="speed-btn" data-speed="2">2x</button>
                    <button class="speed-btn" data-speed="3">3x</button>
                </div>
            </div>
        </div>

        <div id="event-tabs">
            <button class="tab-btn active" data-tab="actions">Action Stream</button>
            <button class="tab-btn" data-tab="chat">Match Chat</button>
            <button class="tab-btn" data-tab="aim">Aim Trace</button>
        </div>

        <div id="event-log"></div>
    </div>

    <!-- Dashboard View -->
    <div id="dashboard-view" style="display: block;">
        <div id="dashboard-content"></div>
    </div>
    
    <script>
        // ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú Ï¶âÏãú Dashboard ÌëúÏãú Î≥¥Ïû• (ÏµúÏö∞ÏÑ† Ïã§Ìñâ)
        (function() {
            function initDashboard() {
                const dashboardView = document.getElementById('dashboard-view');
                const container = document.getElementById('container');
                const bottomPanel = document.getElementById('bottom-panel');
                const topNav = document.getElementById('top-nav');
                
                // ÏÉÅÎã® ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò Ìï≠ÏÉÅ ÌëúÏãú
                if (topNav) {
                    topNav.style.display = 'flex';
                    topNav.style.visibility = 'visible';
                }
                
                // Dashboard ÌëúÏãú
                if (dashboardView) {
                    dashboardView.style.display = 'block';
                    dashboardView.style.visibility = 'visible';
                    dashboardView.classList.remove('hidden');
                }
                
                // Container Ïà®Í∏∞Í∏∞
                if (container) {
                    container.style.display = 'none';
                    container.style.visibility = 'hidden';
                }
                
                // ÌïòÎã® Ìå®ÎÑê Ïà®Í∏∞Í∏∞
                if (bottomPanel) {
                    bottomPanel.style.display = 'none';
                    bottomPanel.style.visibility = 'hidden';
                }
            }
            
            // Ï¶âÏãú Ïã§Ìñâ
            initDashboard();
            
            // DOM Î°úÎìú ÌõÑÏóêÎèÑ Ïã§Ìñâ
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initDashboard);
            }
            
            // Ï∂îÍ∞Ä Î≥¥Ïû•ÏùÑ ÏúÑÌï¥ ÏïΩÍ∞ÑÏùò ÏßÄÏó∞ ÌõÑ Ïã§Ìñâ
            setTimeout(initDashboard, 100);
        })();
    </script>

    <!-- GitHub CSV ÏÑ†ÌÉù ÌåùÏóÖ -->
    <div id="csv-popup">
        <div id="csv-popup-content">
            <h3>CSV ÌååÏùº ÏÑ†ÌÉù (Ïó¨Îü¨ Í∞ú ÏÑ†ÌÉù Í∞ÄÎä•)</h3>
            
            <!-- GitHub Token ÏûÖÎ†• (Private RepositoryÏö©) -->
            <div id="github-token-section" style="margin-bottom: 15px; padding: 10px; background: #0f1419; border-radius: 4px; border: 1px solid #2a2f3e;">
                <label style="display: block; color: #8a8fa5; font-size: 12px; margin-bottom: 5px;">
                    GitHub Personal Access Token (Private RepositoryÏö©, ÏÑ†ÌÉùÏÇ¨Ìï≠)
                </label>
                <div style="display: flex; gap: 5px;">
                    <input 
                        type="password" 
                        id="github-token-input" 
                        placeholder="ghp_xxxxxxxxxxxxx" 
                        style="flex: 1; padding: 8px; background: #1a1f2e; border: 1px solid #2a2f3e; border-radius: 4px; color: #fff; font-size: 12px;"
                    />
                    <button 
                        id="github-token-save" 
                        style="padding: 8px 12px; background: #4a90e2; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;"
                    >
                        Ï†ÄÏû•
                    </button>
                    <button 
                        id="github-token-clear" 
                        style="padding: 8px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;"
                    >
                        ÏÇ≠Ï†ú
                    </button>
                </div>
                <small style="color: #8a8fa5; font-size: 11px; display: block; margin-top: 5px;">
                    TokenÏùÄ Î∏åÎùºÏö∞Ï†ÄÏóê Ï†ÄÏû•ÎêòÎ©∞, Private repository Ï†ëÍ∑ºÏóêÎßå ÏÇ¨Ïö©Îê©ÎãàÎã§.
                </small>
            </div>
            
            <div id="csv-loading" style="color: #8a8fa5;">ÌååÏùº Î™©Î°ù Î°úÎî© Ï§ë...</div>
            <ul id="csv-file-list"></ul>
            <div style="margin-top: 15px; display: flex; gap: 10px;">
                <button id="csv-load-selected" style="padding: 8px 16px; background: #4a90e2; color: white; border: none; border-radius: 4px; cursor: pointer;">ÏÑ†ÌÉùÌïú ÌååÏùº Î°úÎìú</button>
                <button id="csv-popup-close" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Îã´Í∏∞</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script>
        class CombatSimulation {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                
                this.data = null;
                this.currentTick = 0;
                this.isPlaying = false;
                this.playSpeed = 1;
                
                this.playerObjects = new Map();
                this.playerLabels = new Map();
                this.playerTrails = new Map();
                this.eventMarkers = [];
                this.mapBounds = null;
                this.selectedEvent = null;
                this.focusMode = false;
                this.focusTimeRange = null;
                this.focusTickRange = null;
                this.baseCameraDistance = 1500;
                this.language = 'ko'; // 'ko' or 'en'
                this.currentReportWindow = null; // ÌòÑÏû¨ Ïó¥Î†§ÏûàÎäî Î≥¥Í≥†ÏÑú Ï∞Ω
                this.detectedMapName = null; // Ï∂îÎ°†Îêú Îßµ Ïù¥Î¶Ñ
                this.mapData = null; // Îßµ Îç∞Ïù¥ÌÑ∞ (Ïô∏Î∂ÄÏóêÏÑú Î°úÎìú)
                this.pathLines = null; // Ï£ºÏöî Í≤ΩÎ°ú ÎùºÏù∏
                this.cameraRotationX = 0.3;
                this.cameraRotationY = 0;
                this.cameraDistance = 1500;
                this.killLabels = new Map(); // ÌÇ¨ ÎùºÎ≤® Ï∂îÏ†Å (ÌéòÏù¥ÎìúÏïÑÏõÉÏö©)
                this.playerIndex = new Map(); // name -> [{tick, pos}]
                this.selectedPlayer = null;
                this.mapImagePlane = null; // 2D Îßµ Ïù¥ÎØ∏ÏßÄ ÌèâÎ©¥
                this.mapImageTexture = null; // Îßµ Ïù¥ÎØ∏ÏßÄ ÌÖçÏä§Ï≤ò
                this.mapImageSettings = {
                    imagePath: 'anubis-pro-vs-matchmaking-callouts-v0-k3ix37861a1a1.webp',
                    repeatX: 1,
                    repeatY: 1,
                    offsetX: 0,
                    offsetY: 0,
                    textureRotation: 0,
                    scaleX: 1,
                    scaleZ: 1,
                    worldOffsetX: 0,
                    worldOffsetZ: 0,
                    worldOffsetY: 0,
                    worldRotation: 0
                };
                this.followPlayer = false;
                
                // window.simulationÏóê Ïù∏Ïä§ÌÑ¥Ïä§ Ìï†Îãπ (ÎîîÎ≤ÑÍπÖÏö©)
                window.simulation = this;
                
                this.init();
            }

            init() {
                this.setupScene();
                this.setupControls();
                this.setupFileInput();
                this.setupTabs();
                this.setupResizableBottom();
                this.setupNavigation();
                // Ï¥àÍ∏∞ Î°úÎìú Ïãú Dashboard ÌëúÏãú
                this.showDashboard();
                
                // Îßµ Îç∞Ïù¥ÌÑ∞ Î°úÎìú (ÎπÑÎèôÍ∏∞)
                this.loadMapData();
                this.animate();
            }

            setupFileInput() {
                const selectBtn = document.getElementById('select-csv-btn');
                const inputEl = document.getElementById('csv-file');
                
                if (selectBtn) {
                    selectBtn.addEventListener('click', () => {
                        this.showCSVPopup();
                    });
                }
                
                if (!inputEl) {
                    console.error('ÌååÏùº ÏûÖÎ†• ÏöîÏÜå(#csv-file)Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
                    return;
                }
                // Í∞ôÏùÄ ÌååÏùºÏùÑ Ïó∞ÏÜç ÏÑ†ÌÉùÌï† Îïå change Ïù¥Î≤§Ìä∏Í∞Ä Ïïà Îú®Îäî Î¨∏Ï†ú Î∞©ÏßÄ
                inputEl.addEventListener('click', () => {
                    inputEl.value = '';
                });
                inputEl.addEventListener('change', (e) => {
                    const file = e.target.files && e.target.files[0];
                    const loading = document.getElementById('loading');
                    if (loading) {
                        loading.style.display = 'block';
                        loading.innerHTML = 'Parsing CSV file...';
                    }
                    if (file) {
                        console.log('CSV ÌååÏùº ÏÑ†ÌÉùÎê®:', file.name, file.size, 'bytes');
                        document.getElementById('selected-file').textContent = file.name;
                        this.loadCSV(file);
                    } else {
                        console.warn('ÏÑ†ÌÉùÎêú ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.');
                        if (loading) loading.style.display = 'none';
                    }
                });

                // Îßµ Ïù¥ÎØ∏ÏßÄ ÏûêÎèô Î°úÎìú (POC: anubis ÌîÑÎ°úÎßµ)
                // setupMapImageInputÏùÄ Ï†úÍ±∞Îê® (POCÏóêÏÑúÎäî ÏûêÎèô Î°úÎìú)

                // ÌåùÏóÖ Îã´Í∏∞ Î≤ÑÌäº
                const closeBtn = document.getElementById('csv-popup-close');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => {
                        document.getElementById('csv-popup').classList.remove('active');
                    });
                }
                
                // GitHub Token Í¥ÄÎ¶¨
                this.setupGitHubToken();
            }
            
            setupGitHubToken() {
                const tokenInput = document.getElementById('github-token-input');
                const saveBtn = document.getElementById('github-token-save');
                const clearBtn = document.getElementById('github-token-clear');
                
                // Ï†ÄÏû•Îêú Token Î∂àÎü¨Ïò§Í∏∞
                const savedToken = localStorage.getItem('github_pat_token');
                if (savedToken && tokenInput) {
                    tokenInput.value = savedToken;
                }
                
                // Ï†ÄÏû• Î≤ÑÌäº
                if (saveBtn) {
                    saveBtn.addEventListener('click', () => {
                        const token = tokenInput ? tokenInput.value.trim() : '';
                        if (token) {
                            localStorage.setItem('github_pat_token', token);
                            alert('TokenÏù¥ Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.');
                        } else {
                            alert('TokenÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
                        }
                    });
                }
                
                // ÏÇ≠Ï†ú Î≤ÑÌäº
                if (clearBtn) {
                    clearBtn.addEventListener('click', () => {
                        if (tokenInput) tokenInput.value = '';
                        localStorage.removeItem('github_pat_token');
                        alert('TokenÏù¥ ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.');
                    });
                }
            }
            
            getGitHubToken() {
                return localStorage.getItem('github_pat_token') || null;
            }

            setupNavigation() {
                const navItems = document.querySelectorAll('.nav-item');
                navItems.forEach(item => {
                    item.addEventListener('click', () => {
                        const text = item.textContent.trim();
                        if (text === 'Info') {
                            this.showDashboard();
                        } else if (text === '3D ÏãúÎÆ¨Î†àÏù¥ÏÖò Î∂ÑÏÑù') {
                            this.showInvestigate();
                        } else {
                            // Îã§Î•∏ ÌÉ≠Îì§ÏùÄ ÎÇòÏ§ëÏóê Íµ¨ÌòÑ
                            navItems.forEach(n => n.classList.remove('active'));
                            item.classList.add('active');
                        }
                    });
                });
            }

            showDashboard() {
                document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                document.querySelectorAll('.nav-item').forEach(n => {
                    if (n.textContent.trim() === 'Info') n.classList.add('active');
                });
                
                const dashboardView = document.getElementById('dashboard-view');
                const container = document.getElementById('container');
                const bottomPanel = document.getElementById('bottom-panel');
                
                if (dashboardView && container) {
                    container.style.display = 'none';
                    dashboardView.classList.remove('hidden');
                    // ÌïòÎã® Ìå®ÎÑê Ïà®Í∏∞Í∏∞
                    if (bottomPanel) {
                        bottomPanel.style.display = 'none';
                    }
                    this.renderDashboard();
                }
            }

            showInvestigate() {
                document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                document.querySelectorAll('.nav-item').forEach(n => {
                    if (n.textContent.trim() === '3D ÏãúÎÆ¨Î†àÏù¥ÏÖò Î∂ÑÏÑù') n.classList.add('active');
                });
                
                const dashboardView = document.getElementById('dashboard-view');
                const container = document.getElementById('container');
                const bottomPanel = document.getElementById('bottom-panel');
                
                // Dashboard Ïà®Í∏∞Í∏∞
                if (dashboardView) {
                    dashboardView.style.display = 'none';
                    dashboardView.style.visibility = 'hidden';
                    dashboardView.classList.add('hidden');
                }
                
                // Container ÌëúÏãú
                if (container) {
                    container.style.display = 'flex';
                    container.style.visibility = 'visible';
                    
                    // ÌïòÎã® Ìå®ÎÑê Îã§Ïãú ÌëúÏãú
                    if (bottomPanel) {
                        bottomPanel.style.display = 'flex';
                        bottomPanel.style.visibility = 'visible';
                    }
                    
                    // Canvas Ïª®ÌÖåÏù¥ÎÑàÍ∞Ä Î≥¥Ïù¥ÎèÑÎ°ù Î≥¥Ïû•
                    const canvasContainer = document.getElementById('canvas-container');
                    if (canvasContainer) {
                        canvasContainer.style.display = 'block';
                        canvasContainer.style.visibility = 'visible';
                    }
                    
                    // Renderer ÌÅ¨Í∏∞ Ïû¨Ï°∞Ï†ï
                    if (this.renderer) {
                        setTimeout(() => {
                            const width = canvasContainer ? canvasContainer.clientWidth : 800;
                            const height = canvasContainer ? canvasContainer.clientHeight : 600;
                            if (width > 0 && height > 0) {
                                this.camera.aspect = width / height;
                                this.camera.updateProjectionMatrix();
                                this.renderer.setSize(width, height);
                            }
                        }, 100);
                    }
                }
            }

            async renderDashboard() {
                const content = document.getElementById('dashboard-content');
                if (!content) return;

                // Î∏åÎûúÎìú Ìó§Îçî Ï∂îÍ∞Ä
                const brandHeader = `
                    <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 40px; padding-bottom: 20px; border-bottom: 2px solid #2a2f3e;">
                        <img src="crumb_logo.png" alt="CRUMB Logo" onerror="this.style.display='none'" style="height: 64px; width: auto; object-fit: contain;">
                        <div>
                            <h1 style="margin: 0; font-size: 28px; color: #fff; font-weight: 600; letter-spacing: 0.5px;">CRUMB ‚Äî Combat Replay Unified Monitoring & Behavior-analysis</h1>
                            <p style="margin: 8px 0 0 0; font-size: 14px; color: #8a8fa5; font-style: italic;">"Follow every trace." üçû</p>
                        </div>
                    </div>
                `;

                // README ÎÇ¥Ïö©ÏùÑ HTMLÎ°ú Î≥ÄÌôò (Ïñ∏Ïñ¥Î≥Ñ)
                const readmeContents = {
                    ko: `FPS Ï†ÑÌà¨ ÍµêÏ†Ñ ÏÉÅÌô©ÏùÑ 3DÎ°ú ÏãúÎÆ¨Î†àÏù¥ÏÖòÌïòÍ≥† Î∂ÑÏÑùÌïòÎäî Ïõπ ÌîåÎû´ÌèºÏûÖÎãàÎã§.

---

## üöÄ Îπ†Î•∏ ÏãúÏûë

1. **3D ÏãúÎÆ¨Î†àÏù¥ÏÖò Î∂ÑÏÑù** ÌÉ≠ ÌÅ¥Î¶≠
2. Ï¢åÏ∏° ÏÇ¨Ïù¥ÎìúÎ∞î **"ÌååÏùº ÏÑ†ÌÉù"** Î≤ÑÌäº ÌÅ¥Î¶≠
3. GitHub CSV ÌååÏùº ÏÑ†ÌÉù
4. 3D ÏãúÎÆ¨Î†àÏù¥ÏÖò ÏûêÎèô ÏãúÏûë

---

## üéØ Ï£ºÏöî Í∏∞Îä•

- **3D ÏãúÍ∞ÅÌôî**: ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπò, ÌÇ¨ Ïù¥Î≤§Ìä∏, Ïù¥Îèô Í≤ΩÎ°ú
- **Ïù∏ÌÑ∞ÎûôÌã∞Î∏å Ïª®Ìä∏Î°§**: Ïπ¥Î©îÎùº ÌöåÏ†Ñ/Ï§å, Ïû¨ÏÉù/ÏùºÏãúÏ†ïÏßÄ, ÏÜçÎèÑ Ï°∞Ï†à
- **ÌîåÎ†àÏù¥Ïñ¥ Ï∂îÏ†Å**: Follow Î™®Îìú, K/D Ratio, ÏãúÏ†ê Ïù¥Îèô
- **Aim Trace**: Ï°∞Ï§Ä Í∂§Ï†Å ÏãúÍ∞ÅÌôî, ÏóêÏûÑÎ¥á ÌÉêÏßÄ

---

## üéÆ Ïª®Ìä∏Î°§

| ÏûÖÎ†• | ÎèôÏûë |
|------|------|
| ÎßàÏö∞Ïä§ ÎìúÎûòÍ∑∏ | Ïπ¥Î©îÎùº ÌöåÏ†Ñ |
| ÎßàÏö∞Ïä§ Ìú† | Ï§å Ïù∏/ÏïÑÏõÉ |
| Ïû¨ÏÉù Î≤ÑÌäº | ÏãúÏûë/ÏùºÏãúÏ†ïÏßÄ |
| ÌÉÄÏûÑÎùºÏù∏ ÌÅ¥Î¶≠ | ÏãúÏ†ê Ïù¥Îèô |
| ÏÜçÎèÑ Î≤ÑÌäº | 0.5x ~ 3x |

---

## üîß Í∏∞Ïà† Ïä§ÌÉù

Three.js ¬∑ PapaParse ¬∑ ÏàúÏàò JavaScript`,
                    en: `A web platform for 3D simulation and analysis of FPS combat engagement situations.

---

## üöÄ Quick Start

1. Click **3D Simulation Analysis** tab
2. Click **"Select File"** button in the left sidebar
3. Select GitHub CSV file
4. 3D simulation starts automatically

---

## üéØ Key Features

- **3D Visualization**: Player positions, kill events, movement paths
- **Interactive Controls**: Camera rotation/zoom, play/pause, speed adjustment
- **Player Tracking**: Follow mode, K/D Ratio, viewpoint movement
- **Aim Trace**: Aim trajectory visualization, aimbot detection

---

## üéÆ Controls

| Input | Action |
|------|------|
| Mouse Drag | Camera Rotation |
| Mouse Wheel | Zoom In/Out |
| Play Button | Start/Pause |
| Timeline Click | Seek Position |
| Speed Button | 0.5x ~ 3x |

---

## üîß Tech Stack

Three.js ¬∑ PapaParse ¬∑ Pure JavaScript`
                };
                
                const readmeContent = readmeContents[this.language] || readmeContents.ko;

                // Í∞ÑÎã®Ìïú ÎßàÌÅ¨Îã§Ïö¥ ÌååÏÑú (Í∏∞Î≥∏Ï†ÅÏù∏ Î≥ÄÌôò)
                content.innerHTML = brandHeader + this.markdownToHTML(readmeContent);
            }

            markdownToHTML(markdown) {
                let html = markdown;
                
                // Ìó§ÎçîÏóê ID Ï∂îÍ∞ÄÎ•º ÏúÑÌïú Ìó¨Ìçº Ìï®Ïàò
                const createId = (text) => {
                    return text.toLowerCase()
                        .replace(/[^\w\u3131-\u318E\uAC00-\uD7A3]+/g, '-')
                        .replace(/^-+|-+$/g, '');
                };
                
                // ÎßÅÌÅ¨ Î≥ÄÌôò (Ìó§Îçî Î≥ÄÌôò Ï†ÑÏóê Ï≤òÎ¶¨)
                html = html.replace(/\[([^\]]+)\]\(#([^\)]+)\)/g, (match, text, anchor) => {
                    return `<a href="#${anchor}" style="color: #4a90e2; text-decoration: none; border-bottom: 1px solid #4a90e2;">${text}</a>`;
                });
                
                // Ìó§Îçî Î≥ÄÌôò (ID Ìè¨Ìï®) - ÏàúÏÑú Ï§ëÏöî: h4 -> h3 -> h2 -> h1
                html = html.replace(/^#### (.*$)/gim, (match, text) => {
                    const id = createId(text);
                    return `<h4 id="${id}">${text}</h4>`;
                });
                html = html.replace(/^### (.*$)/gim, (match, text) => {
                    const id = createId(text);
                    return `<h3 id="${id}">${text}</h3>`;
                });
                html = html.replace(/^## (.*$)/gim, (match, text) => {
                    const id = createId(text);
                    return `<h2 id="${id}">${text}</h2>`;
                });
                html = html.replace(/^# (.*$)/gim, (match, text) => {
                    const id = createId(text);
                    return `<h1 id="${id}">${text}</h1>`;
                });
                
                // Î≥ºÎìúÏ≤¥ Î≥ÄÌôò (**ÌÖçÏä§Ìä∏**)
                html = html.replace(/\*\*([^\*]+)\*\*/g, '<strong>$1</strong>');
                
                // ÏΩîÎìú Î∏îÎ°ù
                html = html.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>');
                html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
                
                // Î¶¨Ïä§Ìä∏
                html = html.replace(/^- (.*$)/gim, '<li>$1</li>');
                html = html.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
                
                // ÌÖåÏù¥Î∏î (Í∞ÑÎã®Ìïú Ï≤òÎ¶¨)
                html = html.replace(/\|(.+)\|/g, (match) => {
                    const cells = match.split('|').filter(c => c.trim());
                    if (cells.length > 0) {
                        return '<tr>' + cells.map(c => '<td>' + c.trim() + '</td>').join('') + '</tr>';
                    }
                    return match;
                });
                
                // Î¶¨Ïä§Ìä∏ Ìï≠Î™© ÏÇ¨Ïù¥Ïùò Ï§ÑÎ∞îÍøà Ï†úÍ±∞ (Î¶¨Ïä§Ìä∏ ÎÇ¥Î∂Ä <br> Ï†úÍ±∞)
                html = html.replace(/<\/li>\s*<br>\s*<li>/gi, '</li><li>');
                html = html.replace(/<ul>\s*<br>/gi, '<ul>');
                html = html.replace(/<br>\s*<\/ul>/gi, '</ul>');
                
                // Îã®ÎùΩ
                html = html.replace(/\n\n/g, '</p><p>');
                html = '<p>' + html + '</p>';
                
                // Ï§ÑÎ∞îÍøà (Î¶¨Ïä§Ìä∏ ÎÇ¥Î∂ÄÎäî Ïù¥ÎØ∏ Ï≤òÎ¶¨Îê®)
                html = html.replace(/\n/g, '<br>');
                
                // ÏïµÏª§ ÎßÅÌÅ¨ ÌÅ¥Î¶≠ Ïãú DashboardÎ°ú Ïù¥ÎèôÌïòÍ≥† Î∂ÄÎìúÎü¨Ïö¥ Ïä§ÌÅ¨Î°§
                setTimeout(() => {
                    document.querySelectorAll('#dashboard-content a[href^="#"]').forEach(link => {
                        link.addEventListener('click', (e) => {
                            e.preventDefault();
                            
                            // DashboardÍ∞Ä Ïó¥Î†§ÏûàÏßÄ ÏïäÏúºÎ©¥ DashboardÎ°ú Ïù¥Îèô
                            const dashboardView = document.getElementById('dashboard-view');
                            const container = document.getElementById('container');
                            if (dashboardView && !dashboardView.classList.contains('active')) {
                                // Info ÌÉ≠ ÌôúÏÑ±Ìôî
                                document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                                document.querySelectorAll('.nav-item').forEach(n => {
                                    if (n.textContent.trim() === 'Info') n.classList.add('active');
                                });
                                
                                // Dashboard Î∑∞ ÌëúÏãú
                                if (container) {
                                    container.style.display = 'none';
                                }
                                dashboardView.classList.add('active');
                                
                                // ÌïòÎã® Ìå®ÎÑê Ïà®Í∏∞Í∏∞
                                const bottomPanel = document.getElementById('bottom-panel');
                                if (bottomPanel) {
                                    bottomPanel.style.display = 'none';
                                }
                            }
                            
                            // Ìï¥Îãπ ÏÑπÏÖòÏúºÎ°ú Ïä§ÌÅ¨Î°§
                            const targetId = link.getAttribute('href').substring(1);
                            setTimeout(() => {
                                const targetElement = document.getElementById(targetId);
                                if (targetElement) {
                                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                }
                            }, dashboardView && !dashboardView.classList.contains('active') ? 200 : 0);
                        });
                    });
                }, 100);
                
                return html;
            }

            async showCSVPopup() {
                const popup = document.getElementById('csv-popup');
                const fileList = document.getElementById('csv-file-list');
                const loading = document.getElementById('csv-loading');
                
                if (!popup || !fileList) return;
                
                popup.classList.add('active');
                fileList.innerHTML = '';
                loading.style.display = 'block';
                
                try {
                    // GitHub APIÎ°ú CSV ÌååÏùº Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞
                    const repo = 'bangilhan/tt_combat_simulation_data';
                    const apiUrl = `https://api.github.com/repos/${repo}/contents`;
                    console.log('GitHub API Ìò∏Ï∂ú:', apiUrl);
                    
                    // Token Í∞ÄÏ†∏Ïò§Í∏∞
                    const token = this.getGitHubToken();
                    const headers = {};
                    if (token) {
                        headers['Authorization'] = `token ${token}`;
                        console.log('Private repository Ï†ëÍ∑º (Token ÏÇ¨Ïö©)');
                    } else {
                        console.log('Public repository Ï†ëÍ∑º ÏãúÎèÑ');
                    }
                    
                    const response = await fetch(apiUrl, {
                        headers: headers
                    });
                    
                    // ÏùëÎãµ ÏÉÅÌÉú ÌôïÏù∏
                    if (!response.ok) {
                        if (response.status === 404) {
                            loading.style.display = 'none';
                            fileList.innerHTML = `
                                <li style="color: #ff6b6b; padding: 10px;">
                                    <strong>RepositoryÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.</strong><br>
                                    <small style="color: #8a8fa5;">
                                        Repository Ïù¥Î¶Ñ: ${repo}<br>
                                        ÌôïÏù∏ ÏÇ¨Ìï≠:<br>
                                        1. RepositoryÍ∞Ä ÏÉùÏÑ±ÎêòÏóàÎäîÏßÄ ÌôïÏù∏<br>
                                        2. Repository Ïù¥Î¶ÑÏù¥ Ï†ïÌôïÌïúÏßÄ ÌôïÏù∏<br>
                                        3. RepositoryÍ∞Ä PublicÏù∏ÏßÄ ÌôïÏù∏ (PrivateÏùÄ Ïù∏Ï¶ù ÌïÑÏöî)
                                    </small>
                                </li>
                            `;
                            console.error('RepositoryÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå:', response.status, response.statusText);
                            return;
                        } else if (response.status === 403) {
                            loading.style.display = 'none';
                            fileList.innerHTML = `
                                <li style="color: #ff6b6b; padding: 10px;">
                                    <strong>Ï†ëÍ∑º Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§.</strong><br>
                                    <small style="color: #8a8fa5;">
                                        RepositoryÍ∞Ä PrivateÏù¥Í±∞ÎÇò API rate limitÏóê ÎèÑÎã¨ÌñàÏùÑ Ïàò ÏûàÏäµÎãàÎã§.
                                    </small>
                                </li>
                            `;
                            console.error('Ï†ëÍ∑º Í∂åÌïú ÏóÜÏùå:', response.status, response.statusText);
                            return;
                        } else {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                    }
                    
                    const files = await response.json();
                    console.log('GitHub API ÏùëÎãµ:', files);
                    
                    // ÏùëÎãµÏù¥ Î∞∞Ïó¥Ïù¥ ÏïÑÎãå Í≤ΩÏö∞ (ÏóêÎü¨ Î©îÏãúÏßÄ Îì±)
                    if (!Array.isArray(files)) {
                        loading.style.display = 'none';
                        fileList.innerHTML = `
                            <li style="color: #ff6b6b; padding: 10px;">
                                <strong>ÏòàÏÉÅÏπò Î™ªÌïú ÏùëÎãµ:</strong><br>
                                <small style="color: #8a8fa5;">${JSON.stringify(files)}</small>
                            </li>
                        `;
                        console.error('ÏòàÏÉÅÏπò Î™ªÌïú ÏùëÎãµ ÌòïÏãù:', files);
                        return;
                    }
                    
                    // CSV ÌååÏùºÎßå ÌïÑÌÑ∞ÎßÅ
                    let csvFiles = files.filter(file => 
                        file.type === 'file' && file.name.endsWith('.csv')
                    );
                    
                    // tt_aimbot_detection_data.csvÎ•º Ïö∞ÏÑ†ÏàúÏúÑÎ°ú Ï†ïÎ†¨
                    csvFiles.sort((a, b) => {
                        const aIsMain = a.name.includes('tt_aimbot_detection_data');
                        const bIsMain = b.name.includes('tt_aimbot_detection_data');
                        if (aIsMain && !bIsMain) return -1;
                        if (!aIsMain && bIsMain) return 1;
                        // sample ÌååÏùºÏùÄ Îí§Î°ú
                        const aIsSample = a.name.includes('sample');
                        const bIsSample = b.name.includes('sample');
                        if (aIsSample && !bIsSample) return 1;
                        if (!aIsSample && bIsSample) return -1;
                        return a.name.localeCompare(b.name);
                    });
                    
                    console.log('CSV ÌååÏùº Ïàò:', csvFiles.length);
                    console.log('Ï†ïÎ†¨Îêú ÌååÏùº Î™©Î°ù:', csvFiles.map(f => f.name));
                    
                    loading.style.display = 'none';
                    
                    if (csvFiles.length === 0) {
                        if (files.length === 0) {
                            fileList.innerHTML = `
                                <li style="color: #8a8fa5; padding: 10px;">
                                    RepositoryÍ∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§.<br>
                                    <small>CSV ÌååÏùºÏùÑ ÏóÖÎ°úÎìúÌï¥Ï£ºÏÑ∏Ïöî.</small>
                                </li>
                            `;
                        } else {
                            fileList.innerHTML = `
                                <li style="color: #8a8fa5; padding: 10px;">
                                    CSV ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.<br>
                                    <small>RepositoryÏóê ${files.length}Í∞úÏùò ÌååÏùºÏù¥ ÏûàÏßÄÎßå CSV ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.</small>
                                </li>
                            `;
                        }
                        return;
                    }
                    
                    // ÏÑ†ÌÉùÎêú ÌååÏùºÎì§ÏùÑ Ï∂îÏ†ÅÌïòÍ∏∞ ÏúÑÌïú Set
                    this.selectedCSVFiles = new Set();
                    
                    csvFiles.forEach(file => {
                        const li = document.createElement('li');
                        li.style.display = 'flex';
                        li.style.alignItems = 'center';
                        li.style.gap = '10px';
                        li.style.padding = '8px';
                        li.style.cursor = 'pointer';
                        li.style.borderRadius = '4px';
                        li.addEventListener('mouseenter', () => {
                            li.style.background = '#2a2f3e';
                        });
                        li.addEventListener('mouseleave', () => {
                            li.style.background = 'transparent';
                        });
                        
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.value = file.download_url;
                        checkbox.dataset.filename = file.name;
                        checkbox.style.cursor = 'pointer';
                        checkbox.addEventListener('change', (e) => {
                            if (e.target.checked) {
                                this.selectedCSVFiles.add(file.download_url);
                            } else {
                                this.selectedCSVFiles.delete(file.download_url);
                            }
                        });
                        
                        const label = document.createElement('label');
                        label.textContent = file.name;
                        label.style.cursor = 'pointer';
                        label.style.flex = '1';
                        label.addEventListener('click', (e) => {
                            e.preventDefault();
                            checkbox.checked = !checkbox.checked;
                            checkbox.dispatchEvent(new Event('change'));
                        });
                        
                        li.appendChild(checkbox);
                        li.appendChild(label);
                        fileList.appendChild(li);
                    });
                    
                    // ÏÑ†ÌÉùÌïú ÌååÏùº Î°úÎìú Î≤ÑÌäº Ïù¥Î≤§Ìä∏
                    const loadBtn = document.getElementById('csv-load-selected');
                    if (loadBtn) {
                        loadBtn.onclick = () => {
                            if (this.selectedCSVFiles.size === 0) {
                                alert('ÌååÏùºÏùÑ ÌïòÎÇò Ïù¥ÏÉÅ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
                                return;
                            }
                            this.loadMultipleCSVFiles();
                            popup.classList.remove('active');
                        };
                    }
                } catch (error) {
                    console.error('GitHub ÌååÏùº Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®:', error);
                    loading.style.display = 'none';
                    fileList.innerHTML = `
                        <li style="color: #ff6b6b; padding: 10px;">
                            <strong>Ïò§Î•ò Î∞úÏÉù:</strong><br>
                            <small style="color: #8a8fa5;">${error.message || error}</small><br>
                            <small style="color: #8a8fa5; margin-top: 5px; display: block;">
                                ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Í≤∞ÏùÑ ÌôïÏù∏ÌïòÍ±∞ÎÇò Î∏åÎùºÏö∞Ï†Ä ÏΩòÏÜîÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.
                            </small>
                        </li>
                    `;
                }
            }
            
            async loadMultipleCSVFiles() {
                const loading = document.getElementById('loading');
                const selectedFile = document.getElementById('selected-file');
                
                if (!this.selectedCSVFiles || this.selectedCSVFiles.size === 0) {
                    alert('ÌååÏùºÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
                    return;
                }
                
                const fileUrls = Array.from(this.selectedCSVFiles);
                const fileCount = fileUrls.length;
                
                if (loading) {
                    loading.style.display = 'block';
                    loading.innerHTML = `GitHubÏóêÏÑú ${fileCount}Í∞ú CSV ÌååÏùº Îã§Ïö¥Î°úÎìú Ï§ë...`;
                }
                
                if (selectedFile) {
                    selectedFile.textContent = `${fileCount}Í∞ú ÌååÏùº ÏÑ†ÌÉùÎê®`;
                }
                
                try {
                    // Token Í∞ÄÏ†∏Ïò§Í∏∞
                    const token = this.getGitHubToken();
                    const headers = {};
                    if (token) {
                        headers['Authorization'] = `token ${token}`;
                    }
                    
                    // Î™®Îì† ÌååÏùºÏùÑ Î≥ëÎ†¨Î°ú Îã§Ïö¥Î°úÎìú
                    const filePromises = fileUrls.map(async (url) => {
                        const response = await fetch(url, {
                            headers: headers
                        });
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const text = await response.text();
                        const filename = url.split('/').pop() || 'unknown.csv';
                        const blob = new Blob([text], { type: 'text/csv' });
                        return new File([blob], filename, { type: 'text/csv' });
                    });
                    
                    const files = await Promise.all(filePromises);
                    
                    // Î™®Îì† ÌååÏùºÏùò Îç∞Ïù¥ÌÑ∞Î•º Î≥ëÌï©
                    await this.loadAndMergeMultipleCSV(files);
                } catch (error) {
                    console.error('CSV ÌååÏùº Îã§Ïö¥Î°úÎìú Ïã§Ìå®:', error);
                    if (loading) {
                        loading.innerHTML = 'Ïò§Î•ò: ' + error.message;
                    }
                    alert('CSV ÌååÏùºÏùÑ Îã§Ïö¥Î°úÎìúÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + error.message);
                }
            }
            
            async loadAndMergeMultipleCSV(files) {
                const loading = document.getElementById('loading');
                const allRows = [];
                
                try {
                    // Î™®Îì† ÌååÏùºÏùÑ ÏàúÏ∞®Ï†ÅÏúºÎ°ú ÌååÏã±
                    for (let i = 0; i < files.length; i++) {
                        if (loading) {
                            loading.innerHTML = `ÌååÏùº ÌååÏã± Ï§ë... (${i + 1}/${files.length})`;
                        }
                        
                        const file = files[i];
                        const rows = await new Promise((resolve, reject) => {
                            Papa.parse(file, {
                                header: true,
                                skipEmptyLines: true,
                                complete: (results) => {
                                    resolve(results.data);
                                },
                                error: (error) => {
                                    reject(error);
                                }
                            });
                        });
                        
                        allRows.push(...rows);
                    }
                    
                    if (loading) {
                        loading.innerHTML = 'Îç∞Ïù¥ÌÑ∞ Î≥ëÌï© Î∞è Ï≤òÎ¶¨ Ï§ë...';
                    }
                    
                    // Î™®Îì† Îç∞Ïù¥ÌÑ∞Î•º Î≥ëÌï©ÌïòÏó¨ Ï≤òÎ¶¨
                    await this.processData(allRows);
                } catch (error) {
                    console.error('CSV ÌååÏùº Î≥ëÌï© Ïã§Ìå®:', error);
                    if (loading) {
                        loading.innerHTML = 'Ïò§Î•ò: ' + error.message;
                    }
                    alert('CSV ÌååÏùºÏùÑ Ï≤òÎ¶¨ÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + error.message);
                }
            }

            async loadCSVFromGitHub(url, filename) {
                const loading = document.getElementById('loading');
                const selectedFile = document.getElementById('selected-file');
                
                if (loading) {
                    loading.style.display = 'block';
                    loading.innerHTML = 'GitHubÏóêÏÑú CSV ÌååÏùº Îã§Ïö¥Î°úÎìú Ï§ë...';
                }
                
                if (selectedFile) {
                    selectedFile.textContent = filename;
                }
                
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const text = await response.text();
                    
                    // ÌÖçÏä§Ìä∏Î•º BlobÏúºÎ°ú Î≥ÄÌôòÌïòÏó¨ File Í∞ùÏ≤¥Ï≤òÎüº ÏÇ¨Ïö©
                    const blob = new Blob([text], { type: 'text/csv' });
                    const file = new File([blob], filename, { type: 'text/csv' });
                    
                    await this.loadCSV(file);
                } catch (error) {
                    console.error('CSV ÌååÏùº Îã§Ïö¥Î°úÎìú Ïã§Ìå®:', error);
                    if (loading) {
                        loading.innerHTML = 'Ïò§Î•ò: ' + error.message;
                    }
                    alert('CSV ÌååÏùºÏùÑ Îã§Ïö¥Î°úÎìúÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + error.message);
                }
            }

            setupTabs() {
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        // ÌÉ≠ Ï†ÑÌôò
                        const tab = btn.getAttribute('data-tab');
                        if (tab === 'aim') {
                            this.renderAimTrace();
                        } else if (tab === 'actions') {
                            this.updateEventLog();
                        } else {
                            // chat placeholder
                            const eventLog = document.getElementById('event-log');
                            eventLog.innerHTML = '<div style="padding:10px;color:#8a8fa5;">Chat view TBD</div>';
                        }
                    });
                });

                // Ìè¨Ïª§Ïä§ Î™®Îìú Ï¢ÖÎ£å Î≤ÑÌäº
                document.getElementById('exit-focus-btn').addEventListener('click', () => {
                    this.exitFocusMode();
                });
                
                // Î≥¥Í≥†ÏÑú ÏÉùÏÑ± ÌÉ≠
                document.getElementById('report-tab').addEventListener('click', () => {
                    const playerName = this.selectedPlayer || (this.selectedEvent && this.selectedEvent.attacker && this.selectedEvent.attacker.name) || 
                                    ((this.data && this.data.metadata && this.data.metadata.players && this.data.metadata.players[0]) || null);
                    if (playerName) {
                        this.generateReport(playerName);
                    } else {
                        alert(this.language === 'ko' ? 'Î®ºÏ†Ä ÌîåÎ†àÏù¥Ïñ¥Î•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî' : 'Please select a player first');
                    }
                });
                
                // Ïñ∏Ïñ¥ Ï†ÑÌôò Î≤ÑÌäº
                document.getElementById('lang-toggle').addEventListener('click', () => {
                    this.language = this.language === 'ko' ? 'en' : 'ko';
                    this.updateLanguage();
                });
                
                // Ïñ∏Ïñ¥ ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
                this.updateLanguage = () => {
                    const langToggle = document.getElementById('lang-toggle');
                    langToggle.textContent = this.language === 'ko' ? 'üåê EN' : 'üåê KO';
                    
                    // UI ÌÖçÏä§Ìä∏ Ï†ïÏùò
                    const uiTexts = {
                        ko: {
                            navInfo: 'Info',
                            navSimulation: '3D ÏãúÎÆ¨Î†àÏù¥ÏÖò Î∂ÑÏÑù',
                            navReport: 'Î∂ÑÏÑù Î≥¥Í≥†ÏÑú',
                            fileLoad: 'ÌååÏùº Î°úÎìú',
                            selectFile: 'ÌååÏùº ÏÑ†ÌÉù',
                            noFileSelected: 'ÏÑ†ÌÉùÎêú ÌååÏùº ÏóÜÏùå',
                            processing: 'CSV ÌååÏùº Ï≤òÎ¶¨ Ï§ë...',
                            statistics: 'ÌÜµÍ≥Ñ',
                            title: 'Ï†úÎ™©',
                            name: 'Ïù¥Î¶Ñ',
                            game: 'Í≤åÏûÑ',
                            server: 'ÏÑúÎ≤Ñ',
                            gameMode: 'Í≤åÏûÑ Î™®Îìú',
                            startTime: 'ÏãúÏûë ÏãúÍ∞Ñ',
                            length: 'Í∏∏Ïù¥',
                            players: 'ÌîåÎ†àÏù¥Ïñ¥',
                            match: 'Îß§Ïπò',
                            matchStartTime: 'Îß§Ïπò ÏãúÏûë ÏãúÍ∞Ñ',
                            matchLength: 'Îß§Ïπò Í∏∏Ïù¥',
                            matchMode: 'Îß§Ïπò Î™®Îìú',
                            mapName: 'Îßµ Ïù¥Î¶Ñ',
                            totalEvents: 'Ï¥ù Ïù¥Î≤§Ìä∏',
                            mapBounds: 'Îßµ Í≤ΩÍ≥Ñ',
                            calculating: 'Í≥ÑÏÇ∞ Ï§ë...',
                            mapRendering: 'Îßµ Î†åÎçîÎßÅ Ï†ïÎ≥¥',
                            currentMap: 'ÌòÑÏû¨ Îßµ',
                            note: 'Ï∞∏Í≥†',
                            mapGeometry: 'Îßµ ÏßÄÏò§Î©îÌä∏Î¶¨',
                            mapApi: 'Ïô∏Î∂Ä Îßµ Îç∞Ïù¥ÌÑ∞',
                            kdRatio: 'K/D ÎπÑÏú®',
                            kdDesc: 'K/D: ÌÇ¨ / Îç∞Ïä§ - ÌÅ¥Î¶≠ÌïòÏó¨ ÌïÑÌÑ∞ÎßÅ',
                            killEvents: 'ÌÇ¨ Ïù¥Î≤§Ìä∏Í∞Ä Ïó¨Í∏∞Ïóê ÌëúÏãúÎê©ÎãàÎã§',
                            go: 'Ïù¥Îèô',
                            resetView: 'Î∑∞ Ï¥àÍ∏∞Ìôî',
                            prev: 'Ïù¥Ï†Ñ',
                            next: 'Îã§Ïùå',
                            follow: 'Îî∞ÎùºÍ∞ÄÍ∏∞',
                            focusMode: 'Ìè¨Ïª§Ïä§ Î™®Îìú: Ïù¥Î≤§Ìä∏ ÏÑ†ÌÉùÎê®',
                            exitFocus: 'Ìè¨Ïª§Ïä§ Î™®Îìú Ï¢ÖÎ£å',
                            actionStream: 'Ïï°ÏÖò Ïä§Ìä∏Î¶º',
                            matchChat: 'Îß§Ïπò Ï±ÑÌåÖ',
                            aimTrace: 'ÏóêÏûÑ Ìä∏Î†àÏù¥Ïä§'
                        },
                        en: {
                            navInfo: 'Info',
                            navSimulation: '3D Simulation Analysis',
                            navReport: 'Analysis Report',
                            fileLoad: 'File Load',
                            selectFile: 'Select File',
                            noFileSelected: 'No file selected',
                            processing: 'Processing CSV file...',
                            statistics: 'Statistics',
                            title: 'Title',
                            name: 'Name',
                            game: 'Game',
                            server: 'Server',
                            gameMode: 'Game Mode',
                            startTime: 'Start Time',
                            length: 'Length',
                            players: 'Players',
                            match: 'Match',
                            matchStartTime: 'Match Start Time',
                            matchLength: 'Match Length',
                            matchMode: 'Match Mode',
                            mapName: 'Map Name',
                            totalEvents: 'Total Events',
                            mapBounds: 'Map Bounds',
                            calculating: 'Calculating...',
                            mapRendering: 'Map Rendering Info',
                            currentMap: 'Current Map',
                            note: 'Note',
                            mapGeometry: 'Map Geometry',
                            mapApi: 'External Map Data',
                            kdRatio: 'K/D Ratio',
                            kdDesc: 'K/D: Kills / Deaths - Click to filter',
                            killEvents: 'Kill events will appear here',
                            go: 'Go',
                            resetView: 'Reset View',
                            prev: 'Prev',
                            next: 'Next',
                            follow: 'Follow',
                            focusMode: 'Focus Mode: Event selected',
                            exitFocus: 'Exit Focus Mode',
                            actionStream: 'Action Stream',
                            matchChat: 'Match Chat',
                            aimTrace: 'Aim Trace'
                        }
                    };
                    
                    const t = uiTexts[this.language];
                    
                    // ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò Î©îÎâ¥ ÏóÖÎç∞Ïù¥Ìä∏
                    const navItems = document.querySelectorAll('.nav-item');
                    navItems.forEach(item => {
                        const text = item.textContent.trim();
                        if (text.includes('Info') || item.classList.contains('active') && item.previousElementSibling && item.previousElementSibling.id === 'brand-logo') {
                            // InfoÎäî Í∑∏ÎåÄÎ°ú
                        } else if (text.includes('3D') || text.includes('ÏãúÎÆ¨Î†àÏù¥ÏÖò')) {
                            item.textContent = t.navSimulation;
                        } else if (text.includes('Î∂ÑÏÑù Î≥¥Í≥†ÏÑú') || text.includes('Analysis Report')) {
                            item.textContent = t.navReport;
                        }
                    });
                    
                    // ÏÇ¨Ïù¥ÎìúÎ∞î ÏóÖÎç∞Ïù¥Ìä∏
                    const sidebarSections = document.querySelectorAll('.sidebar-section h3');
                    sidebarSections.forEach(h3 => {
                        if (h3.textContent.includes('File Load') || h3.textContent.includes('ÌååÏùº Î°úÎìú')) {
                            h3.textContent = t.fileLoad;
                        } else if (h3.textContent.includes('Statistics') || h3.textContent.includes('ÌÜµÍ≥Ñ')) {
                            h3.textContent = t.statistics;
                        }
                    });
                    
                    // ÌååÏùº ÏÑ†ÌÉù Î≤ÑÌäº
                    const selectBtn = document.getElementById('select-csv-btn');
                    if (selectBtn) selectBtn.textContent = t.selectFile;
                    
                    // ÏÑ†ÌÉùÎêú ÌååÏùº ÏóÜÏùå
                    const selectedFile = document.getElementById('selected-file');
                    if (selectedFile && selectedFile.textContent.includes('ÏÑ†ÌÉùÎêú ÌååÏùº ÏóÜÏùå') || selectedFile.textContent.includes('No file selected')) {
                        if (selectedFile.textContent === 'ÏÑ†ÌÉùÎêú ÌååÏùº ÏóÜÏùå' || selectedFile.textContent === 'No file selected') {
                            selectedFile.textContent = t.noFileSelected;
                        }
                    }
                    
                    // Ï≤òÎ¶¨ Ï§ë
                    const loading = document.getElementById('loading');
                    if (loading) loading.textContent = t.processing;
                    
                    // Statistics ÏÑπÏÖò ÏóÖÎç∞Ïù¥Ìä∏
                    const statLabels = document.querySelectorAll('.stat-label');
                    statLabels.forEach(label => {
                        const text = label.textContent.trim();
                        if (text.includes('Name:')) label.textContent = t.name + ':';
                        else if (text.includes('Server:')) label.textContent = t.server + ':';
                        else if (text.includes('Game Mode:')) label.textContent = t.gameMode + ':';
                        else if (text.includes('Start time:')) label.textContent = t.startTime + ':';
                        else if (text.includes('Length:')) label.textContent = t.length + ':';
                        else if (text.includes('Players:')) label.textContent = t.players + ':';
                        else if (text.includes('Match Start Time:')) label.textContent = t.matchStartTime + ':';
                        else if (text.includes('Match Length:')) label.textContent = t.matchLength + ':';
                        else if (text.includes('Match Mode:')) label.textContent = t.matchMode + ':';
                        else if (text.includes('Map Name:')) label.textContent = t.mapName + ':';
                        else if (text.includes('Total Events:')) label.textContent = t.totalEvents + ':';
                    });
                    
                    const statTitles = document.querySelectorAll('.stat-group-title');
                    statTitles.forEach(title => {
                        const text = title.textContent.trim();
                        if (text.includes('Title')) title.textContent = t.title;
                        else if (text.includes('Game')) title.textContent = t.game;
                        else if (text.includes('Match')) title.textContent = t.match;
                        else if (text.includes('Players') || text.includes('K/D')) title.textContent = t.players + ' (' + t.kdRatio + ')';
                        else if (text.includes('Map Bounds') || text.includes('Îßµ Í≤ΩÍ≥Ñ')) title.textContent = t.mapBounds;
                    });
                    
                    // K/D ÏÑ§Î™Ö
                    const kdDesc = document.querySelector('.stat-group-title')?.nextElementSibling;
                    if (kdDesc && kdDesc.style && (kdDesc.textContent.includes('K/D') || kdDesc.textContent.includes('ÌÇ¨'))) {
                        kdDesc.textContent = t.kdDesc;
                    }
                    
                    // Îßµ Ï†ïÎ≥¥ ÌÖçÏä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
                    const mapRenderingLabel = document.getElementById('map-rendering-label');
                    if (mapRenderingLabel) {
                        mapRenderingLabel.textContent = t.mapRendering + ':';
                    }
                    
                    const currentMapText = document.getElementById('current-map-text');
                    const detectedMapNameElement = document.getElementById('detected-map-name');
                    if (currentMapText && detectedMapNameElement) {
                        const mapName = this.data?.metadata?.mapName || this.detectedMapName || 'Unknown';
                        const source = this.detectedMapName ? (this.language === 'ko' ? '(ÏúÑÏπò Í∏∞Î∞ò Ï∂îÎ°†)' : '(Location-based inference)') : 
                                      (this.language === 'ko' ? '(Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò)' : '(Data-based)');
                        currentMapText.innerHTML = t.currentMap + ': <span id="detected-map-name">' + mapName + ' ' + source + '</span>';
                    } else if (currentMapText) {
                        // fallback
                        const mapName = this.data?.metadata?.mapName || this.detectedMapName || 'Unknown';
                        currentMapText.textContent = t.currentMap + ': ' + mapName;
                    }
                    
                    const mapGeometryText = document.getElementById('map-geometry-text');
                    if (mapGeometryText) {
                        if (this.language === 'ko') {
                            mapGeometryText.textContent = 'Îßµ ÏßÄÏò§Î©îÌä∏Î¶¨ Îç∞Ïù¥ÌÑ∞Îäî CS2 Í≤åÏûÑ ÌååÏùº(.bsp)ÏóêÏÑú Ï∂îÏ∂úÌïòÍ±∞ÎÇò';
                        } else {
                            mapGeometryText.textContent = 'Map geometry data must be extracted from CS2 game files (.bsp) or';
                        }
                    }
                    
                    const mapApiText = document.getElementById('map-api-text');
                    if (mapApiText) {
                        if (this.language === 'ko') {
                            mapApiText.textContent = 'Ïô∏Î∂Ä Îßµ Îç∞Ïù¥ÌÑ∞ APIÎ•º ÏÇ¨Ïö©Ìï¥Ïïº Ìï©ÎãàÎã§.';
                        } else {
                            mapApiText.textContent = 'use an external map data API.';
                        }
                    }
                    
                    const mapNoteText = document.getElementById('map-note-text');
                    if (mapNoteText) {
                        if (this.language === 'ko') {
                            mapNoteText.textContent = 'Ï∞∏Í≥†: ÌòÑÏû¨Îäî ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπò Í∏∞Î∞ò Í≤ΩÍ≥ÑÎßå ÌëúÏãúÎê©ÎãàÎã§.';
                        } else {
                            mapNoteText.textContent = 'Note: Currently only player position-based boundaries are displayed.';
                        }
                    }
                    
                    // Map Bounds ÌÖçÏä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
                    const mapBoundsTitle = document.getElementById('map-info-title');
                    if (mapBoundsTitle) {
                        mapBoundsTitle.textContent = t.mapBounds;
                    }
                    
                    const mapBoundsText = document.getElementById('map-bounds');
                    if (mapBoundsText && mapBoundsText.textContent.includes('Í≥ÑÏÇ∞ Ï§ë')) {
                        mapBoundsText.textContent = t.calculating;
                    }
                    
                    // Ïù¥Î≤§Ìä∏ ÌîºÏª§ ÏóÖÎç∞Ïù¥Ìä∏
                    const killSelect = document.getElementById('kill-select');
                    if (killSelect && killSelect.options[0]) {
                        killSelect.options[0].text = t.killEvents;
                    }
                    
                    const playerSelect = document.getElementById('player-select');
                    if (playerSelect && playerSelect.options[0]) {
                        playerSelect.options[0].text = t.players;
                    }
                    
                    // Î≤ÑÌäº ÏóÖÎç∞Ïù¥Ìä∏
                    const goBtn = document.getElementById('go-kill');
                    if (goBtn) goBtn.textContent = t.go;
                    
                    const resetBtn = document.getElementById('reset-view');
                    if (resetBtn) resetBtn.textContent = t.resetView;
                    
                    const prevBtn = document.getElementById('prev-player-tick');
                    if (prevBtn) prevBtn.textContent = t.prev;
                    
                    const nextBtn = document.getElementById('next-player-tick');
                    if (nextBtn) nextBtn.textContent = t.next;
                    
                    const followBtn = document.getElementById('follow-toggle');
                    if (followBtn) followBtn.textContent = t.follow;
                    
                    const exitFocusBtn = document.getElementById('exit-focus-btn');
                    if (exitFocusBtn) exitFocusBtn.textContent = t.exitFocus;
                    
                    const focusInfo = document.getElementById('focus-info');
                    if (focusInfo) focusInfo.textContent = t.focusMode;
                    
                    // ÌïòÎã® Ìå®ÎÑê ÌÉ≠ ÏóÖÎç∞Ïù¥Ìä∏
                    const tabBtns = document.querySelectorAll('.tab-btn');
                    tabBtns.forEach(btn => {
                        const text = btn.textContent.trim();
                        if (text.includes('Action Stream') || text.includes('Ïï°ÏÖò Ïä§Ìä∏Î¶º')) {
                            btn.textContent = t.actionStream;
                        } else if (text.includes('Match Chat') || text.includes('Îß§Ïπò Ï±ÑÌåÖ')) {
                            btn.textContent = t.matchChat;
                        } else if (text.includes('Aim Trace') || text.includes('ÏóêÏûÑ Ìä∏Î†àÏù¥Ïä§')) {
                            btn.textContent = t.aimTrace;
                        }
                    });
                    
                    // Dashboard/Info ÌÉ≠ ÎÇ¥Ïö© ÏóÖÎç∞Ïù¥Ìä∏
                    if (document.getElementById('dashboard-view') && !document.getElementById('dashboard-view').classList.contains('hidden')) {
                        this.renderDashboard();
                    }
                    
                    // Î≥¥Í≥†ÏÑúÍ∞Ä Ïó¥Î†§ÏûàÏúºÎ©¥ Ïñ∏Ïñ¥ Î≥ÄÍ≤Ω ÌõÑ Ïû¨ÏÉùÏÑ±
                    if (this.currentReportWindow && !this.currentReportWindow.closed) {
                        const playerName = this.selectedPlayer || (this.selectedEvent && this.selectedEvent.attacker && this.selectedEvent.attacker.name) || 
                                        ((this.data && this.data.metadata && this.data.metadata.players && this.data.metadata.players[0]) || null);
                        if (playerName) {
                            this.currentReportWindow.close();
                            this.generateReport(playerName);
                        }
                    }
                };
            }

            async loadCSV(file) {
                const loading = document.getElementById('loading');
                if (loading) {
                    loading.style.display = 'block';
                    loading.innerHTML = 'Parsing CSV file...';
                }
                
                return new Promise((resolve) => {
                    try {
                        // PapaParse Î°úÎìú ÌôïÏù∏
                        if (typeof Papa === 'undefined' || !Papa || !Papa.parse) {
                            console.error('PapaParseÍ∞Ä Î°úÎìúÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');
                            if (loading) loading.innerHTML = 'Error: CSV parser not loaded. ÎÑ§Ìä∏ÏõåÌÅ¨Î•º ÌôïÏù∏ÌïòÍ≥† ÏÉàÎ°úÍ≥†Ïπ®(Ctrl+F5) Ìï¥Ï£ºÏÑ∏Ïöî.';
                            resolve();
                            return;
                        }
                        Papa.parse(file, {
                            header: true,
                            skipEmptyLines: true,
                            complete: async (results) => {
                                console.log('CSV ÌååÏã± ÏôÑÎ£å:', results.data.length, 'Ï§Ñ');
                                console.log('Ï≤´ Î≤àÏß∏ Ìñâ ÏÉòÌîå:', results.data[0]);
                                
                                if (!results || !results.data || results.data.length === 0) {
                                    console.error('CSV ÌååÏã± Í≤∞Í≥ºÍ∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§');
                                    alert('CSV ÌååÏùºÏóê Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.');
                                    if (loading) loading.style.display = 'none';
                                    resolve();
                                    return;
                                }
                                
                                if (loading) loading.innerHTML = 'Processing data... 0%';
                                try {
                                    await this.processData(results.data);
                                } catch (procError) {
                                    console.error('processData Ïò§Î•ò:', procError);
                                    alert('Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò: ' + procError.message);
                                }
                                if (loading) loading.style.display = 'none';
                                resolve();
                            },
                            error: (error) => {
                                console.error('CSV ÌååÏã± Ïò§Î•ò:', error);
                                if (loading) loading.style.display = 'none';
                                alert('CSV ÌååÏùºÏùÑ ÏùΩÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + error.message);
                                resolve();
                            }
                        });
                    } catch (error) {
                        console.error('loadCSV Ïò§Î•ò:', error);
                        if (loading) loading.style.display = 'none';
                        alert('ÌååÏùº Î°úÎìú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + error.message);
                        resolve();
                    }
                });
            }

            async processData(rows) {
                try {
                    console.log('processData ÏãúÏûë, Ï¥ù Ìñâ Ïàò:', rows.length);
                    if (!rows || rows.length === 0) {
                        console.error('Îç∞Ïù¥ÌÑ∞Í∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§');
                        alert('CSV ÌååÏùºÏóê Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.');
                        return;
                    }
                    
                    const positions = [];
                    const events = [];
                    const aimIndex = new Map(); // name -> [{yaw,pitch,time,type}]
                    
                    // match_id Ï∂îÏ∂ú (Ï≤´ Î≤àÏß∏ ÌñâÏóêÏÑú)
                    let matchId = null;
                    if (rows.length > 0 && rows[0].match_id !== undefined) {
                        matchId = rows[0].match_id !== null ? String(rows[0].match_id).trim() : null;
                    }
                    
                    // ÎÇòÏ§ëÏóê Ï°∞Ïù∏Îê† Îç∞Ïù¥ÌÑ∞Î•º Ï†ÄÏû•Ìï† Îßµ (player_id -> metadata)
                    // CSVÏóê ÏßÅÏ†ë Ìè¨Ìï®ÎêòÏñ¥ ÏûàÏùÑ ÏàòÎèÑ ÏûàÍ≥†, ÎÇòÏ§ëÏóê Ï°∞Ïù∏Îê† ÏàòÎèÑ ÏûàÏùå
                    const playerJoinData = new Map(); // player_id -> {team, map, os, input_device, character}
                    
                    // Îßµ Í≤ΩÍ≥Ñ Ï∂îÏ†ÅÏö© (Î≥ÑÎèÑ Î∞∞Ïó¥ ÏóÜÏù¥ ÏßÅÏ†ë Í≥ÑÏÇ∞)
                    let minX = Infinity, maxX = -Infinity;
                    let minY = Infinity, maxY = -Infinity;
                    let minZ = Infinity, maxZ = -Infinity;
                    
                    let tickData = {};
                    let currentTick = null;
                    
                    const totalRows = rows.length;
                    const chunkSize = 1000; // Ï≤≠ÌÅ¨ Îã®ÏúÑÎ°ú Ï≤òÎ¶¨ÌïòÏó¨ UI Ï∞®Îã® Î∞©ÏßÄ
                    
                    // ÏßÑÌñâ ÏÉÅÌô© ÌëúÏãú
                    const loading = document.getElementById('loading');
                    const updateProgress = (progress) => {
                        if (loading) {
                            loading.style.display = 'block';
                            loading.innerHTML = 'Processing data... ' + Math.round(progress) + '%';
                        }
                    };
                    
                    // Ï≤≠ÌÅ¨ Îã®ÏúÑ Ï≤òÎ¶¨
                    for (let chunkStart = 0; chunkStart < totalRows; chunkStart += chunkSize) {
                        const chunkEnd = Math.min(chunkStart + chunkSize, totalRows);
                        const chunk = rows.slice(chunkStart, chunkEnd);
                        
                        chunk.forEach((row, localIdx) => {
                        const idx = chunkStart + localIdx;
                        
                        // ÏÉàÎ°úÏö¥ Îç∞Ïù¥ÌÑ∞ Ïä§ÌÇ§Îßà: tick ÌïÑÏàò
                        const tickStr = row.tick && row.tick.trim ? row.tick.trim() : (row.tick !== undefined && row.tick !== null ? String(row.tick) : null);
                        if (!tickStr || tickStr === '') return;
                        
                        const tick = parseInt(tickStr);
                        if (Number.isNaN(tick)) return;
                        
                        // timestampÎ•º Ï¥à Îã®ÏúÑÎ°ú Î≥ÄÌôò (ms -> s)
                        const timestampMs = parseFloat(row.timestamp || 0);
                        const gameTime = timestampMs > 0 ? timestampMs / 1000 : 0;
                        
                        // tickÏù¥ Î≥ÄÍ≤ΩÎêòÎ©¥ Ïù¥Ï†Ñ tick Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
                        if (currentTick !== tick && currentTick !== null && tickData.players && tickData.players.length) {
                            positions.push({
                                tick: currentTick,
                                game_time: tickData.game_time || 0,
                                players: tickData.players || []
                            });
                            tickData = { players: [] };
                        }
                        
                        currentTick = tick;
                        tickData.game_time = gameTime;
                        
                        // ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπò Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ (ÏÉà Ïä§ÌÇ§Îßà: player_id, X, Y, Z)
                        const x = row.X !== undefined && row.X !== null ? String(row.X).trim() : null;
                        const y = row.Y !== undefined && row.Y !== null ? String(row.Y).trim() : null;
                        const z = row.Z !== undefined && row.Z !== null ? String(row.Z).trim() : null;
                        const playerId = row.player_id !== undefined && row.player_id !== null ? String(row.player_id).trim() : null;
                        
                        if (x && y && z && playerId && playerId !== '') {
                            const posX = parseFloat(x);
                            const posY = parseFloat(y);
                            const posZ = parseFloat(z);
                            
                            if (!Number.isNaN(posX) && !Number.isNaN(posY) && !Number.isNaN(posZ)) {
                                // Îßµ Í≤ΩÍ≥Ñ ÏßÅÏ†ë ÏóÖÎç∞Ïù¥Ìä∏
                                if (posX < minX) minX = posX;
                                if (posX > maxX) maxX = posX;
                                if (posY < minY) minY = posY;
                                if (posY > maxY) maxY = posY;
                                if (posZ < minZ) minZ = posZ;
                                if (posZ > maxZ) maxZ = posZ;
                                
                                tickData.players = tickData.players || [];
                                
                                // yaw, pitch Ï†ïÎ≥¥ ÏàòÏßë
                                const yawStr = row.yaw !== undefined && row.yaw !== null ? String(row.yaw).trim() : null;
                                const pitchStr = row.pitch !== undefined && row.pitch !== null ? String(row.pitch).trim() : null;
                                const yaw = yawStr && yawStr !== '' ? parseFloat(yawStr) : null;
                                const pitch = pitchStr && pitchStr !== '' ? parseFloat(pitchStr) : null;
                                
                                // health Ï†ïÎ≥¥
                                const health = row.health !== undefined && row.health !== null ? parseInt(String(row.health)) : 100;
                                
                                // weapon Ï†ïÎ≥¥ (equipped_weapon_id ÎòêÎäî event_src_id)
                                const weaponId = row.equipped_weapon_id !== undefined && row.equipped_weapon_id !== null ? 
                                    parseInt(String(row.equipped_weapon_id)) : 
                                    (row.event_src_id !== undefined && row.event_src_id !== null ? parseInt(String(row.event_src_id)) : null);
                                
                                // Ï°∞Ïù∏ Îç∞Ïù¥ÌÑ∞ ÌôïÏù∏ (CSVÏóê ÏßÅÏ†ë Ìè¨Ìï®ÎêòÏñ¥ ÏûàÍ±∞ÎÇò ÎÇòÏ§ëÏóê Ï°∞Ïù∏Îê† Ïàò ÏûàÏùå)
                                let joinData = playerJoinData.get(playerId);
                                if (!joinData) {
                                    // CSVÏóêÏÑú ÏßÅÏ†ë ÏùΩÏùÑ Ïàò ÏûàÎäî Í≤ΩÏö∞ (ÎÇòÏ§ëÏóê Ïª¨Îüº Ï∂îÍ∞Ä ÏòàÏ†ï)
                                    joinData = {
                                        team: row.team || row.team_name || '',
                                        map: row.map || row.map_name || null,
                                        os: row.os || row.os_type || null,
                                        input_device: row.input_device || row.input_device_type || null,
                                        character: row.character || row.character_name || null
                                    };
                                    playerJoinData.set(playerId, joinData);
                                }
                                
                                tickData.players.push({
                                    name: playerId, // player_idÎ•º nameÏúºÎ°ú ÏÇ¨Ïö©
                                    team: joinData.team || '', // Ï°∞Ïù∏Îêú ÌåÄ Ï†ïÎ≥¥
                                    position: [posX, posZ, posY], // Three.js Ï¢åÌëúÍ≥Ñ: X, Z, Y
                                    health: !Number.isNaN(health) ? health : 100,
                                    round: 1, // ÏÉà Îç∞Ïù¥ÌÑ∞ÏóêÎäî round Ï†ïÎ≥¥Í∞Ä ÏóÜÏùå
                                    weapon: !Number.isNaN(weaponId) ? weaponId : null,
                                    yaw: !Number.isNaN(yaw) ? yaw : null,
                                    pitch: !Number.isNaN(pitch) ? pitch : null,
                                    // ÎÇòÏ§ëÏóê Ï°∞Ïù∏Îê† Ï†ïÎ≥¥Îì§
                                    map: joinData.map || null,
                                    os: joinData.os || null,
                                    input_device: joinData.input_device || null,
                                    character: joinData.character || null
                                });
                            }
                        }
                        
                        // Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨ (ÏÉà Ïä§ÌÇ§Îßà: event_type, event_src_player_id, event_trg_player_id)
                        const eventType = row.event_type !== undefined && row.event_type !== null ? parseInt(String(row.event_type)) : null;
                        if (!Number.isNaN(eventType) && eventType > 0) {
                            // event_type: 1:fire, 2:hit, 3:kill
                            let eventTypeStr = '';
                            if (eventType === 1) eventTypeStr = 'fire';
                            else if (eventType === 2) eventTypeStr = 'hit';
                            else if (eventType === 3) eventTypeStr = 'kill';
                            
                            if (eventTypeStr) {
                                const attackerId = row.event_src_player_id !== undefined && row.event_src_player_id !== null ? 
                                    String(row.event_src_player_id).trim() : null;
                                const victimId = row.event_trg_player_id !== undefined && row.event_trg_player_id !== null ? 
                                    String(row.event_trg_player_id).trim() : null;
                                
                                // ÌÇ¨ Ïù¥Î≤§Ìä∏ Ï§ëÎ≥µ Ï≤¥ÌÅ¨
                                let shouldAddEvent = true;
                                if (eventType === 3 && attackerId && victimId) {
                                    const existingKill = events.find(e => 
                                        e.tick === tick && 
                                        e.event_type_lower === 'kill' &&
                                        e.attacker && e.attacker.name === attackerId &&
                                        e.victim && e.victim.name === victimId
                                    );
                                    if (existingKill) {
                                        shouldAddEvent = false;
                                    }
                                }
                                
                                if (shouldAddEvent) {
                                    // Í≥µÍ≤©Ïûê ÏúÑÏπò Ï∞æÍ∏∞ (Í∞ôÏùÄ tickÏùò ÌîåÎ†àÏù¥Ïñ¥ Îç∞Ïù¥ÌÑ∞ÏóêÏÑú)
                                    let attackerPos = [null, null, null];
                                    if (attackerId) {
                                        const attackerPlayer = tickData.players.find(p => p.name === attackerId);
                                        if (attackerPlayer && attackerPlayer.position) {
                                            attackerPos = attackerPlayer.position;
                                        }
                                    }
                                    
                                    // ÌîºÍ≤©Ïûê ÏúÑÏπò Ï∞æÍ∏∞
                                    let victimPos = [null, null, null];
                                    if (victimId) {
                                        const victimPlayer = tickData.players.find(p => p.name === victimId);
                                        if (victimPlayer && victimPlayer.position) {
                                            victimPos = victimPlayer.position;
                                        }
                                    }
                                    
                                    // weapon Ï†ïÎ≥¥
                                    const eventWeaponId = row.event_src_id !== undefined && row.event_src_id !== null ? 
                                        parseInt(String(row.event_src_id)) : null;
                                    
                                    // headshot Ï†ïÎ≥¥
                                    const headshot = row.head_shot_yn !== undefined && row.head_shot_yn !== null ? 
                                        (parseInt(String(row.head_shot_yn)) === 1) : false;
                                    
                                    events.push({
                                        tick: tick,
                                        game_time: gameTime,
                                        event_type: eventTypeStr,
                                        event_type_lower: eventTypeStr.toLowerCase(),
                                        attacker: {
                                            name: attackerId,
                                            team: '',
                                            position: attackerPos,
                                            weapon: !Number.isNaN(eventWeaponId) ? eventWeaponId : null
                                        },
                                        victim: {
                                            name: victimId,
                                            team: '',
                                            position: victimPos
                                        },
                                        weapon: !Number.isNaN(eventWeaponId) ? eventWeaponId : null,
                                        headshot: headshot
                                    });
                                    
                                    // ÌÇ¨ Ïù¥Î≤§Ìä∏Ïùò Í≥µÍ≤©Ïûê Aim Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
                                    if (eventType === 3 && attackerId) {
                                        const attackerPlayer = tickData.players.find(p => p.name === attackerId);
                                        if (attackerPlayer && attackerPlayer.yaw !== null && attackerPlayer.pitch !== null) {
                                            if (!aimIndex.has(attackerId)) aimIndex.set(attackerId, []);
                                            const existingKill = aimIndex.get(attackerId).find(a => 
                                                a.type === 'kill' && a.tick === tick && Math.abs(a.time - gameTime) < 0.01
                                            );
                                            if (!existingKill) {
                                                aimIndex.get(attackerId).push({ 
                                                    yaw: attackerPlayer.yaw, 
                                                    pitch: attackerPlayer.pitch, 
                                                    time: gameTime, 
                                                    tick: tick, 
                                                    type: 'kill',
                                                    _temp: true
                                                });
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        });
                        
                        // ÏßÑÌñâ ÏÉÅÌô© ÏóÖÎç∞Ïù¥Ìä∏ Î∞è UI Ï∞®Îã® Î∞©ÏßÄ
                        updateProgress((chunkEnd / totalRows) * 100);
                        await new Promise(resolve => setTimeout(resolve, 0)); // Îã§Ïùå Ïù¥Î≤§Ìä∏ Î£®ÌîÑÎ°ú
                    }
                    
                    if (currentTick !== null && tickData.players && tickData.players.length) {
                        positions.push({
                            tick: currentTick,
                            game_time: tickData.game_time || 0,
                            players: tickData.players || []
                        });
                    }
                    
                    // Îßµ Í≤ΩÍ≥Ñ Í≥ÑÏÇ∞ (Ïù¥ÎØ∏ Í≥ÑÏÇ∞Îê®)
                    let detectedMapName = null;
                    if (minX !== Infinity && maxX !== -Infinity) {
                        this.mapBounds = {
                            minX: minX,
                            maxX: maxX,
                            minY: minY,
                            maxY: maxY,
                            minZ: minZ,
                            maxZ: maxZ,
                            centerX: (minX + maxX) / 2,
                            centerY: (minY + maxY) / 2,
                            centerZ: (minZ + maxZ) / 2,
                            width: maxX - minX,
                            height: maxY - minY,
                            depth: maxZ - minZ
                        };
                        
                        // ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπò Î≤îÏúÑÎ•º Í∏∞Î∞òÏúºÎ°ú Îßµ Ï∂îÎ°†
                        detectedMapName = this.detectMapFromBounds(this.mapBounds);
                    }
                    
                    // CSV ÌååÏùºÎ™ÖÏóêÏÑú Îßµ Ïù¥Î¶Ñ Ï∂îÏ∂ú ÏãúÎèÑ
                    const fileName = document.getElementById('selected-file')?.textContent || '';
                    let mapNameFromFile = null;
                    if (fileName && fileName !== 'ÏÑ†ÌÉùÎêú ÌååÏùº ÏóÜÏùå' && fileName !== 'No file selected') {
                        // ÌååÏùºÎ™ÖÏóêÏÑú Îßµ Ïù¥Î¶Ñ Ìå®ÌÑ¥ Ï∞æÍ∏∞ (Ïòà: anubis, dust2, inferno Îì±)
                        const mapPatterns = [
                            'anubis', 'dust2', 'dust_2', 'inferno', 'mirage', 'overpass', 
                            'nuke', 'vertigo', 'ancient', 'cache', 'train', 'cobblestone'
                        ];
                        const fileNameLower = fileName.toLowerCase();
                        for (const map of mapPatterns) {
                            if (fileNameLower.includes(map)) {
                                mapNameFromFile = map.charAt(0).toUpperCase() + map.slice(1).replace('_', '');
                                break;
                            }
                        }
                    }
                    
                    // ÏµúÏ¢Ö Îßµ Ïù¥Î¶Ñ Í≤∞Ï†ï (ÌååÏùºÎ™Ö Ïö∞ÏÑ†, ÏóÜÏúºÎ©¥ ÏúÑÏπò Í∏∞Î∞ò Ï∂îÎ°†)
                    const finalMapName = mapNameFromFile || detectedMapName || 'Unknown';
                    this.detectedMapName = finalMapName;
                    
                    const gameTimes = positions.map(p => p.game_time).filter(t => t);
                    const ticks = positions.map(p => p.tick).filter(t => t);
                    const players = new Set();
                    const playerStats = new Map();
                    const playerIndex = new Map();
                    
                    // ÌîåÎ†àÏù¥Ïñ¥ Ïù∏Îç±Ïä§ Î∞è Aim Îç∞Ïù¥ÌÑ∞ ÏàòÏßë (ÏµúÏ†ÅÌôî)
                    positions.forEach(p => {
                    p.players.forEach(pl => {
                        if (pl.name) {
                            players.add(pl.name);
                            if (!playerStats.has(pl.name)) {
                                // ÌîåÎ†àÏù¥Ïñ¥ ÌÜµÍ≥Ñ Ï¥àÍ∏∞Ìôî (ÎÇòÏ§ëÏóê Ï°∞Ïù∏Îê† Ï†ïÎ≥¥Îì§ Ìè¨Ìï®)
                                playerStats.set(pl.name, { 
                                    kills: 0, 
                                    deaths: 0, 
                                    team: pl.team || '',
                                    map: pl.map || null,
                                    os: pl.os || null,
                                    input_device: pl.input_device || null,
                                    character: pl.character || null
                                });
                            } else {
                                // Ïù¥ÎØ∏ ÏûàÎäî Í≤ΩÏö∞ÏóêÎèÑ Ï∂îÍ∞Ä Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏ (Ï≤´ Î≤àÏß∏Î°ú Î∞úÍ≤¨Îêú Í∞í ÏÇ¨Ïö©)
                                const stats = playerStats.get(pl.name);
                                if (!stats.map && pl.map) stats.map = pl.map;
                                if (!stats.os && pl.os) stats.os = pl.os;
                                if (!stats.input_device && pl.input_device) stats.input_device = pl.input_device;
                                if (!stats.character && pl.character) stats.character = pl.character;
                            }
                            if (!playerIndex.has(pl.name)) playerIndex.set(pl.name, []);
                            playerIndex.get(pl.name).push({ tick: p.tick, time: p.game_time, position: pl.position });
                            
                            // Aim Îç∞Ïù¥ÌÑ∞ ÏàòÏßë (Î™®Îì† Ìã±ÏóêÏÑú yaw/pitch)
                            if (pl.yaw !== null && pl.yaw !== undefined && 
                                pl.pitch !== null && pl.pitch !== undefined) {
                                if (!aimIndex.has(pl.name)) aimIndex.set(pl.name, []);
                                aimIndex.get(pl.name).push({ 
                                    yaw: pl.yaw, 
                                    pitch: pl.pitch, 
                                    time: p.game_time, 
                                    tick: p.tick,
                                    type: 'move' 
                                });
                            }
                            }
                        });
                    });
                    
                    // Kill Ïù¥Î≤§Ìä∏Ïùò aim Îç∞Ïù¥ÌÑ∞Î•º move Îç∞Ïù¥ÌÑ∞ÏôÄ Î≥ëÌï© (ÏùºÍ¥Ñ Ï≤òÎ¶¨)
                    aimIndex.forEach((arr, name) => {
                        const kills = arr.filter(a => a.type === 'kill' && a._temp);
                        const moves = arr.filter(a => a.type === 'move');
                        
                        // kill ÌÉÄÏûÖÏùÑ Í∞ôÏùÄ ÏãúÍ∞Ñ/Ìã±Ïùò moveÏóê Î≥ëÌï©
                        kills.forEach(kill => {
                            const existing = moves.find(m => 
                                Math.abs(m.time - kill.time) < 0.01 && m.tick === kill.tick
                            );
                            if (existing) {
                                existing.type = 'kill';
                            }
                        });
                        
                        // ÏûÑÏãú kill Ìï≠Î™© Ï†úÍ±∞ (Î≥ëÌï©Îêú Í≤ÉÎßå ÎÇ®ÍπÄ)
                        arr.splice(0, arr.length, ...moves, ...kills.filter(k => {
                            const exists = moves.some(m => 
                                Math.abs(m.time - k.time) < 0.01 && m.tick === k.tick
                            );
                            return !exists;
                        }));
                    });
                    
                    events.forEach(e => {
                        if (e.event_type_lower && (e.event_type_lower.includes('kill') || e.event_type_lower.includes('died'))) {
                            if (e.attacker && e.attacker.name) {
                                const stats = playerStats.get(e.attacker.name);
                                if (stats) stats.kills++;
                            }
                            if (e.victim && e.victim.name) {
                                const stats = playerStats.get(e.victim.name);
                                if (stats) stats.deaths++;
                            }
                        }
                    });
                    
                    // ÌîåÎ†àÏù¥Ïñ¥Î≥Ñ Ï∂îÍ∞Ä Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏàòÏßë (OS, ÏûÖÎ†• ÎîîÎ∞îÏù¥Ïä§, Ï∫êÎ¶≠ÌÑ∞ Îì±)
                    const playerMetadata = new Map();
                    positions.forEach(p => {
                        p.players.forEach(pl => {
                            if (pl.name && !playerMetadata.has(pl.name)) {
                                playerMetadata.set(pl.name, {
                                    team: pl.team || '',
                                    map: pl.map || null,
                                    os: pl.os || null,
                                    input_device: pl.input_device || null,
                                    character: pl.character || null
                                });
                            }
                        });
                    });
                    
                    // Í≥†Ïú†Ìïú ÌåÄ Î™©Î°ù ÏàòÏßë
                    const uniqueTeams = new Set();
                    playerStats.forEach(stats => {
                        if (stats.team) uniqueTeams.add(stats.team);
                    });
                    
                    // Í≥†Ïú†Ìïú Îßµ Î™©Î°ù ÏàòÏßë
                    const uniqueMaps = new Set();
                    playerMetadata.forEach(meta => {
                        if (meta.map) uniqueMaps.add(meta.map);
                    });
                    if (this.detectedMapName) uniqueMaps.add(this.detectedMapName);
                    
                    this.data = {
                        metadata: {
                            total_ticks: positions.length,
                            total_events: events.length,
                            time_range: {
                                min: gameTimes.length ? Math.min(...gameTimes) : 0,
                                max: gameTimes.length ? Math.max(...gameTimes) : 0
                            },
                            tick_range: {
                                min: ticks.length ? Math.min(...ticks) : 0,
                                max: ticks.length ? Math.max(...ticks) : 0
                            },
                            players: Array.from(players).sort(),
                            playerStats: Object.fromEntries(playerStats),
                            playerMetadata: Object.fromEntries(playerMetadata), // Ï∂îÍ∞Ä Î©îÌÉÄÎç∞Ïù¥ÌÑ∞
                            teams: Array.from(uniqueTeams).length > 0 ? Array.from(uniqueTeams) : ['CT', 'TERRORIST'], // ÎèôÏ†Å ÌåÄ Î™©Î°ù
                            maps: Array.from(uniqueMaps), // Îßµ Î™©Î°ù
                            mapName: this.detectedMapName || 'Unknown',
                            // ÎÇòÏ§ëÏóê Ï°∞Ïù∏Îê† Ï†ïÎ≥¥Îì§ÏùÑ ÏúÑÌïú Íµ¨Ï°∞
                            matchInfo: {
                                match_id: matchId, // CSVÏóêÏÑú Ï∂îÏ∂úÌïú match_id
                                os_distribution: {}, // OSÎ≥Ñ Î∂ÑÌè¨
                                input_device_distribution: {}, // ÏûÖÎ†• ÎîîÎ∞îÏù¥Ïä§Î≥Ñ Î∂ÑÌè¨
                                character_distribution: {} // Ï∫êÎ¶≠ÌÑ∞Î≥Ñ Î∂ÑÌè¨
                            }
                        },
                        positions: positions,
                        events: events
                    };
                    
                    // OS, ÏûÖÎ†• ÎîîÎ∞îÏù¥Ïä§, Ï∫êÎ¶≠ÌÑ∞ Î∂ÑÌè¨ Í≥ÑÏÇ∞
                    playerMetadata.forEach(meta => {
                        if (meta.os) {
                            this.data.metadata.matchInfo.os_distribution[meta.os] = 
                                (this.data.metadata.matchInfo.os_distribution[meta.os] || 0) + 1;
                        }
                        if (meta.input_device) {
                            this.data.metadata.matchInfo.input_device_distribution[meta.input_device] = 
                                (this.data.metadata.matchInfo.input_device_distribution[meta.input_device] || 0) + 1;
                        }
                        if (meta.character) {
                            this.data.metadata.matchInfo.character_distribution[meta.character] = 
                                (this.data.metadata.matchInfo.character_distribution[meta.character] || 0) + 1;
                        }
                    });
                    this.playerIndex = playerIndex;
                    // aimIndex Ï†ïÎ†¨ (ÏãúÍ∞ÑÏàú)
                    aimIndex.forEach((arr, name) => {
                        arr.sort((a, b) => a.time - b.time);
                    });
                    this.aimIndex = aimIndex;
                    
                    // window.simulationÏóê Ïù∏Ïä§ÌÑ¥Ïä§ Ìï†Îãπ (ÎîîÎ≤ÑÍπÖÏö©)
                    window.simulation = this;
                    
                    console.log('Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ ÏôÑÎ£å:', this.data.metadata);
                    console.log('Îßµ Í≤ΩÍ≥Ñ:', this.mapBounds);
                    console.log('Positions Ïàò:', positions.length);
                    console.log('Events Ïàò:', events.length);
                    console.log('Î°úÎìúÎêú Îç∞Ïù¥ÌÑ∞:', window.simulation?.data?.metadata);
                    console.log('Match ID:', matchId);
                    console.log('Ï°∞Ïù∏ Îç∞Ïù¥ÌÑ∞ Ï§ÄÎπÑ ÏôÑÎ£å (ÌåÄ, Îßµ, OS, ÏûÖÎ†•ÎîîÎ∞îÏù¥Ïä§, Ï∫êÎ¶≠ÌÑ∞)');
                    
                    if (positions.length === 0) {
                        console.error('PositionsÍ∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§. Îç∞Ïù¥ÌÑ∞ Ìè¨Îß∑ÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.');
                        alert('Îç∞Ïù¥ÌÑ∞Î•º Ï≤òÎ¶¨Ìï† Ïàò ÏóÜÏäµÎãàÎã§. CSV ÌååÏùº Ìè¨Îß∑ÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.');
                        return;
                    }
                    
                    this.updateUI();
                    this.setupMapBounds();
                    // setupMapBounds() Ïù¥ÌõÑÏóê Í≤ΩÎ°ú Î†åÎçîÎßÅ (baseCameraDistance ÏÑ§Ï†ï ÌõÑ)
                    this.analyzeAndRenderPaths();
                    this.populateKillPicker();
                    this.populatePlayerPicker();
            }
            
            /**
             * ÎÇòÏ§ëÏóê Ï°∞Ïù∏Îê† Îç∞Ïù¥ÌÑ∞Î•º Ï∂îÍ∞ÄÌïòÎäî Ìï®Ïàò
             * @param {Object} joinData - player_idÎ•º ÌÇ§Î°ú ÌïòÎäî Ï°∞Ïù∏ Îç∞Ïù¥ÌÑ∞ Í∞ùÏ≤¥
             * @example
             * enrichPlayerData({
             *   "-479": { team: "Team A", os: "Windows", input_device: "keyboard_mouse", character: "Character1" },
             *   "-481": { team: "Team B", os: "Mac", input_device: "console", character: "Character2" }
             * })
             */
            enrichPlayerData(joinData) {
                if (!this.data || !joinData) return;
                
                console.log('ÌîåÎ†àÏù¥Ïñ¥ Îç∞Ïù¥ÌÑ∞ Ï°∞Ïù∏ ÏãúÏûë:', joinData);
                
                // Í∞Å Ìã±Ïùò ÌîåÎ†àÏù¥Ïñ¥ Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
                this.data.positions.forEach(tickData => {
                    tickData.players.forEach(player => {
                        const joinInfo = joinData[player.name];
                        if (joinInfo) {
                            if (joinInfo.team !== undefined) player.team = joinInfo.team;
                            if (joinInfo.map !== undefined) player.map = joinInfo.map;
                            if (joinInfo.os !== undefined) player.os = joinInfo.os;
                            if (joinInfo.input_device !== undefined) player.input_device = joinInfo.input_device;
                            if (joinInfo.character !== undefined) player.character = joinInfo.character;
                        }
                    });
                });
                
                // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
                Object.keys(joinData).forEach(playerId => {
                    if (this.data.metadata.playerMetadata[playerId]) {
                        Object.assign(this.data.metadata.playerMetadata[playerId], joinData[playerId]);
                    } else {
                        this.data.metadata.playerMetadata[playerId] = joinData[playerId];
                    }
                    
                    // playerStatsÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
                    if (this.data.metadata.playerStats[playerId]) {
                        if (joinData[playerId].team !== undefined) {
                            this.data.metadata.playerStats[playerId].team = joinData[playerId].team;
                        }
                    }
                });
                
                // ÌåÄ Î™©Î°ù Ïû¨ÏàòÏßë
                const uniqueTeams = new Set();
                Object.values(this.data.metadata.playerStats).forEach(stats => {
                    if (stats.team) uniqueTeams.add(stats.team);
                });
                this.data.metadata.teams = Array.from(uniqueTeams).length > 0 ? Array.from(uniqueTeams) : ['CT', 'TERRORIST'];
                
                // Îßµ Î™©Î°ù Ïû¨ÏàòÏßë
                const uniqueMaps = new Set();
                Object.values(this.data.metadata.playerMetadata).forEach(meta => {
                    if (meta.map) uniqueMaps.add(meta.map);
                });
                if (this.detectedMapName) uniqueMaps.add(this.detectedMapName);
                this.data.metadata.maps = Array.from(uniqueMaps);
                
                // Î∂ÑÌè¨ Ïû¨Í≥ÑÏÇ∞
                this.recalculateDistributions();
                
                // UI ÏóÖÎç∞Ïù¥Ìä∏
                this.updateUI();
                this.populatePlayerPicker();
                
                console.log('ÌîåÎ†àÏù¥Ïñ¥ Îç∞Ïù¥ÌÑ∞ Ï°∞Ïù∏ ÏôÑÎ£å');
            }
            
            /**
             * OS, ÏûÖÎ†• ÎîîÎ∞îÏù¥Ïä§, Ï∫êÎ¶≠ÌÑ∞ Î∂ÑÌè¨Î•º Ïû¨Í≥ÑÏÇ∞ÌïòÎäî Ìï®Ïàò
             */
            recalculateDistributions() {
                if (!this.data) return;
                
                const osDist = {};
                const inputDeviceDist = {};
                const characterDist = {};
                
                Object.values(this.data.metadata.playerMetadata).forEach(meta => {
                    if (meta.os) {
                        osDist[meta.os] = (osDist[meta.os] || 0) + 1;
                    }
                    if (meta.input_device) {
                        inputDeviceDist[meta.input_device] = (inputDeviceDist[meta.input_device] || 0) + 1;
                    }
                    if (meta.character) {
                        characterDist[meta.character] = (characterDist[meta.character] || 0) + 1;
                    }
                });
                
                this.data.metadata.matchInfo.os_distribution = osDist;
                this.data.metadata.matchInfo.input_device_distribution = inputDeviceDist;
                this.data.metadata.matchInfo.character_distribution = characterDist;
                
                console.log('Î∂ÑÌè¨ Ïû¨Í≥ÑÏÇ∞ ÏôÑÎ£å:', {
                    os: osDist,
                    input_device: inputDeviceDist,
                    character: characterDist
                });
            }
                    
                    // POC: CSV Î°úÎìú ÌõÑ ÏûêÎèôÏúºÎ°ú Îßµ Ïù¥ÎØ∏ÏßÄ Î°úÎìú
                    // Îßµ Í∞êÏßÄÏôÄ ÏÉÅÍ¥ÄÏóÜÏù¥ Ìï≠ÏÉÅ mapImageSettings Ïù¥ÎØ∏ÏßÄ Î°úÎìú ÏãúÎèÑ
                    if (this.mapImageSettings && this.mapImageSettings.imagePath) {
                        this.loadMapImageFromPath(this.mapImageSettings.imagePath);
                    }
                    
                    // ÌååÏùº Î°úÎìú ÌõÑ 3D ÏãúÎÆ¨Î†àÏù¥ÏÖò Î∂ÑÏÑù ÌÉ≠ÏúºÎ°ú ÏûêÎèô Ï†ÑÌôò
                    this.showInvestigate();
                    
                    // ÏãúÎÆ¨Î†àÏù¥ÏÖò Î†åÎçîÎßÅ Ï¥àÍ∏∞Ìôî
                    setTimeout(() => {
                    this.renderTick(0);
                        // renderer ÌÅ¨Í∏∞ Ïû¨Ï°∞Ï†ï (containerÍ∞Ä Ïà®Í≤®Ï†∏ ÏûàÏùÑ Ïàò ÏûàÏùå)
                        const container = document.getElementById('canvas-container');
                        if (container && this.renderer) {
                            const width = container.clientWidth;
                            const height = container.clientHeight;
                            if (width > 0 && height > 0) {
                                this.camera.aspect = width / height;
                                this.camera.updateProjectionMatrix();
                                this.renderer.setSize(width, height);
                            }
                        }
                    }, 100);
                } catch (error) {
                    console.error('processData Ïò§Î•ò:', error);
                    alert('Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + error.message);
                    const loading = document.getElementById('loading');
                    if (loading) loading.style.display = 'none';
                }
            }

            renderAimTrace() {
                const container = document.getElementById('event-log');
                container.innerHTML = '';
                const canvas = document.createElement('canvas');
                canvas.width = container.clientWidth - 20;
                canvas.height = container.clientHeight - 20;
                canvas.style.background = '#0a0e15';
                canvas.style.border = '1px solid #2a2f3e';
                container.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                const W = canvas.width;
                const H = canvas.height;

                // Focus Î™®ÎìúÍ∞Ä ÏïÑÎãàÎ©¥ Î©îÏãúÏßÄ ÌëúÏãú
                if (!this.focusMode || !this.focusTickRange) {
                    ctx.fillStyle = '#8a8fa5';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Aim TraceÎäî Focus Î™®ÎìúÏóêÏÑúÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.', W/2, H/2);
                    ctx.fillText('ÌÇ¨ Ïù¥Î≤§Ìä∏Î•º ÏÑ†ÌÉùÌïòÏó¨ Focus Î™®ÎìúÎ•º ÌôúÏÑ±ÌôîÌïòÏÑ∏Ïöî.', W/2, H/2 + 30);
                    return;
                }

                // ÏÑ†ÌÉùÎêú ÌîåÎ†àÏù¥Ïñ¥ Ïö∞ÏÑ†ÏàúÏúÑ: Ìè¨Ïª§Ïä§ Î™®ÎìúÏùº ÎïåÎäî Î∞òÎìúÏãú Í≥µÍ≤©Ïûê -> ÏÑ†ÌÉùÎêú ÌîåÎ†àÏù¥Ïñ¥ -> Ï≤´ Î≤àÏß∏
                let name = null;
                if (this.focusMode && this.selectedEvent && this.selectedEvent.attacker && this.selectedEvent.attacker.name) {
                    // Ìè¨Ïª§Ïä§ Î™®ÎìúÏùº ÎïåÎäî Î¨¥Ï°∞Í±¥ Í≥µÍ≤©ÏûêÎ•º ÌëúÏãú
                    name = this.selectedEvent.attacker.name;
                    console.log('Aim Trace - Ìè¨Ïª§Ïä§ Î™®Îìú: Í≥µÍ≤©Ïûê', name, 'Ïùò aim trace ÌëúÏãú');
                } else if (this.selectedEvent && this.selectedEvent.attacker && this.selectedEvent.attacker.name) {
                    name = this.selectedEvent.attacker.name;
                } else {
                    name = this.selectedPlayer || ((this.data && this.data.metadata && this.data.metadata.players && this.data.metadata.players[0]) || null);
                }
                
                // Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ÏóêÏÑú Aim Ï†ïÎ≥¥ ÏàòÏßë
                let samples = [];
                if (name && this.data) {
                    console.log('Aim Trace - ÌîåÎ†àÏù¥Ïñ¥:', name);
                    
                    // Ìè¨Ïª§Ïä§ Î™®ÎìúÏùº ÎïåÎäî Ìã± Ïù∏Îç±Ïä§ Î≤îÏúÑÎ°ú ÏßÅÏ†ë ÏàòÏßë (Î™®Îì† Ìã±, ÎàÑÏ†Å)
                    if (this.focusMode && this.focusTickRange) {
                        console.log('Aim Trace - Ìè¨Ïª§Ïä§ Î™®Îìú: Ìã± Î≤îÏúÑ', this.focusTickRange.startIdx, '-', this.focusTickRange.endIdx, 'Ï¥ù', (this.focusTickRange.endIdx - this.focusTickRange.startIdx + 1), 'Ìã±');
                        let foundCount = 0;
                        let missingCount = 0;
                        let lastYaw = null;
                        let lastPitch = null;
                        
                        // Ï≤´ Î≤àÏß∏ Ïú†Ìö®Ìïú Í∞íÏùÑ Ï∞æÍ∏∞ ÏúÑÌï¥ Ïó≠Î∞©Ìñ•ÏúºÎ°úÎèÑ Í≤ÄÏÉâ
                        for (let idx = this.focusTickRange.startIdx - 1; idx >= 0 && idx >= this.focusTickRange.startIdx - 10; idx--) {
                            const pos = this.data.positions[idx];
                            if (pos) {
                                const player = pos.players.find(p => p.name === name);
                                if (player && player.yaw !== null && player.yaw !== undefined && !Number.isNaN(player.yaw) &&
                                    player.pitch !== null && player.pitch !== undefined && !Number.isNaN(player.pitch)) {
                                    lastYaw = player.yaw;
                                    lastPitch = player.pitch;
                                    break;
                                }
                            }
                        }
                        
                        // Î™®Îì† Ìã±ÏùÑ ÏàúÌöåÌïòÎ©¥ÏÑú Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÎäî Ìã±Îßå ÏàòÏßë (Ï§ëÎ≥µ Ï†úÍ±∞)
                        for (let idx = this.focusTickRange.startIdx; idx <= this.focusTickRange.endIdx; idx++) {
                            const pos = this.data.positions[idx];
                            if (pos) {
                                const player = pos.players.find(p => p.name === name);
                                if (player) {
                                    const yaw = player.yaw;
                                    const pitch = player.pitch;
                                    
                                    // Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÎäî Í≤ΩÏö∞Îßå Ï∂îÍ∞Ä (Î≥¥Í∞Ñ ÏóÜÏù¥)
                                    if (yaw !== null && yaw !== undefined && !Number.isNaN(yaw) &&
                                        pitch !== null && pitch !== undefined && !Number.isNaN(pitch)) {
                                        // Ïù¥Ï†Ñ ÏÉòÌîåÍ≥º Í∞íÏù¥ Îã§Î•º ÎïåÎßå Ï∂îÍ∞Ä (Ï§ëÎ≥µ Ï†úÍ±∞)
                                        if (lastYaw === null || lastPitch === null || 
                                            Math.abs(yaw - lastYaw) > 0.01 || Math.abs(pitch - lastPitch) > 0.01) {
                                            samples.push({
                                                yaw: yaw,
                                                pitch: pitch,
                                                time: pos.game_time,
                                                tick: pos.tick,
                                                tickIdx: idx, // Ìã± Ïù∏Îç±Ïä§ Î™ÖÏãúÏ†Å Ï†ÄÏû•
                                                type: 'move'
                                            });
                                            lastYaw = yaw;
                                            lastPitch = pitch;
                                            foundCount++;
                                        } else {
                                            // Í∞ôÏùÄ Í∞íÏù¥Î©¥ Ïä§ÌÇµ (Ï§ëÎ≥µ Ï†úÍ±∞)
                                            missingCount++;
                                        }
                                    } else {
                                        missingCount++;
                                    }
                                } else {
                                    missingCount++;
                                }
                            }
                        }
                        console.log('Aim Trace - Ìè¨Ïª§Ïä§ Î™®Îìú ÏàòÏßë:', foundCount, 'Í≥†Ïú† ÏÉòÌîå, Ï§ëÎ≥µ/ÏóÜÏùå:', missingCount, '/ Ï†ÑÏ≤¥ Ìã±:', (this.focusTickRange.endIdx - this.focusTickRange.startIdx + 1));
                        console.log('Aim Trace - Ìè¨Ïª§Ïä§ Î™®Îìú Î≤îÏúÑ:', this.focusTickRange.startIdx, '~', this.focusTickRange.endIdx, 'Ìã±');
                    } else {
                        // ÏùºÎ∞ò Î™®Îìú: Ï†ÑÏ≤¥ positionsÏóêÏÑú ÏàòÏßë (Ï§ëÎ≥µ Ï†úÍ±∞ Ìè¨Ìï®)
                        let foundCount = 0;
                        let missingCount = 0;
                        let lastYaw = null;
                        let lastPitch = null;
                        this.data.positions.forEach(pos => {
                            const player = pos.players.find(p => p.name === name);
                            if (player) {
                                // yaw/pitch ÌôïÏù∏ (null Ï≤¥ÌÅ¨ Î∞è Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨)
                                const yaw = player.yaw;
                                const pitch = player.pitch;
                                if (yaw !== null && yaw !== undefined && !Number.isNaN(yaw) &&
                                    pitch !== null && pitch !== undefined && !Number.isNaN(pitch)) {
                                    // Ïù¥Ï†Ñ ÏÉòÌîåÍ≥º Í∞íÏù¥ Îã§Î•º ÎïåÎßå Ï∂îÍ∞Ä (Ï§ëÎ≥µ Ï†úÍ±∞)
                                    if (lastYaw === null || lastPitch === null || 
                                        Math.abs(yaw - lastYaw) > 0.01 || Math.abs(pitch - lastPitch) > 0.01) {
                                        samples.push({
                                            yaw: yaw,
                                            pitch: pitch,
                                            time: pos.game_time,
                                            tick: pos.tick,
                                            type: 'move'
                                        });
                                        lastYaw = yaw;
                                        lastPitch = pitch;
                                        foundCount++;
                                    } else {
                                        missingCount++;
                                    }
                                } else {
                                    missingCount++;
                                }
                            } else {
                                missingCount++;
                            }
                        });
                        console.log('Aim Trace - ÏùºÎ∞ò Î™®Îìú ÏàòÏßë:', foundCount, 'Í≥†Ïú† ÏÉòÌîå, Ï§ëÎ≥µ/ÏóÜÏùå:', missingCount, '/ Ï†ÑÏ≤¥:', this.data.positions.length);
                    }
                    
                    // ÌÇ¨ Ïù¥Î≤§Ìä∏ÏóêÏÑú kill ÌÉÄÏûÖ ÎßàÌÇπ (Ï§ëÎ≥µ Ï†úÍ±∞ Í∞ïÌôî)
                    if (this.aimIndex && this.aimIndex.has(name)) {
                        let killPoints = this.aimIndex.get(name).filter(a => a.type === 'kill');

                        // Ìè¨Ïª§Ïä§ Î™®ÎìúÏóêÏÑúÎäî ÏÑ†ÌÉùÎêú Ïù¥Î≤§Ìä∏Ïùò ÌÇ¨Îßå ÌëúÏãú (Ï§ëÎ≥µ Î∂âÏùÄ Ï†ê Î∞©ÏßÄ)
                        if (this.focusMode && this.selectedEvent && this.selectedEvent.tick !== undefined) {
                            const focusTick = this.selectedEvent.tick;
                            const focusVictim = this.selectedEvent.victim ? this.selectedEvent.victim.name : null;
                            killPoints = killPoints.filter(kp => {
                                if (kp.tick !== focusTick) return false;
                                // victim Ï†ïÎ≥¥Í∞Ä ÏûàÏúºÎ©¥ ÏùºÏπòÌïòÎäî Í≤ΩÏö∞Îßå ÌëúÏãú
                                return focusVictim ? true : true;
                            });
                        }
                        console.log('Aim Trace - Kill Ìè¨Ïù∏Ìä∏ Ïàò (Ï§ëÎ≥µ Ï†úÍ±∞ Ï†Ñ):', killPoints.length);
                        
                        // Ï§ëÎ≥µ Ï†úÍ±∞: Í∞ôÏùÄ tickÏùò ÌÇ¨ÏùÄ ÌïòÎÇòÎßå ÎÇ®ÍπÄ
                        const uniqueKillPoints = [];
                        const seenTicks = new Set();
                        killPoints.forEach(kp => {
                            if (!seenTicks.has(kp.tick)) {
                                seenTicks.add(kp.tick);
                                uniqueKillPoints.push(kp);
                            }
                        });
                        
                        console.log('Aim Trace - Kill Ìè¨Ïù∏Ìä∏ Ïàò (Ï§ëÎ≥µ Ï†úÍ±∞ ÌõÑ):', uniqueKillPoints.length);
                        
                        uniqueKillPoints.forEach(kp => {
                            const existing = samples.find(s => 
                                Math.abs(s.time - kp.time) < 0.01 && s.tick === kp.tick
                            );
                            if (existing) {
                                existing.type = 'kill';
                            } else {
                                samples.push(kp);
                            }
                        });
                    }
                    
                    samples.sort((a, b) => a.time - b.time);
                    console.log('Aim Trace - ÏµúÏ¢Ö ÏÉòÌîå Ïàò:', samples.length);
                    
                    // Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ Í≤ΩÍ≥†
                    if (samples.length === 0) {
                        console.warn('Aim Trace - Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§. ÌîåÎ†àÏù¥Ïñ¥:', name);
                    }
                } else {
                    console.warn('Aim Trace - ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Î¶Ñ ÎòêÎäî Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.');
                }

                // ÌòÑÏû¨ Ïû¨ÏÉù Íµ¨Í∞Ñ - Ìè¨Ïª§Ïä§ Î™®ÎìúÏùº ÎïåÎäî Ìè¨Ïª§Ïä§ Î≤îÏúÑ ÏÇ¨Ïö©
                let tStart, tEnd;
                if (this.focusMode && this.focusTickRange) {
                    // Ìè¨Ïª§Ïä§ Î™®Îìú: ÏÑ†ÌÉùÎêú Ïù¥Î≤§Ìä∏ Ï†ÑÌõÑ ¬±30Ìã± Î≤îÏúÑ
                    tStart = this.data.positions[this.focusTickRange.startIdx].game_time;
                    tEnd = this.data.positions[this.focusTickRange.endIdx].game_time;
                    console.log('Aim Trace - Ìè¨Ïª§Ïä§ Î™®Îìú Î≤îÏúÑ:', tStart.toFixed(2), '-', tEnd.toFixed(2), 'Î≤îÏúÑ:', (tEnd - tStart).toFixed(2), 'Ï¥à');
                } else {
                    const endIdx = this.currentTick;
                    // Îçî ÎÑìÏùÄ Î≤îÏúÑ: ÏµúÍ∑º 300Ìã± ÎòêÎäî 5Ï¥à
                    const startIdx = Math.max(0, endIdx - 300);
                    tStart = (this.data.positions[startIdx] && this.data.positions[startIdx].game_time != null) ? this.data.positions[startIdx].game_time : 0;
                    const currentTime = (this.data.positions[endIdx] && this.data.positions[endIdx].game_time != null) ? this.data.positions[endIdx].game_time : tStart;
                    tEnd = currentTime;
                    // ÏµúÏÜå 5Ï¥à Î≤îÏúÑ Î≥¥Ïû•
                    if (tEnd - tStart < 5) {
                        tStart = Math.max(0, tEnd - 5);
                    }
                }
                const currentTime = (this.data.positions[this.currentTick] && this.data.positions[this.currentTick].game_time != null) ? this.data.positions[this.currentTick].game_time : tStart;
                
                // Ìè¨Ïª§Ïä§ Î™®ÎìúÏùº ÎïåÎäî Ïû¨ÏÉù Ï§ëÏù¥Î©¥ ÌòÑÏû¨ Ìã±ÍπåÏßÄ ÎàÑÏ†Å, ÏïÑÎãàÎ©¥ Ï†ÑÏ≤¥ ÌëúÏãú
                // ÏùºÎ∞ò Î™®ÎìúÏùº ÎïåÎßå ÏãúÍ∞Ñ Î≤îÏúÑÎ°ú ÌïÑÌÑ∞ÎßÅ
                let windowSamples;
                if (this.focusMode && this.focusTickRange) {
                    // Ìè¨Ïª§Ïä§ Î™®Îìú: Ïû¨ÏÉù Ï§ëÏù¥Î©¥ ÌòÑÏû¨ Ìã±ÍπåÏßÄ ÎàÑÏ†Å ÌëúÏãú (Ìã± Ïù∏Îç±Ïä§ Í∏∞Î∞ò)
                    const currentTickIdx = this.currentTick;
                    const startTickIdx = this.focusTickRange.startIdx;
                    
                    // Ìè¨Ïª§Ïä§ Î™®ÎìúÏóêÏÑúÎäî Ìï≠ÏÉÅ Ï†ÑÏ≤¥ ÏÉòÌîå ÌëúÏãú (ÎàÑÏ†Å)
                    // Ïû¨ÏÉù Ï§ëÏù¥Î©¥ ÌòÑÏû¨ Ìã±ÍπåÏßÄÎßå ÌëúÏãúÌïòÎèÑÎ°ù ÏòµÏÖò Ï†úÍ≥µ
                    if (this.isPlaying && currentTickIdx > startTickIdx) {
                        // Ïû¨ÏÉù Ï§ë: ÌòÑÏû¨ Ìã±ÍπåÏßÄÏùò ÏÉòÌîåÎßå ÌëúÏãú (ÏàúÏ∞®Ï†Å ÎàÑÏ†Å)
                        windowSamples = samples.filter(s => {
                            // tickIdxÍ∞Ä ÏûàÏúºÎ©¥ ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ positionsÏóêÏÑú Ï∞æÍ∏∞
                            let sampleTickIdx = s.tickIdx;
                            if (sampleTickIdx === undefined) {
                                sampleTickIdx = this.data.positions.findIndex(p => p.tick === s.tick);
                            }
                            return sampleTickIdx !== -1 && sampleTickIdx <= currentTickIdx && sampleTickIdx >= startTickIdx;
                        });
                        console.log('Aim Trace - Ìè¨Ïª§Ïä§ Î™®Îìú (Ïû¨ÏÉù Ï§ë): Ìã±', startTickIdx, '~', currentTickIdx, 'ÍπåÏßÄ', windowSamples.length, 'ÏÉòÌîå ÎàÑÏ†Å (Ï†ÑÏ≤¥ samples:', samples.length, ')');
                    } else {
                        // Ï†ïÏßÄ ÏÉÅÌÉúÎ©¥ Ï†ÑÏ≤¥ ÌëúÏãú (Î™®Îì† ÏÉòÌîå)
                        windowSamples = samples;
                        console.log('Aim Trace - Ìè¨Ïª§Ïä§ Î™®Îìú (Ï†ïÏßÄ): Ï†ÑÏ≤¥', windowSamples.length, 'ÏÉòÌîå ÌëúÏãú');
                    }
                } else {
                    // ÏùºÎ∞ò Î™®Îìú: ÏãúÍ∞Ñ Î≤îÏúÑÎ°ú ÌïÑÌÑ∞ÎßÅ
                    windowSamples = samples.filter(s => s.time >= tStart && s.time <= tEnd);
                }
                
                console.log('Aim Trace - ÏúàÎèÑÏö∞ ÏÉòÌîå Ïàò:', windowSamples.length, 'ÏãúÍ∞Ñ Î≤îÏúÑ:', tStart.toFixed(2), '-', tEnd.toFixed(2), 'Î≤îÏúÑ:', (tEnd - tStart).toFixed(2), 'Ï¥à');
                console.log('Aim Trace - ÏÉòÌîå yaw Î≤îÏúÑ:', windowSamples.length > 0 ? [Math.min(...windowSamples.map(s => s.yaw)).toFixed(2), Math.max(...windowSamples.map(s => s.yaw)).toFixed(2)] : 'ÏóÜÏùå');
                console.log('Aim Trace - ÏÉòÌîå pitch Î≤îÏúÑ:', windowSamples.length > 0 ? [Math.min(...windowSamples.map(s => s.pitch)).toFixed(2), Math.max(...windowSamples.map(s => s.pitch)).toFixed(2)] : 'ÏóÜÏùå');
                
                // Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ Î©îÏãúÏßÄ ÌëúÏãú
                if (samples.length === 0) {
                    ctx.fillStyle = '#8a8fa5';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('No aim data available for ' + (name || 'selected player'), W/2, H/2);
                    ctx.textAlign = 'left';
                    return;
                }
                
                if (windowSamples.length === 0) {
                    ctx.fillStyle = '#8a8fa5';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('No data in current time window', W/2, H/2);
                    ctx.textAlign = 'left';
                    return;
                }

                // Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ Î≤îÏúÑ Í≥ÑÏÇ∞ (ÎèôÏ†Å Ïä§ÏºÄÏùºÎßÅ)
                const yaws = windowSamples.map(s => s.yaw).filter(v => !Number.isNaN(v));
                const pitches = windowSamples.map(s => s.pitch).filter(v => !Number.isNaN(v));
                
                let xMin, xMax, yMin, yMax;
                if (yaws.length > 0 && pitches.length > 0) {
                    const yawMin = Math.min(...yaws);
                    const yawMax = Math.max(...yaws);
                    const pitchMin = Math.min(...pitches);
                    const pitchMax = Math.max(...pitches);
                    
                    const yawRange = yawMax - yawMin;
                    const pitchRange = pitchMax - pitchMin;
                    
                    // Î≤îÏúÑÍ∞Ä Îß§Ïö∞ Ï¢ÅÏúºÎ©¥ (10ÎèÑ Ïù¥Ìïò) ÌôïÎåÄ, ÏïÑÎãàÎ©¥ Ï†ÑÏ≤¥ Î≤îÏúÑ ÏÇ¨Ïö©
                    if (yawRange < 10 && pitchRange < 10) {
                        // ÌôïÎåÄ: Ï§ëÏïô Í∏∞Ï§ÄÏúºÎ°ú ¬±20ÎèÑ Î≤îÏúÑ
                        const yawCenter = (yawMin + yawMax) / 2;
                        const pitchCenter = (pitchMin + pitchMax) / 2;
                        xMin = yawCenter - 20;
                        xMax = yawCenter + 20;
                        yMin = pitchCenter - 20;
                        yMax = pitchCenter + 20;
                        console.log('Aim Trace - ÌôïÎåÄ Î™®Îìú:', {yawCenter, pitchCenter, range: '¬±20¬∞'});
                    } else {
                        // Ïó¨Î∞± Ï∂îÍ∞Ä (10% padding)
                        const yawPadding = Math.max(yawRange * 0.1, 5);
                        const pitchPadding = Math.max(pitchRange * 0.1, 5);
                        xMin = yawMin - yawPadding;
                        xMax = yawMax + yawPadding;
                        yMin = pitchMin - pitchPadding;
                        yMax = pitchMax + pitchPadding;
                        console.log('Aim Trace - ÎèôÏ†Å Î≤îÏúÑ:', {yaw: [xMin, xMax], pitch: [yMin, yMax]});
                    }
                } else {
                    // Í∏∞Î≥∏ Î≤îÏúÑ
                    xMin = -180; xMax = 180; yMin = -90; yMax = 90;
                }
                
                console.log('Aim Trace - Ï¢åÌëú Î≤îÏúÑ:', {yaw: [xMin.toFixed(1), xMax.toFixed(1)], pitch: [yMin.toFixed(1), yMax.toFixed(1)]});
                
                const pad = 40;
                
                function xScale(v){ return pad + (v - xMin) / (xMax - xMin) * (W - 2*pad); }
                function yScale(v){ return H - (pad + (v - yMin) / (yMax - yMin) * (H - 2*pad)); }

                // Î∞∞Í≤Ω Í∑∏Î¶¨Îìú (ÎèôÏ†Å Î≤îÏúÑÏóê ÎßûÏ∂∞)
                ctx.strokeStyle = '#2a2f3e'; ctx.lineWidth = 1;
                const gridStepX = Math.max(1, Math.ceil((xMax - xMin) / 20)); // ÏïΩ 20Í∞ú Í∑∏Î¶¨Îìú
                const gridStepY = Math.max(1, Math.ceil((yMax - yMin) / 15)); // ÏïΩ 15Í∞ú Í∑∏Î¶¨Îìú
                
                for (let x = Math.floor(xMin / gridStepX) * gridStepX; x <= xMax; x += gridStepX) {
                    const sx = xScale(x);
                    if (sx >= pad && sx <= W - pad) {
                        ctx.beginPath(); ctx.moveTo(sx, pad); ctx.lineTo(sx, H - pad); ctx.stroke();
                    }
                }
                for (let y = Math.floor(yMin / gridStepY) * gridStepY; y <= yMax; y += gridStepY) {
                    const sy = yScale(y);
                    if (sy >= pad && sy <= H - pad) {
                        ctx.beginPath(); ctx.moveTo(pad, sy); ctx.lineTo(W - pad, sy); ctx.stroke();
                    }
                }
                
                // Ï∂ï ÎùºÎ≤® (Î≤îÏúÑ ÌëúÏãú)
                ctx.fillStyle = '#8a8fa5'; ctx.font = '12px Arial';
                ctx.fillText(`Yaw (¬∞) [${xMin.toFixed(1)} ~ ${xMax.toFixed(1)}]`, W/2 - 80, H-10);
                ctx.save(); ctx.translate(10, H/2); ctx.rotate(-Math.PI/2); 
                ctx.fillText(`Pitch (¬∞) [${yMin.toFixed(1)} ~ ${yMax.toFixed(1)}]`, 0, 0); ctx.restore();

                // Î™®Îì† Ìè¨Ïù∏Ìä∏ ÌëúÏãú (ÎàÑÏ†Å Ïù¥Îèô Í≤ΩÎ°ú) - Í≥†Ïú†Ìïú Í∞íÎßå ÌëúÏãú
                console.log('Aim Trace - Î†åÎçîÎßÅÌï† Ìè¨Ïù∏Ìä∏ Ïàò:', windowSamples.length);
                
                // Ï§ëÎ≥µ Ï†úÍ±∞: Ïó∞ÏÜçÎêú Í∞ôÏùÄ Í∞í Ï†úÍ±∞ (Î®ºÏ†Ä ÏÉùÏÑ±)
                const uniqueSamples = [];
                let lastRenderedYaw = null;
                let lastRenderedPitch = null;
                
                windowSamples.forEach((s, idx) => {
                    // Í∞íÏù¥ Î≥ÄÍ≤ΩÎêòÏóàÍ±∞ÎÇò Ï≤´ Î≤àÏß∏ ÏÉòÌîåÏù¥Î©¥ Ï∂îÍ∞Ä
                    if (lastRenderedYaw === null || lastRenderedPitch === null ||
                        Math.abs(s.yaw - lastRenderedYaw) > 0.01 || Math.abs(s.pitch - lastRenderedPitch) > 0.01) {
                        uniqueSamples.push(s);
                        lastRenderedYaw = s.yaw;
                        lastRenderedPitch = s.pitch;
                    }
                });
                
                console.log('Aim Trace - Ï§ëÎ≥µ Ï†úÍ±∞ ÌõÑ Í≥†Ïú† Ìè¨Ïù∏Ìä∏ Ïàò:', uniqueSamples.length, '/', windowSamples.length);

                // Í≤ΩÎ°ú Ïó∞Í≤∞ÏÑ† (Í∏∞Î≥∏ ÌöåÏÉâ) - Í≥†Ïú† Ìè¨Ïù∏Ìä∏Îßå Ïó∞Í≤∞
                if (uniqueSamples.length > 1){
                    ctx.beginPath();
                    ctx.strokeStyle = '#5a637a'; ctx.lineWidth = 1.5;
                    let firstPoint = true;
                    for (let i = 0; i < uniqueSamples.length; i++) {
                        const s = uniqueSamples[i];
                        const x = xScale(s.yaw);
                        const y = yScale(s.pitch);
                        if (firstPoint) {
                            ctx.moveTo(x, y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                }
                
                // Ìè¨Ïù∏Ìä∏ Î†åÎçîÎßÅ
                if (uniqueSamples.length === 0) {
                    console.warn('Aim Trace - Î†åÎçîÎßÅÌï† Í≥†Ïú† Ìè¨Ïù∏Ìä∏Í∞Ä ÏóÜÏäµÎãàÎã§. windowSamples:', windowSamples.length);
                } else {
                    console.log('Aim Trace - Î†åÎçîÎßÅ ÏãúÏûë: Í≥†Ïú† Ìè¨Ïù∏Ìä∏', uniqueSamples.length, 'Í∞ú');
                }
                
                uniqueSamples.forEach((s, idx) => {
                    const x = xScale(s.yaw);
                    const y = yScale(s.pitch);
                    
                    // Ï∫îÎ≤ÑÏä§ Î≤îÏúÑ Ï≤¥ÌÅ¨
                    if (x < 0 || x > W || y < 0 || y > H) {
                        if (idx < 3) {
                            console.warn(`Ìè¨Ïù∏Ìä∏ ${idx}Í∞Ä Ï∫îÎ≤ÑÏä§ Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇ®: canvas(${x.toFixed(1)}, ${y.toFixed(1)})`);
                        }
                        return; // Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇú Ìè¨Ïù∏Ìä∏Îäî Ïä§ÌÇµ
                    }
                    
                    // ÎîîÎ≤ÑÍπÖ: Ï≤òÏùå 3Í∞úÏôÄ ÎßàÏßÄÎßâ 3Í∞ú Ìè¨Ïù∏Ìä∏Îßå Î°úÍ∑∏
                    if (idx < 3 || idx >= uniqueSamples.length - 3) {
                        console.log(`Í≥†Ïú† Ìè¨Ïù∏Ìä∏ ${idx}/${uniqueSamples.length}: yaw=${s.yaw.toFixed(2)}, pitch=${s.pitch.toFixed(2)}, canvas(${x.toFixed(1)}, ${y.toFixed(1)})`);
                    }
                    
                    if (s.type === 'kill') {
                        // Kill ÏãúÏ†ê: ÏßÑÎπ®Í∞ï ÌÅ∞ Ïõê + ÌÖåÎëêÎ¶¨
                        ctx.fillStyle = '#cc0000';
                        ctx.beginPath(); ctx.arc(x, y, 5, 0, Math.PI*2); ctx.fill();
                        ctx.strokeStyle = '#ff3333'; ctx.lineWidth = 2; ctx.stroke();
                    } else {
                        // ÏùºÎ∞ò Ïù¥Îèô Ìè¨Ïù∏Ìä∏: ÏûëÏùÄ ÌöåÏÉâ Ï†ê (Î™®Îëê ÌëúÏãú)
                        ctx.fillStyle = '#8a8fa5';
                        ctx.beginPath(); ctx.arc(x, y, 2, 0, Math.PI*2); ctx.fill();
                    }
                });

                // ÌòÑÏû¨ Ìã±Ïùò ÎßàÏö∞Ïä§ ÏúÑÏπò ÌïòÏù¥ÎùºÏù¥Ìä∏ (ÌååÎûë ÌÅ∞ Ï†ê) - Í≥†Ïú† ÏÉòÌîåÏóêÏÑú Ï∞æÍ∏∞
                const curr = uniqueSamples.reduce((prev, s) => {
                    const prevDiff = prev ? Math.abs(s.time - currentTime) : Infinity;
                    const currDiff = Math.abs(s.time - currentTime);
                    return currDiff < prevDiff ? s : prev;
                }, null);
                if (curr) {
                    const cx = xScale(curr.yaw), cy = yScale(curr.pitch);
                    ctx.fillStyle = '#4a90e2';
                    ctx.beginPath(); ctx.arc(cx, cy, 6, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 2; ctx.stroke();
                }

                // Î≤îÎ°Ä
                const legend = [
                    {label:'Current', color:'#4a90e2'},
                    {label:'Kill', color:'#cc0000'}
                ];
                let lx = pad, ly = pad-12;
                legend.forEach(l =>{
                    ctx.fillStyle = l.color; ctx.beginPath(); ctx.arc(lx,ly,4,0,Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#8a8fa5'; ctx.fillText(l.label, lx+10, ly+4);
                    lx += 80;
                });

                // Ï†úÎ™© Î∞è Í±∞Î¶¨ Ï†ïÎ≥¥
                ctx.fillStyle = '#ffffff'; ctx.font = '14px Arial';
                let titleText = `Aim Trace - ${name || 'N/A'}`;
                
                // ÌÇ¨ Ïù¥Î≤§Ìä∏Í∞Ä ÏûàÏúºÎ©¥ Î¨¥Í∏∞ Ï†ïÎ≥¥ Î∞è ÍµêÏ†Ñ Í±∞Î¶¨ Ï∂îÍ∞Ä
                let engagementDistance = null;
                if (this.selectedEvent && this.selectedEvent.attacker && this.selectedEvent.victim) {
                    // Î¨¥Í∏∞ Ï†ïÎ≥¥ Ï∂îÍ∞Ä
                    if (this.selectedEvent.weapon) {
                        titleText += ` | Î¨¥Í∏∞: ${this.selectedEvent.weapon}`;
                    }
                    
                    // ÍµêÏ†Ñ Í±∞Î¶¨ Ï†ïÎ≥¥ Ï∂îÍ∞Ä
                    const attackerPos = this.selectedEvent.attacker.position;
                    const victimPos = this.selectedEvent.victim.position;
                    if (attackerPos && victimPos && attackerPos[0] !== null && victimPos[0] !== null) {
                        // 3D Ïú†ÌÅ¥Î¶¨Îìú Í±∞Î¶¨ Í≥ÑÏÇ∞ (Source ÏóîÏßÑ Ï¢åÌëúÍ≥Ñ)
                        // position Î∞∞Ïó¥: [X, Z, Y] (X: Ï¢åÏö∞, Y: Ï†ÑÌõÑ, Z: ÎÜíÏù¥)
                        const dx = attackerPos[0] - victimPos[0]; // X Ï∞®Ïù¥
                        const dy = attackerPos[1] - victimPos[1]; // Z Ï∞®Ïù¥ (ÎÜíÏù¥)
                        const dz = attackerPos[2] - victimPos[2]; // Y Ï∞®Ïù¥ (Ï†ÑÌõÑ)
                        const distanceUnits = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        
                        // Source ÏóîÏßÑ Îã®ÏúÑ Î≥ÄÌôò: 1 unit = 0.75 Ïù∏Ïπò = ÏïΩ 1.905 cm
                        // ÎòêÎäî 1 unit = 1 Ïù∏Ïπò = 2.54 cm (ÏùºÎ∂Ä Í≤åÏûÑ)
                        // CS:GO/CS2 Í∏∞Ï§Ä: 1 unit = 0.75 Ïù∏Ïπò = 1.905 cm
                        const distanceMeters = distanceUnits * 0.75 * 2.54 / 100; // ÎØ∏ÌÑ∞Î°ú Î≥ÄÌôò
                        const distanceFeet = distanceUnits * 0.75 / 12; // ÌîºÌä∏Î°ú Î≥ÄÌôò
                        
                        engagementDistance = distanceUnits;
                        titleText += ` | ÍµêÏ†Ñ Í±∞Î¶¨: ${distanceUnits.toFixed(1)} units (${distanceMeters.toFixed(2)}m / ${distanceFeet.toFixed(1)}ft)`;
                    }
                }
                
                ctx.fillText(titleText, pad, 20);
                
                // Ï∂îÍ∞Ä Î∂ÑÏÑù Ï†ïÎ≥¥ ÌëúÏãú (ÏûÑÏùò Í∞í)
                if (this.selectedEvent && this.selectedEvent.weapon) {
                    let yOffset = 45;
                    ctx.font = '12px Arial';
                    ctx.fillStyle = '#8a8fa5';
                    
                    // Î¨¥Í∏∞ Ïú†Ìö® ÏÇ¨Í±∞Î¶¨ Î∞è KILL Ïú†Ìö®ÏÑ±
                    const weaponEffectiveRange = 500; // ÏûÑÏùò Í∞í (units)
                    const killValidity = engagementDistance ? (engagementDistance <= weaponEffectiveRange ? 'Ïú†Ìö®' : 'ÎπÑÏú†Ìö®') : 'N/A';
                    const validityColor = killValidity === 'Ïú†Ìö®' ? '#4caf50' : '#ff6b6b';
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(`Î¨¥Í∏∞ Ïú†Ìö® ÏÇ¨Í±∞Î¶¨: ${weaponEffectiveRange} units`, pad, yOffset);
                    yOffset += 18;
                    
                    ctx.fillStyle = validityColor;
                    ctx.fillText(`ÍµêÏ†Ñ Í±∞Î¶¨ Î∞è KILL Ïú†Ìö®ÏÑ±: ${killValidity}`, pad, yOffset);
                    yOffset += 18;
                    
                    // ÏõîÌïµ ÌÉêÏßÄ
                    const wallhackDetected = Math.random() > 0.7 ? 'ÏùòÏã¨' : 'Ï†ïÏÉÅ'; // ÏûÑÏùò Í∞í
                    const wallhackColor = wallhackDetected === 'ÏùòÏã¨' ? '#ff6b6b' : '#4caf50';
                    ctx.fillStyle = wallhackColor;
                    ctx.fillText(`Î≤Ω Í¥ÄÌÜµ ÌÉêÏßÄ (ÏõîÌïµ): ${wallhackDetected}`, pad, yOffset);
                    yOffset += 18;
                    
                    // AIM Ïù¥Îèô Ìå®ÌÑ¥ Ïù¥ÏÉÅ Ï†êÏàò
                    const aimAnomalyScore = (Math.random() * 100).toFixed(1); // ÏûÑÏùò Í∞í (0-100)
                    const anomalyColor = parseFloat(aimAnomalyScore) > 70 ? '#ff6b6b' : (parseFloat(aimAnomalyScore) > 40 ? '#ffa500' : '#4caf50');
                    ctx.fillStyle = anomalyColor;
                    ctx.fillText(`AIM Ïù¥Îèô Ìå®ÌÑ¥ Ïù¥ÏÉÅ Ï†êÏàò: ${aimAnomalyScore}`, pad, yOffset);
                }
            }

            generateReport(playerName) {
                if (!this.data || !playerName) return;
                
                const stats = this.data.metadata.playerStats[playerName] || { kills: 0, deaths: 0, team: '' };
                // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä ÌÇ¨Ìïú Ïù¥Î≤§Ìä∏Îßå ÌïÑÌÑ∞ÎßÅ (Ï§ëÎ≥µ Ï†úÍ±∞)
                let playerKills = this.data.events.filter(e => 
                    e.attacker && e.attacker.name === playerName &&
                    e.event_type_lower && e.event_type_lower.includes('kill')
                );
                
                // Í∞ôÏùÄ tickÏùò Ï§ëÎ≥µ ÌÇ¨ Ï†úÍ±∞
                const seenTicks = new Set();
                playerKills = playerKills.filter(e => {
                    if (seenTicks.has(e.tick)) {
                        return false;
                    }
                    seenTicks.add(e.tick);
                    return true;
                });
                
                console.log('Generate Report - ÌîåÎ†àÏù¥Ïñ¥ ÌÇ¨ Ïàò (Ï§ëÎ≥µ Ï†úÍ±∞ ÌõÑ):', playerKills.length);
                
                // Í∞Å ÌÇ¨ Ïù¥Î≤§Ìä∏Î≥ÑÎ°ú Aim Trace ÏÉùÏÑ± (¬±30Ìã± Î≤îÏúÑ)
                const killTraceImages = [];
                
                playerKills.forEach((killEvent, killIdx) => {
                    // ÌÇ¨ Ïù¥Î≤§Ìä∏Ïùò Ìã± Ïù∏Îç±Ïä§ Ï∞æÍ∏∞
                    const killTickIdx = this.data.positions.findIndex(p => p.tick === killEvent.tick);
                    if (killTickIdx === -1) return;
                    
                    // ¬±30Ìã± Î≤îÏúÑ Í≥ÑÏÇ∞
                    const startIdx = Math.max(0, killTickIdx - 30);
                    const endIdx = Math.min(this.data.positions.length - 1, killTickIdx + 30);
                    
                    // Ìï¥Îãπ Î≤îÏúÑÏùò Aim Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
                    const killAimData = [];
                    for (let idx = startIdx; idx <= endIdx; idx++) {
                        const pos = this.data.positions[idx];
                        if (pos) {
                            const player = pos.players.find(p => p.name === playerName);
                            if (player && player.yaw !== null && player.yaw !== undefined && !Number.isNaN(player.yaw) &&
                                player.pitch !== null && player.pitch !== undefined && !Number.isNaN(player.pitch)) {
                                killAimData.push({
                                    yaw: player.yaw,
                                    pitch: player.pitch,
                                    time: pos.game_time,
                                    tick: pos.tick,
                                    tickIdx: idx,
                                    type: idx === killTickIdx ? 'kill' : 'move'
                                });
                            }
                        }
                    }
                    
                    if (killAimData.length === 0) return;
                    
                    // Ï§ëÎ≥µ Ï†úÍ±∞ (Ïó∞ÏÜçÎêú Í∞ôÏùÄ Í∞í)
                    const uniqueKillAimData = [];
                    let lastYaw = null;
                    let lastPitch = null;
                    killAimData.forEach(s => {
                        if (lastYaw === null || lastPitch === null ||
                            Math.abs(s.yaw - lastYaw) > 0.01 || Math.abs(s.pitch - lastPitch) > 0.01) {
                            uniqueKillAimData.push(s);
                            lastYaw = s.yaw;
                            lastPitch = s.pitch;
                        }
                    });
                    
                    // Aim Trace Ï∫îÎ≤ÑÏä§ ÏÉùÏÑ±
                    const killTraceCanvas = document.createElement('canvas');
                    killTraceCanvas.width = 800;
                    killTraceCanvas.height = 600;
                    const killCtx = killTraceCanvas.getContext('2d');
                    
                    // ÎèôÏ†Å Î≤îÏúÑ Í≥ÑÏÇ∞
                    const yaws = uniqueKillAimData.map(s => s.yaw);
                    const pitches = uniqueKillAimData.map(s => s.pitch);
                    let xMin = Math.min(...yaws);
                    let xMax = Math.max(...yaws);
                    let yMin = Math.min(...pitches);
                    let yMax = Math.max(...pitches);
                    
                    // Î≤îÏúÑÍ∞Ä ÎÑàÎ¨¥ Ï¢ÅÏúºÎ©¥ ÌôïÎåÄ
                    const xRange = xMax - xMin;
                    const yRange = yMax - yMin;
                    if (xRange < 10) {
                        const center = (xMin + xMax) / 2;
                        xMin = center - 10;
                        xMax = center + 10;
                    }
                    if (yRange < 10) {
                        const center = (yMin + yMax) / 2;
                        yMin = center - 10;
                        yMax = center + 10;
                    }
                    
                    // Ìå®Îî© Ï∂îÍ∞Ä
                    const xPadding = (xMax - xMin) * 0.1;
                    const yPadding = (yMax - yMin) * 0.1;
                    xMin -= xPadding;
                    xMax += xPadding;
                    yMin -= yPadding;
                    yMax += yPadding;
                    
                    const pad = 40;
                    const W = killTraceCanvas.width, H = killTraceCanvas.height;
                    
                    function xScale(v){ return pad + (v - xMin) / (xMax - xMin) * (W - 2*pad); }
                    function yScale(v){ return H - (pad + (v - yMin) / (yMax - yMin) * (H - 2*pad)); }
                    
                    // Î∞∞Í≤Ω
                    killCtx.fillStyle = '#0a0e15';
                    killCtx.fillRect(0, 0, W, H);
                    
                    // Í∑∏Î¶¨Îìú
                    killCtx.strokeStyle = '#2a2f3e';
                    killCtx.lineWidth = 1;
                    const xStep = Math.max(10, Math.ceil((xMax - xMin) / 10));
                    const yStep = Math.max(5, Math.ceil((yMax - yMin) / 10));
                    for (let x = Math.floor(xMin / xStep) * xStep; x <= xMax; x += xStep) {
                        const sx = xScale(x);
                        if (sx >= pad && sx <= W - pad) {
                            killCtx.beginPath();
                            killCtx.moveTo(sx, pad);
                            killCtx.lineTo(sx, H - pad);
                            killCtx.stroke();
                        }
                    }
                    for (let y = Math.floor(yMin / yStep) * yStep; y <= yMax; y += yStep) {
                        const sy = yScale(y);
                        if (sy >= pad && sy <= H - pad) {
                            killCtx.beginPath();
                            killCtx.moveTo(pad, sy);
                            killCtx.lineTo(W - pad, sy);
                            killCtx.stroke();
                        }
                    }
                    
                    // Í≤ΩÎ°ú Ïó∞Í≤∞ÏÑ†
                    if (uniqueKillAimData.length > 1) {
                        killCtx.beginPath();
                        killCtx.strokeStyle = '#5a637a';
                        killCtx.lineWidth = 1.5;
                        killCtx.moveTo(xScale(uniqueKillAimData[0].yaw), yScale(uniqueKillAimData[0].pitch));
                        for (let i = 1; i < uniqueKillAimData.length; i++) {
                            killCtx.lineTo(xScale(uniqueKillAimData[i].yaw), yScale(uniqueKillAimData[i].pitch));
                        }
                        killCtx.stroke();
                    }
                    
                    // Ìè¨Ïù∏Ìä∏
                    uniqueKillAimData.forEach(s => {
                        const x = xScale(s.yaw), y = yScale(s.pitch);
                        if (s.type === 'kill') {
                            // Kill ÏãúÏ†ê: ÏßÑÎπ®Í∞ï ÌÅ∞ Ïõê + ÌÖåÎëêÎ¶¨
                            killCtx.fillStyle = '#cc0000';
                            killCtx.beginPath();
                            killCtx.arc(x, y, 5, 0, Math.PI*2);
                            killCtx.fill();
                            killCtx.strokeStyle = '#ff3333';
                            killCtx.lineWidth = 2;
                            killCtx.stroke();
                        } else {
                            // ÏùºÎ∞ò Ïù¥Îèô Ìè¨Ïù∏Ìä∏: ÏûëÏùÄ ÌöåÏÉâ Ï†ê
                            killCtx.fillStyle = '#8a8fa5';
                            killCtx.beginPath();
                            killCtx.arc(x, y, 2, 0, Math.PI*2);
                            killCtx.fill();
                        }
                    });
                    
                    // Ï†úÎ™© Î∞è Ï†ïÎ≥¥
                    killCtx.fillStyle = '#ffffff';
                    killCtx.font = 'bold 16px Arial';
                    killCtx.fillText(`Kill #${killIdx + 1} - ${killEvent.victim ? killEvent.victim.name : 'Unknown'}`, pad, 25);
                    killCtx.font = '12px Arial';
                    killCtx.fillStyle = '#8a8fa5';
                    const timeStr = killEvent.game_time ? `${Math.floor(killEvent.game_time / 60)}:${(killEvent.game_time % 60).toFixed(2)}` : 'N/A';
                    killCtx.fillText(`Time: ${timeStr} | Tick: ${killEvent.tick}`, pad, 45);
                    killCtx.fillText(`Yaw: [${xMin.toFixed(1)} ~ ${xMax.toFixed(1)}] Pitch: [${yMin.toFixed(1)} ~ ${yMax.toFixed(1)}]`, pad, H - 15);
                    
                    killTraceImages.push({
                        image: killTraceCanvas.toDataURL('image/png'),
                        killNum: killIdx + 1,
                        victim: killEvent.victim ? killEvent.victim.name : 'Unknown',
                        time: timeStr
                    });
                });
                
                // Î™®Îì† ÌÇ¨ Ìä∏Î†àÏù¥Ïä§Î•º ÌïòÎÇòÏùò Ïù¥ÎØ∏ÏßÄÎ°ú Ìï©ÏπòÍ∏∞ (ÏÑ∏Î°úÎ°ú Î∞∞Ïπò) - ÎπÑÎèôÍ∏∞ Ï≤òÎ¶¨
                const generateCombinedImage = () => {
                    return new Promise((resolve) => {
                        if (killTraceImages.length === 0) {
                            resolve('');
                            return;
                        }
                        
                        const combinedCanvas = document.createElement('canvas');
                        const traceHeight = 600;
                        const traceSpacing = 20;
                        combinedCanvas.width = 800;
                        combinedCanvas.height = killTraceImages.length * (traceHeight + traceSpacing) - traceSpacing;
                        const combinedCtx = combinedCanvas.getContext('2d');
                        
                        combinedCtx.fillStyle = '#1a1f2e';
                        combinedCtx.fillRect(0, 0, combinedCanvas.width, combinedCanvas.height);
                        
                        let loadedCount = 0;
                        killTraceImages.forEach((trace, idx) => {
                            const img = new Image();
                            img.onload = () => {
                                const y = idx * (traceHeight + traceSpacing);
                                combinedCtx.drawImage(img, 0, y);
                                loadedCount++;
                                if (loadedCount === killTraceImages.length) {
                                    resolve(combinedCanvas.toDataURL('image/png'));
                                }
                            };
                            img.onerror = () => {
                                loadedCount++;
                                if (loadedCount === killTraceImages.length) {
                                    resolve(combinedCanvas.toDataURL('image/png'));
                                }
                            };
                            img.src = trace.image;
                        });
                    });
                };
                
                // Î≥¥Í≥†ÏÑú ÏÉùÏÑ± (Ïù¥ÎØ∏ÏßÄ Î°úÎî© ÎåÄÍ∏∞)
                generateCombinedImage().then(combinedAimTraceImage => {
                
                    // Ïñ∏Ïñ¥Î≥Ñ ÌÖçÏä§Ìä∏ Ï†ïÏùò
                    const texts = {
                        ko: {
                            title: 'ÌîåÎ†àÏù¥Ïñ¥ Î≥¥Í≥†ÏÑú',
                            generated: 'ÏÉùÏÑ± ÏãúÍ∞Ñ',
                            userInfo: 'Ïú†Ï†Ä Í∏∞Î≥∏ Ï†ïÎ≥¥',
                            deviceType: 'Í∏∞Í∏∞ ÏÇ¨Ïö© ÌÉÄÏûÖ',
                            kdRatio: 'K/D ÎπÑÏú®',
                            headshotRate: 'Ìó§ÎìúÏÉ∑ ÎπÑÏú®',
                            matchStats: 'Îß§Ïπò ÌÜµÍ≥Ñ',
                            team: 'ÌåÄ',
                            kills: 'ÌÇ¨',
                            deaths: 'Îç∞Ïä§',
                            totalKills: 'Ï¥ù ÌÇ¨ Ïàò',
                            killTraces: 'ÌÇ¨ Í∂§Ï†Å',
                            killEvents: 'ÌÇ¨ Ïù¥Î≤§Ìä∏',
                            time: 'ÏãúÍ∞Ñ',
                            event: 'Ïù¥Î≤§Ìä∏',
                            victim: 'ÌîºÌï¥Ïûê',
                            weapon: 'Î¨¥Í∏∞',
                            headshot: 'Ìó§ÎìúÏÉ∑',
                            kill: 'ÌÇ¨',
                            death: 'Îç∞Ïä§',
                            yes: 'Ïòà',
                            no: 'ÏïÑÎãàÏò§',
                            aimAnalysis: 'ÏóêÏûÑ Ïù¥Îèô Î∂ÑÏÑù - ÌÇ¨ Ïù¥Î≤§Ìä∏',
                            totalKillsCount: 'Ï¥ù ÌÇ¨ Ïàò',
                            tracesGenerated: 'ÏÉùÏÑ±Îêú ÌÇ¨ Í∂§Ï†Å',
                            individualTraces: 'Í∞úÎ≥Ñ ÌÇ¨ ÏóêÏûÑ Í∂§Ï†Å (Í∞Å ÌÇ¨ Ï£ºÎ≥Ä ¬±30 Ìã±)',
                            killNum: 'ÌÇ¨ #',
                            noKillEvents: 'ÏóêÏûÑ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÎäî ÌÇ¨ Ïù¥Î≤§Ìä∏Í∞Ä ÏóÜÏäµÎãàÎã§',
                            download: 'Îã§Ïö¥Î°úÎìú'
                        },
                        en: {
                            title: 'Player Report',
                            generated: 'Generated',
                            userInfo: 'User Basic Information',
                            deviceType: 'Device Type',
                            kdRatio: 'K/D Ratio',
                            headshotRate: 'Headshot Rate',
                            matchStats: 'Match Statistics',
                            team: 'Team',
                            kills: 'Kills',
                            deaths: 'Deaths',
                            totalKills: 'Total Kills',
                            killTraces: 'Kill Traces',
                            killEvents: 'Kill Events',
                            time: 'Time',
                            event: 'Event',
                            victim: 'Victim',
                            weapon: 'Weapon',
                            headshot: 'Headshot',
                            kill: 'KILLED',
                            death: 'DIED',
                            yes: 'Yes',
                            no: 'No',
                            aimAnalysis: 'Aim Movement Analysis - Kill Events',
                            totalKillsCount: 'Total Kills',
                            tracesGenerated: 'Kill Traces Generated',
                            individualTraces: 'Individual Kill Aim Traces (¬±30 ticks around each kill)',
                            killNum: 'Kill #',
                            noKillEvents: 'No kill events with aim data available',
                            download: 'Download'
                        }
                    };
                    
                    const t = texts[this.language];
                    
                    // Î≥¥Í≥†ÏÑú HTML ÏÉùÏÑ±
                    const reportHTML = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>${t.title} - ${playerName}</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #1a1f2e; color: #fff; }
        .header { border-bottom: 2px solid #4a90e2; padding-bottom: 10px; margin-bottom: 20px; }
        .section { margin: 20px 0; padding: 15px; background: #2a2f3e; border-radius: 8px; }
        .stat-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; }
        .stat-item { padding: 10px; background: #1a1f2e; border-radius: 4px; }
        .stat-label { color: #8a8fa5; font-size: 12px; }
        .stat-value { color: #fff; font-size: 18px; font-weight: bold; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #3a3f4e; }
        th { background: #1a1f2e; color: #4a90e2; }
    </style>
</head>
<body>
    <button id="download-btn" style="position:fixed; top:16px; right:16px; background:#4a90e2; color:#fff; border:none; padding:8px 12px; border-radius:4px; cursor:pointer; box-shadow:0 2px 6px rgba(0,0,0,0.3);">${t.download}</button>
    <div class="header">
        <h1>${t.title}</h1>
        <h2>${playerName}</h2>
        <p>${t.generated}: ${new Date().toLocaleString(this.language === 'ko' ? 'ko-KR' : 'en-US')}</p>
    </div>
    
    <div class="section">
        <h3>${t.userInfo}</h3>
        <div class="stat-grid">
            <div class="stat-item">
                <div class="stat-label">${t.deviceType}</div>
                <div class="stat-value">${this.language === 'ko' ? (Math.random() > 0.8 ? 'Ìå®Îìú' : 'ÌÇ§/Îßà') : (Math.random() > 0.8 ? 'Controller' : 'Keyboard/Mouse')}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">${t.kdRatio}</div>
                <div class="stat-value">${stats.deaths > 0 ? (stats.kills / stats.deaths).toFixed(2) : stats.kills.toFixed(2)}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">${t.headshotRate}</div>
                <div class="stat-value">${((playerKills.filter(e => e.headshot).length / Math.max(playerKills.length, 1)) * 100).toFixed(1)}%</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">high_crit_rate</div>
                <div class="stat-value">${(Math.random() * 100).toFixed(1)}%</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">high_hit_rate</div>
                <div class="stat-value">${(Math.random() * 100).toFixed(1)}%</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">massive_reports</div>
                <div class="stat-value">${Math.floor(Math.random() * 50)}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">recursive_massive_reports</div>
                <div class="stat-value">${Math.random() > 0.7 ? 'ÌÉêÏßÄÎê®' : 'ÏóÜÏùå'}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">DPI/Í∞êÎèÑ Ìå®ÌÑ¥</div>
                <div class="stat-value">${Math.floor(Math.random() * 1600) + 400} DPI / ${(Math.random() * 3 + 0.5).toFixed(2)}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">EAC/NCGUARD ÌÉêÏßÄ</div>
                <div class="stat-value">${Math.random() > 0.8 ? 'ÏùòÏã¨ Í∏∞Î°ù ÏûàÏùå' : 'Ï†ïÏÉÅ'}</div>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>${t.matchStats}</h3>
        <div class="stat-grid">
            <div class="stat-item">
                <div class="stat-label">${t.team}</div>
                <div class="stat-value">${stats.team || 'N/A'}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">${t.kills}</div>
                <div class="stat-value">${stats.kills}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">${t.deaths}</div>
                <div class="stat-value">${stats.deaths}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">${t.totalKills}</div>
                <div class="stat-value">${playerKills.length}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">${t.killTraces}</div>
                <div class="stat-value">${killTraceImages.length}</div>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>${t.killEvents}</h3>
        <table>
            <tr><th>${t.time}</th><th>${t.event}</th><th>${t.victim}</th><th>${t.weapon}</th><th>${t.headshot}</th></tr>
            ${playerKills.slice(0, 20).map(e => `
                <tr>
                    <td>${this.formatTime(e.game_time)}</td>
                    <td>${e.attacker.name === playerName ? t.kill : t.death}</td>
                    <td>${e.attacker.name === playerName ? e.victim.name : e.attacker.name}</td>
                    <td>${e.weapon || 'N/A'}</td>
                    <td>${e.headshot ? t.yes : t.no}</td>
                </tr>
            `).join('')}
        </table>
    </div>
    
    <div class="section">
        <h3>${t.aimAnalysis}</h3>
        <p>${t.totalKillsCount}: ${playerKills.length}</p>
        <p>${t.tracesGenerated}: ${killTraceImages.length}</p>
        ${killTraceImages.length > 0 ? `
            <div style="margin-top: 15px;">
                <h4>${t.individualTraces}</h4>
                ${killTraceImages.map(trace => `
                    <div style="margin-bottom: 30px; padding: 15px; background: #1a1f2e; border-radius: 4px;">
                        <h5 style="color: #4a90e2; margin-bottom: 10px;">${t.killNum}${trace.killNum} - ${trace.victim} (${t.time}: ${trace.time})</h5>
                        <img src="${trace.image}" style="max-width: 100%; border: 1px solid #3a3f4e; border-radius: 4px;" />
                    </div>
                `).join('')}
                
            </div>
        ` : `<p>${t.noKillEvents}</p>`}
    </div>
</body>
<script>
    (function(){
        const btn = document.getElementById('download-btn');
        if (btn) {
            btn.addEventListener('click', function(){
                const html = document.documentElement.outerHTML;
                const blob = new Blob([html], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const filename = 'report_' + '${playerName}' + '_' + Date.now() + '.html';
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            });
        }
    })();
<\/script>
</html>
                `;
                    
                    // ÏÉà Ï∞ΩÏúºÎ°ú Ïó¥Í∏∞
                    const win = window.open('', '_blank');
                    this.currentReportWindow = win; // ÌòÑÏû¨ Î≥¥Í≥†ÏÑú Ï∞Ω Ï†ÄÏû•
                    win.document.write(reportHTML);
                    win.document.close();
                    
                    // Îã§Ïö¥Î°úÎìúÎäî Î¶¨Ìè¨Ìä∏ Ïö∞Ï∏° ÏÉÅÎã® Î≤ÑÌäºÏùÑ ÌÜµÌï¥ ÏàòÌñâ
                });
            }

            async loadMapData() {
                // Ïô∏Î∂ÄÏóêÏÑú Îßµ Îç∞Ïù¥ÌÑ∞Î•º Í∞ÄÏ†∏Ïò§Îäî ÏãúÎèÑ
                const mapDataSources = [
                    // GitHub Raw ContentÎ•º ÌÜµÌïú Îßµ Îç∞Ïù¥ÌÑ∞ (ÏòàÏãú)
                    'https://raw.githubusercontent.com/your-repo/cs2-map-data/main/maps.json',
                    // Î°úÏª¨ Îßµ Îç∞Ïù¥ÌÑ∞ ÌååÏùº (ÌîÑÎ°úÏ†ùÌä∏Ïóê Ìè¨Ìï®)
                    './map_data.json'
                ];
                
                // Í∏∞Î≥∏ Îßµ Îç∞Ïù¥ÌÑ∞ (fallback)
                const defaultMapData = {
                    'Anubis': { 
                        minX: -2000, maxX: 2000, 
                        minY: -2000, maxY: 2000, 
                        minZ: -100, maxZ: 500,
                        centerX: 0, centerY: 0, centerZ: 200
                    },
                    'Dust2': { 
                        minX: -2500, maxX: 2500, 
                        minY: -2500, maxY: 2500, 
                        minZ: -200, maxZ: 600,
                        centerX: 0, centerY: 0, centerZ: 200
                    },
                    'Inferno': { 
                        minX: -3000, maxX: 3000, 
                        minY: -3000, maxY: 3000, 
                        minZ: -150, maxZ: 500,
                        centerX: 0, centerY: 0, centerZ: 175
                    },
                    'Mirage': { 
                        minX: -2800, maxX: 2800, 
                        minY: -2800, maxY: 2800, 
                        minZ: -100, maxZ: 550,
                        centerX: 0, centerY: 0, centerZ: 225
                    },
                    'Overpass': { 
                        minX: -3500, maxX: 3500, 
                        minY: -3500, maxY: 3500, 
                        minZ: -200, maxZ: 600,
                        centerX: 0, centerY: 0, centerZ: 200
                    },
                    'Nuke': {
                        minX: -4000, maxX: 4000,
                        minY: -4000, maxY: 4000,
                        minZ: -500, maxZ: 800,
                        centerX: 0, centerY: 0, centerZ: 150
                    },
                    'Vertigo': {
                        minX: -3000, maxX: 3000,
                        minY: -3000, maxY: 3000,
                        minZ: -100, maxZ: 1200,
                        centerX: 0, centerY: 0, centerZ: 550
                    },
                    'Ancient': {
                        minX: -3200, maxX: 3200,
                        minY: -3200, maxY: 3200,
                        minZ: -150, maxZ: 600,
                        centerX: 0, centerY: 0, centerZ: 225
                    }
                };
                
                // Ïô∏Î∂Ä ÏÜåÏä§ÏóêÏÑú Îßµ Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏãúÎèÑ
                for (const source of mapDataSources) {
                    try {
                        const response = await fetch(source);
                        if (response.ok) {
                            const externalData = await response.json();
                            // Ïô∏Î∂Ä Îç∞Ïù¥ÌÑ∞ÏôÄ Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞ Î≥ëÌï© (Ïô∏Î∂Ä Îç∞Ïù¥ÌÑ∞Í∞Ä Ïö∞ÏÑ†)
                            this.mapData = { ...defaultMapData, ...externalData };
                            // Ïô∏Î∂Ä Îç∞Ïù¥ÌÑ∞Ïùò Í∞Å ÎßµÏóê ÎåÄÌï¥ Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞ Î≥ëÌï© (geometry Ïú†ÏßÄ)
                            for (const mapName in externalData) {
                                if (defaultMapData[mapName]) {
                                    this.mapData[mapName] = { ...defaultMapData[mapName], ...externalData[mapName] };
                                }
                            }
                            console.log('Ïô∏Î∂Ä Îßµ Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏÑ±Í≥µ:', source);
                            
                            // Ïù¥ÎØ∏ ÎßµÏù¥ Î°úÎìúÎêòÏñ¥ ÏûàÏúºÎ©¥ ÏßÄÏò§Î©îÌä∏Î¶¨ Îã§Ïãú Î†åÎçîÎßÅ
                            if (this.detectedMapName && this.mapData[this.detectedMapName]) {
                                this.renderMapGeometry(this.detectedMapName);
                            }
                            
                            return this.mapData;
                        }
                    } catch (error) {
                        console.log('Ïô∏Î∂Ä Îßµ Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®:', source, error);
                        continue;
                    }
                }
                
                // Î™®Îì† Ïô∏Î∂Ä ÏÜåÏä§ Ïã§Ìå® Ïãú Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©
                this.mapData = defaultMapData;
                console.log('Í∏∞Î≥∏ Îßµ Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©');
                return this.mapData;
            }
            
            detectMapFromBounds(bounds) {
                // Îßµ Îç∞Ïù¥ÌÑ∞Í∞Ä Î°úÎìúÎêòÏßÄ ÏïäÏïòÏúºÎ©¥ Î°úÎìú
                if (!this.mapData) {
                    this.loadMapData().then(() => {
                        // Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÌõÑ Îã§Ïãú ÏãúÎèÑ
                        return this.detectMapFromBounds(bounds);
                    });
                    return null;
                }
                
                // Îßµ Î≤îÏúÑÏôÄ ÎπÑÍµêÌïòÏó¨ Í∞ÄÏû• Ïú†ÏÇ¨Ìïú Îßµ Ï∞æÍ∏∞
                let bestMatch = null;
                let bestScore = 0;
                
                for (const [mapName, mapRange] of Object.entries(this.mapData)) {
                    const expectedWidth = mapRange.maxX - mapRange.minX;
                    const expectedDepth = mapRange.maxY - mapRange.minY;
                    const expectedHeight = mapRange.maxZ - mapRange.minZ;
                    
                    // ÎÑàÎπÑ, ÍπäÏù¥, ÎÜíÏù¥Ïùò Ïú†ÏÇ¨ÎèÑ Í≥ÑÏÇ∞
                    const widthDiff = Math.abs(bounds.width - expectedWidth) / expectedWidth;
                    const depthDiff = Math.abs(bounds.depth - expectedDepth) / expectedDepth;
                    const heightDiff = Math.abs(bounds.height - expectedHeight) / expectedHeight;
                    
                    // ÌèâÍ∑† Ï∞®Ïù¥ Í≥ÑÏÇ∞ (ÎÇÆÏùÑÏàòÎ°ù Ïú†ÏÇ¨)
                    const avgDiff = (widthDiff + depthDiff + heightDiff) / 3;
                    const score = 1 - avgDiff; // Ïú†ÏÇ¨ÎèÑ Ï†êÏàò (ÎÜíÏùÑÏàòÎ°ù Ïú†ÏÇ¨)
                    
                    if (score > bestScore && score > 0.3) { // 30% Ïù¥ÏÉÅ Ïú†ÏÇ¨ÎèÑ
                        bestScore = score;
                        bestMatch = mapName;
                    }
                }
                
                return bestMatch;
            }
            
            async renderMapGeometry(mapName) {
                // Îßµ ÏßÄÏò§Î©îÌä∏Î¶¨ Îç∞Ïù¥ÌÑ∞ Î°úÎìú
                if (!this.mapData || !this.mapData[mapName] || !this.mapData[mapName].geometry) {
                    console.log('Îßµ ÏßÄÏò§Î©îÌä∏Î¶¨ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå:', mapName);
                    return;
                }
                
                const geometry = this.mapData[mapName].geometry;
                const mapGroup = new THREE.Group();
                mapGroup.name = 'mapGeometry';
                
                // Í∏∞Ï°¥ Îßµ ÏßÄÏò§Î©îÌä∏Î¶¨ Ï†úÍ±∞
                const existingMap = this.scene.getObjectByName('mapGeometry');
                if (existingMap) {
                    this.scene.remove(existingMap);
                }
                
                // Î≤Ω Î†åÎçîÎßÅ
                if (geometry.walls && geometry.walls.length > 0) {
                    const wallMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x4a5568, 
                        metalness: 0.3,
                        roughness: 0.7,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    geometry.walls.forEach(wall => {
                        const wallGeometry = new THREE.BoxGeometry(wall.width, wall.height, wall.depth);
                        const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
                        wallMesh.position.set(wall.x, wall.z + wall.height / 2, wall.y);
                        if (wall.rotation) {
                            wallMesh.rotation.y = wall.rotation * Math.PI / 180;
                        }
                        wallMesh.castShadow = true;
                        wallMesh.receiveShadow = true;
                        mapGroup.add(wallMesh);
                    });
                }
                
                // Í±¥Î¨º Î†åÎçîÎßÅ
                if (geometry.buildings && geometry.buildings.length > 0) {
                    const buildingMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x2d3748, 
                        metalness: 0.2,
                        roughness: 0.8,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    geometry.buildings.forEach(building => {
                        const buildingGeometry = new THREE.BoxGeometry(building.width, building.height, building.depth);
                        const buildingMesh = new THREE.Mesh(buildingGeometry, buildingMaterial);
                        buildingMesh.position.set(building.x, building.z + building.height / 2, building.y);
                        if (building.rotation) {
                            buildingMesh.rotation.y = building.rotation * Math.PI / 180;
                        }
                        buildingMesh.castShadow = true;
                        buildingMesh.receiveShadow = true;
                        mapGroup.add(buildingMesh);
                    });
                }
                
                // Ìè≠ÌÉÑ ÏÑ§Ïπò ÏßÄÏ†ê ÌëúÏãú
                if (geometry.sites && geometry.sites.length > 0) {
                    const siteMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xff6b6b, 
                        emissive: 0xff0000,
                        emissiveIntensity: 0.3,
                        transparent: true,
                        opacity: 0.6
                    });
                    
                    geometry.sites.forEach(site => {
                        const siteGeometry = new THREE.CylinderGeometry(50, 50, 5, 16);
                        const siteMesh = new THREE.Mesh(siteGeometry, siteMaterial);
                        siteMesh.position.set(site.x, site.z + 2.5, site.y);
                        siteMesh.rotation.x = Math.PI / 2;
                        mapGroup.add(siteMesh);
                        
                        // ÏÇ¨Ïù¥Ìä∏ Ïù¥Î¶Ñ ÎùºÎ≤® (ÏÑ†ÌÉùÏ†Å)
                        if (site.name) {
                            const loader = new THREE.FontLoader();
                            // ÌÖçÏä§Ìä∏Îäî ÎÇòÏ§ëÏóê Ï∂îÍ∞Ä Í∞ÄÎä•
                        }
                    });
                }
                
                // Ïä§Ìè∞ ÏßÄÏ†ê ÌëúÏãú
                if (geometry.spawns && geometry.spawns.length > 0) {
                    geometry.spawns.forEach(spawn => {
                        const spawnColor = spawn.team === 'CT' ? 0x4a90e2 : 0xff6b6b;
                        const spawnMaterial = new THREE.MeshStandardMaterial({ 
                            color: spawnColor, 
                            transparent: true,
                            opacity: 0.5
                        });
                        const spawnGeometry = new THREE.CylinderGeometry(30, 30, 10, 8);
                        const spawnMesh = new THREE.Mesh(spawnGeometry, spawnMaterial);
                        spawnMesh.position.set(spawn.x, spawn.z + 5, spawn.y);
                        spawnMesh.rotation.x = Math.PI / 2;
                        mapGroup.add(spawnMesh);
                    });
                }
                
                // Îßµ ÏßÄÏò§Î©îÌä∏Î¶¨Î•º Ïî¨Ïóê Ï∂îÍ∞Ä
                this.scene.add(mapGroup);
                console.log('Îßµ ÏßÄÏò§Î©îÌä∏Î¶¨ Î†åÎçîÎßÅ ÏôÑÎ£å:', mapName);
            }
            
            analyzeAndRenderPaths() {
                if (!this.data || !this.data.positions || !this.playerIndex) {
                    return;
                }
                
                // baseCameraDistanceÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏúºÎ©¥ Í≤ΩÎ°ú Î†åÎçîÎßÅ Í±¥ÎÑàÎõ∞Í∏∞
                if (!this.baseCameraDistance || this.baseCameraDistance <= 0) {
                    console.log('baseCameraDistanceÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïÑ Í≤ΩÎ°ú Î†åÎçîÎßÅÏùÑ Í±¥ÎÑàÎúÅÎãàÎã§.');
                    return;
                }
                
                // Í∏∞Ï°¥ Í≤ΩÎ°ú ÎùºÏù∏ Ï†úÍ±∞
                if (this.pathLines) {
                    this.pathLines.forEach(line => {
                        this.scene.remove(line);
                    });
                    this.pathLines = [];
                } else {
                    this.pathLines = [];
                }
                
                // Î™®Îì† ÌîåÎ†àÏù¥Ïñ¥Ïùò Ïù¥Îèô Í≤ΩÎ°úÎ•º Í∑∏ÎåÄÎ°ú Ï†êÏÑ†ÏúºÎ°ú Î†åÎçîÎßÅ
                this.playerIndex.forEach((positions, playerName) => {
                    if (positions.length < 2) return;
                    
                    // Í∞Å ÌîåÎ†àÏù¥Ïñ¥Ïùò Î™®Îì† Ïù¥Îèô Í≤ΩÎ°úÎ•º Ï†êÏÑ†ÏúºÎ°ú ÌëúÏãú
                    const pathPoints = [];
                    
                    for (let i = 0; i < positions.length; i++) {
                        const pos = positions[i].position;
                        if (pos && pos[0] !== null && pos[1] !== null) {
                            pathPoints.push(new THREE.Vector3(
                                pos[0], 
                                pos[2] || 0, 
                                pos[1]
                            ));
                        }
                    }
                    
                    if (pathPoints.length < 2) return;
                    
                    // Í≤ΩÎ°úÎ•º Ï†êÏÑ†ÏúºÎ°ú Î†åÎçîÎßÅ
                    const geometry = new THREE.BufferGeometry().setFromPoints(pathPoints);
                    
                    const material = new THREE.LineDashedMaterial({
                        color: 0xffffff, // Ìù∞ÏÉâ
                        linewidth: 2,
                        dashSize: 15,
                        gapSize: 10,
                        opacity: 0.7, // Ìà¨Î™ÖÎèÑ Ï¶ùÍ∞Ä
                        transparent: true
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    line.computeLineDistances(); // Ï†êÏÑ†ÏùÑ ÏúÑÌï¥ ÌïÑÏöî
                    this.scene.add(line);
                    this.pathLines.push(line);
                });
                
                console.log(`Î™®Îì† ÌîåÎ†àÏù¥Ïñ¥ Í≤ΩÎ°ú ${this.pathLines.length}Í∞ú Î†åÎçîÎßÅ ÏôÑÎ£å`);
            }
            
            // setupMapImageInput Ï†úÍ±∞Îê® (POCÏóêÏÑúÎäî ÏûêÎèô Î°úÎìúÎßå ÏÇ¨Ïö©)
            
            loadMapImageFromPath(imagePath) {
                if (!imagePath) return;
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(
                    imagePath,
                    (texture) => {
                        this.applyMapImageSettings(texture);
                        this.mapImageTexture = texture;
                        console.log('Îßµ Ïù¥ÎØ∏ÏßÄ ÌÖçÏä§Ï≤ò Î°úÎìú ÏôÑÎ£å:', imagePath);
                        
                        if (this.mapBounds) {
                            this.renderMapImage();
                            console.log('Îßµ Ïù¥ÎØ∏ÏßÄ ÏûêÎèô Î†åÎçîÎßÅ ÏôÑÎ£å');
                        } else {
                            console.log('Îßµ Í≤ΩÍ≥ÑÍ∞Ä ÏïÑÏßÅ Í≥ÑÏÇ∞ÎêòÏßÄ ÏïäÏùå. Îßµ Í≤ΩÍ≥Ñ Í≥ÑÏÇ∞ ÌõÑ ÏûêÎèô Î†åÎçîÎßÅÎê©ÎãàÎã§.');
                        }
                    },
                    undefined,
                    (error) => {
                        console.error('Îßµ Ïù¥ÎØ∏ÏßÄ Î°úÎìú Ïã§Ìå®:', imagePath, error);
                    }
                );
            }
            
            applyMapImageSettings(texture) {
                if (!texture || !this.mapImageSettings) return;
                const cfg = this.mapImageSettings;
                texture.wrapS = THREE.ClampToEdgeWrapping;
                texture.wrapT = THREE.ClampToEdgeWrapping;
                texture.repeat.set(cfg.repeatX ?? 1, cfg.repeatY ?? 1);
                texture.offset.set(cfg.offsetX ?? 0, cfg.offsetY ?? 0);
                texture.rotation = cfg.textureRotation ?? 0;
                texture.center.set(0.5, 0.5);
            }
            
            renderMapImage() {
                if (!this.mapImageTexture || !this.mapBounds) return;
                
                // Í∏∞Ï°¥ Îßµ Ïù¥ÎØ∏ÏßÄ Ï†úÍ±∞
                if (this.mapImagePlane) {
                    this.scene.remove(this.mapImagePlane);
                    this.mapImagePlane = null;
                }
                
                const bounds = this.mapBounds;
                // Ï¢åÌëúÍ≥Ñ Îß§Ìïë:
                // Í≤åÏûÑ Ï¢åÌëúÍ≥Ñ: X(Ï¢åÏö∞), Y(Ï†ÑÌõÑ), Z(ÎÜíÏù¥)
                // Three.js Ï¢åÌëúÍ≥Ñ: X(Ï¢åÏö∞), Y(ÎÜíÏù¥), Z(Ï†ÑÌõÑ)
                // ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπò: mesh.position.set(player.position[0], player.position[2], player.position[1])
                //   -> gameX -> sceneX, gameZ -> sceneY, gameY -> sceneZ
                
                // Îßµ Ïù¥ÎØ∏ÏßÄÎäî X-Z ÌèâÎ©¥Ïóê Î∞∞Ïπò (ÏúÑÏóêÏÑú ÎÇ¥Î†§Îã§Î≥º Îïå Î≥¥Ïù¥ÎèÑÎ°ù)
                // PlaneGeometryÎäî Í∏∞Î≥∏Ï†ÅÏúºÎ°ú Y-Z ÌèâÎ©¥Ïù¥ÎØÄÎ°ú X-Z ÌèâÎ©¥ÏúºÎ°ú ÌöåÏ†Ñ ÌïÑÏöî
                const cfg = this.mapImageSettings || {};
                const mapWidth = bounds.width * (cfg.scaleX ?? 1);   // X Î∞©Ìñ• (Ï¢åÏö∞)
                const mapDepth = bounds.depth * (cfg.scaleZ ?? 1);   // Y Î∞©Ìñ• (Ï†ÑÌõÑ) -> scene Z Î∞©Ìñ•
                
                // ÌèâÎ©¥ ÏßÄÏò§Î©îÌä∏Î¶¨ ÏÉùÏÑ± (Í∏∞Î≥∏ Y-Z ÌèâÎ©¥)
                const planeGeometry = new THREE.PlaneGeometry(mapWidth, mapDepth);
                
                // Ìà¨Î™ÖÎèÑ (Í∏∞Î≥∏Í∞í 80%)
                const opacity = 0.8;
                
                // Î®∏Ìã∞Î¶¨Ïñº ÏÉùÏÑ±
                const material = new THREE.MeshBasicMaterial({
                    map: this.mapImageTexture,
                    transparent: true,
                    opacity: opacity,
                    side: THREE.DoubleSide
                });
                
                // Î©îÏãú ÏÉùÏÑ±
                this.mapImagePlane = new THREE.Mesh(planeGeometry, material);
                
                // X-Z ÌèâÎ©¥Ïóê Î∞∞Ïπò (YÎäî ÎÜíÏù¥)
                // Í≤åÏûÑ Ï¢åÌëú: centerX, centerY, centerZ
                // Three.js Ï¢åÌëú: centerX, centerZ, centerY
                const worldOffsetX = cfg.worldOffsetX ?? 0;
                const worldOffsetZ = cfg.worldOffsetZ ?? 0;
                const verticalOffset = cfg.worldOffsetY ?? 0;
                const baseHeight = Number.isFinite(bounds.minZ)
                    ? bounds.minZ - 5
                    : (Number.isFinite(bounds.centerZ) ? bounds.centerZ - 5 : -5);
                this.mapImagePlane.position.set(
                    bounds.centerX + worldOffsetX,           // X: Ï¢åÏö∞ Ï§ëÏã¨
                    baseHeight + verticalOffset,             // Y: ÎÜíÏù¥
                    bounds.centerY + worldOffsetZ            // Z: Ï†ÑÌõÑ Ï§ëÏã¨
                );
                
                // X-Z ÌèâÎ©¥ÏúºÎ°ú ÌöåÏ†Ñ (XÏ∂ïÏúºÎ°ú -90ÎèÑ ÌöåÏ†Ñ)
                // PlaneGeometryÎäî Í∏∞Î≥∏Ï†ÅÏúºÎ°ú Y-Z ÌèâÎ©¥Ïù¥ÎØÄÎ°ú X-Z ÌèâÎ©¥ÏúºÎ°ú ÎßåÎì§Î†§Î©¥ XÏ∂ï ÌöåÏ†Ñ ÌïÑÏöî
                this.mapImagePlane.rotation.x = -Math.PI / 2;
                if (cfg.worldRotation) {
                    this.mapImagePlane.rotation.y = cfg.worldRotation;
                }
                
                // Ïî¨Ïóê Ï∂îÍ∞Ä (Î∞∞Í≤ΩÏúºÎ°ú ÏÇ¨Ïö©ÎêòÎØÄÎ°ú Î®ºÏ†Ä Ï∂îÍ∞Ä)
                this.scene.add(this.mapImagePlane);
                
                console.log('Îßµ Ïù¥ÎØ∏ÏßÄ Î†åÎçîÎßÅ ÏôÑÎ£å (X-Z ÌèâÎ©¥):', mapWidth, '√ó', mapDepth);
                console.log('Îßµ Í≤ΩÍ≥Ñ:', {
                    minX: bounds.minX, maxX: bounds.maxX,
                    minY: bounds.minY, maxY: bounds.maxY,
                    centerX: bounds.centerX, centerY: bounds.centerY, centerZ: bounds.centerZ
                });
            }
            
            removeMapImage() {
                if (this.mapImagePlane) {
                    this.scene.remove(this.mapImagePlane);
                    this.mapImagePlane = null;
                }
                if (this.mapImageTexture) {
                    this.mapImageTexture.dispose();
                    this.mapImageTexture = null;
                }
            }
            
            setupMapBounds() {
                if (!this.mapBounds) return;
                
                // Îßµ Í≤ΩÍ≥Ñ Î∞ïÏä§ ÌëúÏãú
                const bounds = this.mapBounds;
                const width = bounds.width;
                const height = bounds.depth;
                const depth = bounds.height;
                
                const geometry = new THREE.BoxGeometry(width, depth, height);
                const edges = new THREE.EdgesGeometry(geometry);
                const line = new THREE.LineSegments(
                    edges,
                    new THREE.LineBasicMaterial({ color: 0x4a90e2, opacity: 0.3, transparent: true })
                );
                line.position.set(bounds.centerX, bounds.centerZ, bounds.centerY);
                this.scene.add(line);
                
                // 2D Îßµ Ïù¥ÎØ∏ÏßÄ Î†åÎçîÎßÅ (Ïù¥ÎØ∏ÏßÄÍ∞Ä Î°úÎìúÎêú Í≤ΩÏö∞)
                if (this.mapImageTexture) {
                    this.renderMapImage();
                }
                
                // Îßµ ÏßÄÏò§Î©îÌä∏Î¶¨ Î†åÎçîÎßÅ (Í∞êÏßÄÎêú ÎßµÏù¥ ÏûàÏúºÎ©¥)
                if (this.detectedMapName) {
                    this.renderMapGeometry(this.detectedMapName);
                }
                
                // Ï£ºÏöî Í≤ΩÎ°ú Î†åÎçîÎßÅÏùÄ setupMapBounds() Ìò∏Ï∂ú ÌõÑ processData()ÏóêÏÑú ÏàòÌñâ
                
                // Ïπ¥Î©îÎùº ÏúÑÏπò Ï°∞Ï†ï Î∞è Í∏∞Î≥∏ Í±∞Î¶¨ ÏÑ§Ï†ï
                const maxDim = Math.max(width, height, depth);
                this.baseCameraDistance = maxDim * 1.2;
                this.cameraDistance = this.baseCameraDistance;
                this.camera.position.set(
                    bounds.centerX,
                    bounds.centerZ + maxDim * 0.8,
                    bounds.centerY + maxDim * 1.2
                );
                this.camera.lookAt(bounds.centerX, bounds.centerZ, bounds.centerY);
                
                // Í∑∏Î¶¨Îìú Ï°∞Ï†ï (Îçî Î™ÖÌôïÌïòÍ≤å)
                const gridSize = Math.max(width, height) * 1.2;
                const gridDivisions = Math.ceil(gridSize / 100); // 100 Îã®ÏúÑÎ°ú Íµ¨Î∂Ñ
                const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x4a90e2, 0x2a3f5a);
                gridHelper.position.set(bounds.centerX, 0, bounds.centerY);
                this.scene.add(gridHelper);
                
                // Íµ¨Ïó≠ ÌëúÏãúÎ•º ÏúÑÌïú ÏÑ† Ï∂îÍ∞Ä (10x10 Íµ¨Ïó≠)
                const sectorSize = Math.max(width, height) / 10;
                const sectorsHelper = new THREE.Group();
                
                // XÏ∂ï ÏÑ†
                for (let i = 0; i <= 10; i++) {
                    const x = bounds.minX + (width / 10) * i;
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(x, bounds.centerZ, bounds.minY),
                        new THREE.Vector3(x, bounds.centerZ, bounds.maxY)
                    ]);
                    const lineMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x3a4f6a, 
                        opacity: 0.3, 
                        transparent: true 
                    });
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    sectorsHelper.add(line);
                }
                
                // YÏ∂ï ÏÑ†
                for (let i = 0; i <= 10; i++) {
                    const y = bounds.minY + (height / 10) * i;
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(bounds.minX, bounds.centerZ, y),
                        new THREE.Vector3(bounds.maxX, bounds.centerZ, y)
                    ]);
                    const lineMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x3a4f6a, 
                        opacity: 0.3, 
                        transparent: true 
                    });
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    sectorsHelper.add(line);
                }
                
                this.scene.add(sectorsHelper);
                
                // Ï¢åÌëúÏ∂ï ÌëúÏãú (ÏõêÏ†ê Î∞è Ï£ºÏöî Íµ¨Ïó≠)
                const axesHelper = new THREE.AxesHelper(Math.max(width, height) * 0.1);
                axesHelper.position.set(bounds.centerX, bounds.centerZ, bounds.centerY);
                this.scene.add(axesHelper);
                
                // Íµ¨Ïó≠ ÎùºÎ≤® Ï∂îÍ∞Ä (Ï£ºÏöî Ìè¨Ïù∏Ìä∏)
                const labelPoints = [
                    { x: bounds.minX, y: bounds.minY, label: 'A1' },
                    { x: bounds.centerX, y: bounds.minY, label: 'B1' },
                    { x: bounds.maxX, y: bounds.minY, label: 'C1' },
                    { x: bounds.minX, y: bounds.centerY, label: 'A2' },
                    { x: bounds.centerX, y: bounds.centerY, label: 'Center' },
                    { x: bounds.maxX, y: bounds.centerY, label: 'C2' },
                    { x: bounds.minX, y: bounds.maxY, label: 'A3' },
                    { x: bounds.centerX, y: bounds.maxY, label: 'B3' },
                    { x: bounds.maxX, y: bounds.maxY, label: 'C3' }
                ];
                
                labelPoints.forEach(point => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 128;
                    canvas.height = 32;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#8a8fa5';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(point.label, canvas.width / 2, canvas.height / 2 + 4);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                        map: texture, 
                        transparent: true 
                    }));
                    sprite.position.set(point.x, bounds.centerZ + 5, point.y);
                    sprite.scale.set(40, 10, 1);
                    this.scene.add(sprite);
                });
                
                // UI ÏóÖÎç∞Ïù¥Ìä∏
                document.getElementById('map-bounds').textContent = 
                    `X: ${bounds.minX.toFixed(0)} ~ ${bounds.maxX.toFixed(0)}\n` +
                    `Y: ${bounds.minY.toFixed(0)} ~ ${bounds.maxY.toFixed(0)}\n` +
                    `Z: ${bounds.minZ.toFixed(0)} ~ ${bounds.maxZ.toFixed(0)}\n` +
                    `Size: ${width.toFixed(0)} √ó ${height.toFixed(0)} √ó ${depth.toFixed(0)}`;
            }

            setupScene() {
                const container = document.getElementById('canvas-container');
                const width = container.clientWidth;
                const height = container.clientHeight;

                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0e15);
                this.scene.fog = new THREE.Fog(0x0a0e15, 1000, 5000);

                this.camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 10000);
                this.camera.position.set(0, 500, 1000);
                this.camera.lookAt(0, 0, 0);

                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('canvas'),
                    antialias: true 
                });
                this.renderer.setSize(width, height);
                this.renderer.shadowMap.enabled = true;

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
                directionalLight.position.set(500, 1000, 500);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);

                window.addEventListener('resize', () => {
                    const width = container.clientWidth;
                    const height = container.clientHeight;
                    this.camera.aspect = width / height;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(width, height);
                });
            }

            setupControls() {
                let isMouseDown = false;
                let isPanning = false; // Ìå®Îãù Î™®Îìú ÌîåÎûòÍ∑∏
                let mouseX = 0, mouseY = 0;
                
                // Ìå®Îãù Ïò§ÌîÑÏÖãÏùÑ Ïù∏Ïä§ÌÑ¥Ïä§ Î≥ÄÏàòÎ°ú Ï¥àÍ∏∞Ìôî
                if (!this.panOffset) {
                    this.panOffset = { x: 0, y: 0, z: 0 };
                }

                const canvas = document.getElementById('canvas');
                
                canvas.addEventListener('mousedown', (e) => {
                    isMouseDown = true;
                    isPanning = e.shiftKey; // Shift ÌÇ§Í∞Ä ÎàåÎ†§ÏûàÏúºÎ©¥ Ìå®Îãù Î™®Îìú
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });

                canvas.addEventListener('mousemove', (e) => {
                    if (isMouseDown) {
                        const deltaX = e.clientX - mouseX;
                        const deltaY = e.clientY - mouseY;
                        
                        if (isPanning || e.shiftKey) {
                            // Ìå®Îãù Î™®Îìú: Ïπ¥Î©îÎùºÎ•º ÌèâÎ©¥ÏúºÎ°ú Ïù¥Îèô
                            const panSpeed = 0.5;
                            const right = new THREE.Vector3();
                            const up = new THREE.Vector3();
                            
                            // Ïπ¥Î©îÎùºÏùò Ïò§Î•∏Ï™Ω Î∞©Ìñ• Í≥ÑÏÇ∞
                            this.camera.getWorldDirection(new THREE.Vector3());
                            right.setFromMatrixColumn(this.camera.matrixWorld, 0);
                            up.setFromMatrixColumn(this.camera.matrixWorld, 1);
                            
                            // Ìå®Îãù Ïò§ÌîÑÏÖã ÎàÑÏ†Å
                            this.panOffset.x -= right.x * deltaX * panSpeed;
                            this.panOffset.y -= right.y * deltaX * panSpeed;
                            this.panOffset.z -= right.z * deltaX * panSpeed;
                            
                            this.panOffset.x += up.x * deltaY * panSpeed;
                            this.panOffset.y += up.y * deltaY * panSpeed;
                            this.panOffset.z += up.z * deltaY * panSpeed;
                        } else {
                            // ÏùºÎ∞ò Î™®Îìú: Ïπ¥Î©îÎùº ÌöåÏ†Ñ
                        this.cameraRotationY += deltaX * 0.01;
                        this.cameraRotationX += deltaY * 0.01;
                        this.cameraRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.cameraRotationX));
                        }
                        mouseX = e.clientX;
                        mouseY = e.clientY;
                    }
                });

                canvas.addEventListener('mouseup', () => {
                    isMouseDown = false;
                    isPanning = false;
                });
                
                // Shift ÌÇ§ ÏÉÅÌÉú Ï∂îÏ†Å (Ìå®ÎãùÏö©)
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Shift' && isMouseDown) {
                        isPanning = true;
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    if (e.key === 'Shift') {
                        isPanning = false;
                    }
                });

                canvas.addEventListener('wheel', (e) => {
                    let zoomSpeed = 5; // Í∏∞Î≥∏ Ï§å ÏÜçÎèÑ
                    
                    // Ctrl ÌÇ§: Îß§Ïö∞ ÏÑ∏Î∞ÄÌïú Ï§å (0.5Î∞∞)
                    if (e.ctrlKey) {
                        zoomSpeed = 0.5;
                    }
                    // Alt ÌÇ§: ÏÑ∏Î∞ÄÌïú Ï§å (1Î∞∞)
                    else if (e.altKey) {
                        zoomSpeed = 1;
                    }
                    // Shift ÌÇ§: Îπ†Î•∏ Ï§å (2Î∞∞)
                    else if (e.shiftKey) {
                        zoomSpeed = 10;
                    }
                    
                    this.cameraDistance += e.deltaY * zoomSpeed;
                    // ÌôïÎåÄ/Ï∂ïÏÜå ÌïúÍ≥Ñ ÏôÑÌôî
                    const minDist = Math.max(10, this.baseCameraDistance * 0.01); // Îçî Í∞ÄÍπåÏù¥ ÌôïÎåÄ ÌóàÏö©
                    const maxDist = Math.max(minDist + 500, this.baseCameraDistance * 25.0);  // Îçî Î©ÄÎ¶¨ Ï∂ïÏÜå ÌóàÏö©
                    this.cameraDistance = Math.max(minDist, Math.min(maxDist, this.cameraDistance));
                    e.preventDefault();
                });
                
                // ÌÇ§Î≥¥ÎìúÎ°ú ÏÑ∏Î∞ÄÌïú Ï§å Ïª®Ìä∏Î°§ Ï∂îÍ∞Ä (+, - ÌÇ§)
                document.addEventListener('keydown', (e) => {
                    // Ctrl + +/- : Îß§Ïö∞ ÏÑ∏Î∞ÄÌïú Ï§å
                    if (e.ctrlKey && (e.key === '+' || e.key === '=')) {
                        this.cameraDistance -= 1;
                        e.preventDefault();
                    } else if (e.ctrlKey && e.key === '-') {
                        this.cameraDistance += 1;
                        e.preventDefault();
                    }
                    // Alt + +/- : ÏÑ∏Î∞ÄÌïú Ï§å
                    else if (e.altKey && (e.key === '+' || e.key === '=')) {
                        this.cameraDistance -= 5;
                        e.preventDefault();
                    } else if (e.altKey && e.key === '-') {
                        this.cameraDistance += 5;
                        e.preventDefault();
                    }
                    // +/- : ÏùºÎ∞ò Ï§å
                    else if (e.key === '+' || e.key === '=') {
                        this.cameraDistance -= 10;
                        e.preventDefault();
                    } else if (e.key === '-') {
                        this.cameraDistance += 10;
                        e.preventDefault();
                    }
                    
                    // ÌïúÍ≥Ñ Ï†ÅÏö©
                    const minDist = Math.max(10, this.baseCameraDistance * 0.01);
                    const maxDist = Math.max(minDist + 500, this.baseCameraDistance * 25.0);
                    this.cameraDistance = Math.max(minDist, Math.min(maxDist, this.cameraDistance));
                });

                this.updateCamera = () => {
                    // ÌÉÄÍ≤üÏù¥ ÏÑ§Ï†ïÎêòÏñ¥ ÏûàÏúºÎ©¥ ÌÉÄÍ≤ü Ï§ëÏã¨, ÏóÜÏúºÎ©¥ Îßµ Ï§ëÏã¨
                    if (this.cameraTarget) {
                        // Ìè¨Ïª§Ïä§ Î™®ÎìúÏóêÏÑúÎèÑ Ìå®Îãù Ïò§ÌîÑÏÖã Ï†ÅÏö©
                        const target = this.cameraTarget;
                        const baseX = target.x + this.cameraDistance * Math.sin(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                        const baseY = target.y + this.cameraDistance * Math.sin(this.cameraRotationX);
                        const baseZ = target.z + this.cameraDistance * Math.cos(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                        // Ìå®Îãù Ïò§ÌîÑÏÖã Ï†ÅÏö©
                        this.camera.position.set(
                            baseX + this.panOffset.x,
                            baseY + this.panOffset.y,
                            baseZ + this.panOffset.z
                        );
                        this.camera.lookAt(
                            target.x + this.panOffset.x,
                            target.y + this.panOffset.y,
                            target.z + this.panOffset.z
                        );
                    } else if (this.mapBounds) {
                        const bounds = this.mapBounds;
                        const baseX = bounds.centerX + this.cameraDistance * Math.sin(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                        const baseY = bounds.centerZ + this.cameraDistance * Math.sin(this.cameraRotationX);
                        const baseZ = bounds.centerY + this.cameraDistance * Math.cos(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                        // Ìå®Îãù Ïò§ÌîÑÏÖã Ï†ÅÏö©
                        this.camera.position.set(
                            baseX + this.panOffset.x,
                            baseY + this.panOffset.y,
                            baseZ + this.panOffset.z
                        );
                        this.camera.lookAt(
                            bounds.centerX + this.panOffset.x,
                            bounds.centerZ + this.panOffset.y,
                            bounds.centerY + this.panOffset.z
                        );
                    } else {
                        const baseX = this.cameraDistance * Math.sin(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                        const baseY = this.cameraDistance * Math.sin(this.cameraRotationX);
                        const baseZ = this.cameraDistance * Math.cos(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                        // Ìå®Îãù Ïò§ÌîÑÏÖã Ï†ÅÏö©
                        this.camera.position.set(
                            baseX + this.panOffset.x,
                            baseY + this.panOffset.y,
                            baseZ + this.panOffset.z
                        );
                        this.camera.lookAt(
                            this.panOffset.x,
                            this.panOffset.y,
                            this.panOffset.z
                        );
                    }
                };

                document.getElementById('play-btn').addEventListener('click', () => {
                    this.togglePlay();
                });

                document.getElementById('timeline').addEventListener('click', (e) => {
                    const rect = e.currentTarget.getBoundingClientRect();
                    const percent = (e.clientX - rect.left) / rect.width;
                    this.seekTo(percent);
                });

                document.querySelectorAll('.speed-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        const newSpeed = parseFloat(btn.dataset.speed);
                        console.log('Ïû¨ÏÉù ÏÜçÎèÑ Î≥ÄÍ≤Ω:', this.playSpeed, '->', newSpeed);
                        this.playSpeed = newSpeed;
                        // Ïû¨ÏÉù ÏÜçÎèÑ Î≥ÄÍ≤Ω Ïãú Ï¶âÏãú Î∞òÏòÅÎêòÎèÑÎ°ù lastUpdateTime Î¶¨ÏÖã
                        this.lastUpdateTime = Date.now();
                    });
                });

                // ESC ÌÇ§Î°ú Ìè¨Ïª§Ïä§ Î™®Îìú Ï¢ÖÎ£å
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.focusMode) {
                        this.exitFocusMode();
                    }
                });

                // Reset view
                document.getElementById('reset-view').addEventListener('click', () => {
                    this.cameraRotationX = 0.3;
                    this.cameraRotationY = 0;
                    this.cameraDistance = this.baseCameraDistance;
                    this.cameraTarget = null; // ÌÉÄÍ≤ü Ìï¥Ï†ú
                    // Ìå®Îãù Ïò§ÌîÑÏÖã Ï¥àÍ∏∞Ìôî
                    if (this.panOffset) {
                        this.panOffset.x = 0;
                        this.panOffset.y = 0;
                        this.panOffset.z = 0;
                    }
                    this.updateCamera();
                });
            }

            setupResizableBottom() {
                const panel = document.getElementById('bottom-panel');
                const handle = document.getElementById('resize-handle');
                const minH = 160; // px
                const maxH = Math.floor(window.innerHeight * 0.8);
                // Load saved height
                const saved = localStorage.getItem('bottomPanelHeight');
                if (saved) panel.style.height = `${parseInt(saved,10)}px`;

                let dragging = false;
                let startY = 0;
                let startH = 0;

                handle.addEventListener('mousedown', (e) => {
                    dragging = true;
                    startY = e.clientY;
                    startH = panel.getBoundingClientRect().height;
                    document.body.style.userSelect = 'none';
                });

                window.addEventListener('mousemove', (e) => {
                    if (!dragging) return;
                    const dy = startY - e.clientY; // drag up increases height
                    let h = startH + dy;
                    h = Math.max(minH, Math.min(maxH, h));
                    panel.style.height = `${h}px`;
                });

                window.addEventListener('mouseup', () => {
                    if (!dragging) return;
                    dragging = false;
                    document.body.style.userSelect = '';
                    const h = panel.getBoundingClientRect().height;
                    localStorage.setItem('bottomPanelHeight', String(Math.round(h)));
                });
            }

            updateUI() {
                if (!this.data) return;

                const m = this.data.metadata;
                document.getElementById('total-players').textContent = m.players.length;
                document.getElementById('total-events').textContent = m.total_events;
                
                // Îßµ Ïù¥Î¶Ñ ÏóÖÎç∞Ïù¥Ìä∏
                const mapName = m.mapName || this.detectedMapName || 'Unknown';
                const mapNameElement = document.getElementById('map-name');
                if (mapNameElement) {
                    mapNameElement.textContent = mapName;
                }
                
                // Îßµ Ï†ïÎ≥¥ ÌÖçÏä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
                const detectedMapNameElement = document.getElementById('detected-map-name');
                if (detectedMapNameElement) {
                    const source = this.detectedMapName ? (this.language === 'ko' ? '(ÏúÑÏπò Í∏∞Î∞ò Ï∂îÎ°†)' : '(Location-based inference)') : 
                                  (this.language === 'ko' ? '(Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò)' : '(Data-based)');
                    detectedMapNameElement.textContent = `${mapName} ${source}`;
                }
                
                const duration = m.time_range.max - m.time_range.min;
                const mins = Math.floor(duration / 60);
                const secs = Math.floor(duration % 60);
                document.getElementById('game-length').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
                document.getElementById('match-length').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
                
                // Match ID ÌëúÏãú
                const matchIdElement = document.getElementById('match-id');
                if (matchIdElement && m.matchInfo && m.matchInfo.match_id !== null) {
                    matchIdElement.textContent = m.matchInfo.match_id;
                } else if (matchIdElement) {
                    matchIdElement.textContent = '-';
                }
                
                // ÏãúÏûë ÏãúÍ∞Ñ (timestampÏóêÏÑú ÎÇ†Ïßú Ï∂îÏ∂ú)
                const startDate = new Date();
                startDate.setTime(m.time_range.min * 1000);
                const startTimeElement = document.getElementById('start-time');
                if (startTimeElement) {
                    startTimeElement.textContent = startDate.toLocaleDateString('ko-KR') + ' ' + startDate.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });
                }
                
                // Match Start Time
                const matchStartTimeElement = document.getElementById('match-start-time');
                if (matchStartTimeElement) {
                    matchStartTimeElement.textContent = startDate.toLocaleDateString('ko-KR') + ' ' + startDate.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });
                }

                const playerList = document.getElementById('player-list');
                playerList.innerHTML = '';
                m.players.forEach(name => {
                    const stats = m.playerStats[name] || { kills: 0, deaths: 0, team: '' };
                    const item = document.createElement('div');
                    item.className = `player-item ${stats.team.toLowerCase()}`;
                    const kd = stats.deaths > 0 ? (stats.kills / stats.deaths).toFixed(2) : stats.kills.toFixed(2);
                    item.innerHTML = `
                        <span>${name}</span>
                        <span class="player-kd">${stats.kills}/${stats.deaths} (${kd})</span>
                    `;
                    item.style.cursor = 'pointer';
                    item.addEventListener('click', () => {
                        // ÌîåÎ†àÏù¥Ïñ¥ ÌÅ¥Î¶≠ Ïãú Ìï¥Îãπ ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Ï∞∏Ïó¨Ìïú ÌÇ¨ Ïù¥Î≤§Ìä∏Î°ú ÌïÑÌÑ∞ÎßÅ
                        const playerKills = this.data.events.filter(e => 
                            (e.attacker.name === name || e.victim.name === name) &&
                            (e.event_type_lower.includes('kill') || e.event_type_lower.includes('died'))
                        );
                        if (playerKills.length > 0) {
                            this.selectEvent(playerKills[0]);
                        }
                    });
                    playerList.appendChild(item);
                });

                this.updateEventLog();
            }

            populateKillPicker() {
                if (!this.data) return;
                const select = document.getElementById('kill-select');
                const goBtn = document.getElementById('go-kill');
                select.innerHTML = '';
                const kills = this.data.events.filter(e => (e.event_type_lower||'').includes('kill') || (e.event_type_lower||'').includes('died'));
                if (kills.length === 0) {
                    const opt = document.createElement('option');
                    opt.textContent = 'No kill events';
                    opt.value = '';
                    select.appendChild(opt);
                    goBtn.disabled = true;
                    return;
                }
                goBtn.disabled = false;
                kills.forEach((e, idx) => {
                    const opt = document.createElement('option');
                    const t = this.formatTime(e.game_time);
                    const label = `${t} ${e.attacker.name || 'Unknown'} ‚Üí ${e.victim.name || 'Unknown'}`;
                    opt.value = String(idx);
                    opt.textContent = label;
                    select.appendChild(opt);
                });

                goBtn.onclick = () => {
                    const i = parseInt(select.value);
                    if (isNaN(i)) return;
                    const e = kills[i];
                    this.selectEvent(e);
                };
            }

            populatePlayerPicker() {
                if (!this.data || !this.playerIndex) return;
                const select = document.getElementById('player-select');
                select.innerHTML = '<option value="">Players</option>';
                Array.from(this.playerIndex.keys()).sort().forEach(name => {
                    const opt = document.createElement('option');
                    opt.value = name;
                    opt.textContent = name;
                    select.appendChild(opt);
                });

                select.onchange = () => {
                    this.selectedPlayer = select.value || null;
                };

                document.getElementById('follow-toggle').onclick = () => {
                    if (!this.selectedPlayer) return;
                    this.followPlayer = !this.followPlayer;
                    document.getElementById('follow-toggle').textContent = this.followPlayer ? 'Following' : 'Follow';
                    if (!this.followPlayer) {
                        this.cameraTarget = null;
                    }
                };

                document.getElementById('prev-player-tick').onclick = () => {
                    this.seekToPlayerTick(-1);
                };
                document.getElementById('next-player-tick').onclick = () => {
                    this.seekToPlayerTick(1);
                };
            }

            seekToPlayerTick(direction) {
                if (!this.selectedPlayer || !this.playerIndex.has(this.selectedPlayer)) return;
                const arr = this.playerIndex.get(this.selectedPlayer);
                if (!arr || arr.length === 0) return;
                // ÌòÑÏû¨ Ìã± Í∏∞Ï§Ä Ïù¥Ï†Ñ/Îã§Ïùå Ìï≠Î™© Ï∞æÍ∏∞
                let idx = arr.findIndex(e => e.tick >= this.data.positions[this.currentTick].tick);
                if (idx === -1) idx = arr.length - 1;
                idx = idx + direction;
                idx = Math.max(0, Math.min(arr.length - 1, idx));
                const target = arr[idx];
                const tickIdx = this.findTickByTime(target.time);
                if (tickIdx !== -1) {
                    this.currentTick = tickIdx;
                    if (this.followPlayer) {
                        this.cameraTarget = { x: target.position[0], y: target.position[2], z: target.position[1] };
                    }
                    this.renderTick(this.currentTick);
                    this.updateTimeDisplay();
                }
            }

            updateEventLog() {
                if (!this.data) return;
                
                const eventLog = document.getElementById('event-log');
                eventLog.innerHTML = '';
                
                let eventsToShow = this.data.events;
                
                // Ìè¨Ïª§Ïä§ Î™®ÎìúÏù∏ Í≤ΩÏö∞ ÏãúÍ∞Ñ Î≤îÏúÑ ÌïÑÌÑ∞ÎßÅ
                if (this.focusMode && this.focusTickRange) {
                    const startT = this.data.positions[this.focusTickRange.startIdx].game_time;
                    const endT = this.data.positions[this.focusTickRange.endIdx].game_time;
                    eventsToShow = this.data.events.filter(e => e.game_time >= startT && e.game_time <= endT);
                } else {
                    // ÌòÑÏû¨ ÏãúÍ∞Ñ Í∏∞Ï§Ä ¬±5Ï¥à Ïù¥ÎÇ¥ Ïù¥Î≤§Ìä∏ ÌëúÏãú
                    const currentTickData = this.data.positions[this.currentTick];
                    const currentTime = currentTickData ? currentTickData.game_time : 0;
                    eventsToShow = this.data.events.filter(e => 
                        Math.abs(e.game_time - currentTime) < 5
                    );
                }
                
                eventsToShow.slice(0, 100).forEach((event, idx) => {
                    const item = document.createElement('div');
                    let className = 'event-item';
                    const isSelected = this.selectedEvent && this.selectedEvent.tick === event.tick;
                    
                    if (event.event_type_lower.includes('kill') || event.event_type_lower.includes('died')) {
                        className += ' kill';
                    } else if (event.event_type_lower.includes('attack')) {
                        className += ' attack';
                    } else if (event.event_type_lower.includes('hit')) {
                        className += ' hit';
                    }
                    
                    if (isSelected) {
                        className += ' selected';
                    }
                    
                    item.className = className;
                    
                    // HTMLÎ°ú ÏÉâÏÉÅ Íµ¨Î∂ÑÌïòÏó¨ ÌëúÏãú
                    const time = this.formatTime(event.game_time);
                    let html = `<span class="event-time">${time}</span> `;
                    
                    if (event.event_type_lower.includes('kill') || event.event_type_lower.includes('died')) {
                        if (event.attacker.name && event.victim.name) {
                            html += `<span class="event-action">killed</span> `;
                            html += `<span class="event-victim">${event.victim.name}</span>`;
                            if (event.weapon) {
                                html += ` <span class="event-weapon">with ${event.weapon}</span>`;
                            }
                            html = `<span class="event-player">${event.attacker.name}</span> ` + html;
                        } else {
                            html += `<span class="event-action">${event.event_type}</span>`;
                        }
                    } else if (event.event_type_lower.includes('attack')) {
                        html += `<span class="event-player">${event.attacker.name || 'Unknown'}</span> `;
                        html += `<span class="event-action">initiated an Attack</span>`;
                        if (event.weapon) {
                            html += ` <span class="event-action">with weapon</span> <span class="event-weapon">${event.weapon}</span>`;
                        }
                    } else {
                        html += `<span class="event-action">${event.event_type}</span>`;
                    }
                    
                    item.innerHTML = html;
                    
                    // ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ Ï∂îÍ∞Ä
                    item.addEventListener('click', () => {
                        this.selectEvent(event);
                    });
                    
                    eventLog.appendChild(item);
                });
                
                // Ïä§ÌÅ¨Î°§ÏùÑ Îß® ÏúÑÎ°ú
                eventLog.scrollTop = 0;
            }

            selectEvent(event) {
                // Í∏∞Ï°¥ ÏÑ†ÌÉù Ìï¥Ï†ú
                if (this.selectedEvent) {
                    document.querySelectorAll('.event-item.selected').forEach(item => {
                        item.classList.remove('selected');
                    });
                }
                
                this.selectedEvent = event;
                
                // Ìè¨Ïª§Ïä§ Î™®Îìú ÌôúÏÑ±Ìôî (Ïù¥Î≤§Ìä∏ Ï†ÑÌõÑ 30Ìã±)
                this.focusMode = true;
                const centerIdx = this.findTickByTime(event.game_time);
                const startIdx = Math.max(0, centerIdx - 30);
                const endIdx = Math.min(this.data.positions.length - 1, centerIdx + 30);
                this.focusTickRange = { startIdx, endIdx, centerIdx };
                this.focusTimeRange = {
                    start: this.data.positions[startIdx].game_time,
                    end: this.data.positions[endIdx].game_time
                };
                
                // Ìï¥Îãπ ÏãúÍ∞ÑÏúºÎ°ú Ïù¥Îèô
                const targetTick = this.findTickByTime(event.game_time);
                if (targetTick !== -1) {
                    this.currentTick = targetTick;
                    this.renderTick(this.currentTick);
                    this.updateTimeDisplay();
                }
                
                // Í≥µÍ≤©ÏûêÎ•º ÏãúÎÆ¨Î†àÏù¥ÏÖò Ï§ëÏïôÏóê Î∞∞Ïπò
                if (event.attacker.position[0] !== null && this.mapBounds) {
                    const attackerPos = {
                        x: event.attacker.position[0],
                        y: event.attacker.position[2],
                        z: event.attacker.position[1]
                    };
                    
                    // Ïπ¥Î©îÎùºÎ•º Í≥µÍ≤©Ïûê ÏúÑÏπòÎ•º Ï§ëÏã¨ÏúºÎ°ú Ï°∞Ï†ï
                    const bounds = this.mapBounds;
                    const maxDim = Math.max(bounds.width, bounds.height, bounds.depth);
                    this.cameraDistance = maxDim * 0.8;
                    
                    // Í≥µÍ≤©Ïûê ÏúÑÏπòÎ•º Ï§ëÏã¨ÏúºÎ°ú Ïπ¥Î©îÎùº Î∞∞Ïπò
                    this.cameraRotationX = 0.4;
                    this.cameraRotationY = Math.PI / 4; // 45ÎèÑ Í∞ÅÎèÑ
                    
                    // Ïπ¥Î©îÎùº ÌÉÄÍ≤üÏùÑ Í≥µÍ≤©Ïûê ÏúÑÏπòÎ°ú ÏÑ§Ï†ï
                    this.cameraTarget = attackerPos;
                    
                    // Ïπ¥Î©îÎùº ÏóÖÎç∞Ïù¥Ìä∏
                    this.updateCameraToTarget();
                }
                
                // Ïù¥Î≤§Ìä∏ Î°úÍ∑∏ ÏóÖÎç∞Ïù¥Ìä∏
                this.updateEventLog();
                
                // Ìè¨Ïª§Ïä§ Î™®Îìú ÌëúÏãú
                this.showFocusModeIndicator();
                // Aim Trace ÌÉ≠Ïù¥ Ïó¥Î†§ÏûàÎã§Î©¥ Í∞±Ïã†
                const activeTabEl = document.querySelector('.tab-btn.active');
                const activeTab = activeTabEl ? activeTabEl.getAttribute('data-tab') : null;
                if (activeTab === 'aim') this.renderAimTrace();
            }
            
            updateCameraToTarget() {
                if (!this.cameraTarget || !this.mapBounds) return;
                
                const target = this.cameraTarget;
                const x = target.x + this.cameraDistance * Math.sin(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                const y = target.y + this.cameraDistance * Math.sin(this.cameraRotationX);
                const z = target.z + this.cameraDistance * Math.cos(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                
                // Ìå®Îãù Ïò§ÌîÑÏÖã Ï†ÅÏö©
                this.camera.position.set(
                    x + (this.panOffset ? this.panOffset.x : 0),
                    y + (this.panOffset ? this.panOffset.y : 0),
                    z + (this.panOffset ? this.panOffset.z : 0)
                );
                this.camera.lookAt(
                    target.x + (this.panOffset ? this.panOffset.x : 0),
                    target.y + (this.panOffset ? this.panOffset.y : 0),
                    target.z + (this.panOffset ? this.panOffset.z : 0)
                );
            }

            findTickByTime(targetTime) {
                if (!this.data) return -1;
                
                let closestTick = 0;
                let minDiff = Infinity;
                
                this.data.positions.forEach((pos, idx) => {
                    const diff = Math.abs(pos.game_time - targetTime);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestTick = idx;
                    }
                });
                
                return closestTick;
            }

            showFocusModeIndicator() {
                // Ìè¨Ïª§Ïä§ Î™®Îìú Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ ÌëúÏãú
                const focusControls = document.getElementById('focus-controls');
                const timeDisplay = document.getElementById('time-display');
                
                if (this.focusMode && this.focusTimeRange) {
                    focusControls.classList.add('show');
                    const range = this.focusTimeRange.end - this.focusTimeRange.start;
                    const info = document.getElementById('focus-info');
                    info.textContent = `Focus: ${this.formatTime(this.focusTimeRange.start)} - ${this.formatTime(this.focusTimeRange.end)} (${this.formatTime(range)})`;
                    timeDisplay.style.color = '#4a90e2';
                    timeDisplay.style.fontWeight = 'bold';
                } else {
                    focusControls.classList.remove('show');
                    timeDisplay.style.color = '';
                    timeDisplay.style.fontWeight = '';
                }
            }

            exitFocusMode() {
                this.focusMode = false;
                this.focusTimeRange = null;
                this.selectedEvent = null;
                this.cameraTarget = null; // ÌÉÄÍ≤ü Ìï¥Ï†ú
                this.updateCamera();
                this.showFocusModeIndicator();
                this.updateEventLog();
            }

            renderTick(tickIndex) {
                if (!this.data || !this.data.positions) return;

                const tickData = this.data.positions[tickIndex];
                if (!tickData) return;

                // Í∏∞Ï°¥ Ïò§Î∏åÏ†ùÌä∏ Ï†úÍ±∞
                this.playerObjects.forEach(obj => this.scene.remove(obj));
                this.playerLabels.forEach(obj => this.scene.remove(obj));
                this.playerObjects.clear();
                this.playerLabels.clear();

                // ÌîåÎ†àÏù¥Ïñ¥ Î†åÎçîÎßÅ
                tickData.players.forEach(player => {
                    // ÏÉà Îç∞Ïù¥ÌÑ∞ÏóêÎäî team Ï†ïÎ≥¥Í∞Ä ÏóÜÏúºÎØÄÎ°ú player_idÎ•º Í∏∞Î∞òÏúºÎ°ú ÏÉâÏÉÅ Íµ¨Î∂Ñ
                    // player_idÍ∞Ä ÏùåÏàòÎ©¥ Ìïú ÌåÄ, ÏñëÏàòÎ©¥ Îã§Î•∏ ÌåÄÏúºÎ°ú Í∞ÄÏ†ï
                    const playerIdNum = parseInt(player.name) || 0;
                    const isCT = player.team === 'CT' || (player.team === '' && playerIdNum < 0);
                    const color = isCT ? 0x5b9bd5 : 0xff6b6b;
                    
                    // CTÎäî ÏõêÌòï, TÎäî ÏÇºÍ∞ÅÌòï
                    let geometry;
                    if (isCT) {
                        geometry = new THREE.SphereGeometry(12, 16, 16);
                    } else {
                        geometry = new THREE.ConeGeometry(12, 24, 3);
                        geometry.rotateX(-Math.PI / 2);
                    }
                    
                    const material = new THREE.MeshPhongMaterial({ 
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.4
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(player.position[0], player.position[2], player.position[1]);
                    this.scene.add(mesh);
                    this.playerObjects.set(player.name, mesh);

                    // ÌîåÎ†àÏù¥Ïñ¥ ID ÎùºÎ≤® (ÌÅ¨Í≤å)
                    // ÌòÑÏû¨ Ìã±Ïóê ÌÇ¨ Ïù¥Î≤§Ìä∏Í∞Ä ÏûàÍ≥† Ïù¥ ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Í≥µÍ≤©ÏûêÏù∏ÏßÄ ÌôïÏù∏
                    let isAttacker = false;
                    let attackerWeapon = null;
                    if (this.data && this.data.events) {
                        const currentTime = tickData.game_time;
                        const activeEvent = this.data.events.find(e => 
                            Math.abs(e.game_time - currentTime) < 0.05 && 
                            e.attacker && 
                            e.attacker.name === player.name
                        );
                        if (activeEvent) {
                            isAttacker = true;
                            attackerWeapon = activeEvent.weapon || null;
                        }
                    }
                    
                    // ÎùºÎ≤® ÎÜíÏù¥ Ï°∞Ï†ï (Í≥µÍ≤©ÏûêÎäî Ìïú Ï§ÑÏù¥ÎØÄÎ°ú ÎÇÆÍ≤å)
                    const labelHeight = isAttacker ? 60 : 96;
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 512;
                    canvas.height = labelHeight;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Î∞∞Í≤Ω ÌÖåÎëêÎ¶¨
                    ctx.strokeStyle = isCT ? '#5b9bd5' : '#ff6b6b';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
                    
                    let yPos = 40;
                    
                    // Í≥µÍ≤©ÏûêÏù∏ Í≤ΩÏö∞ Ìïú Ï§ÑÎ°ú Í∞ÑÎã®ÌïòÍ≤å ÌëúÏãú
                    if (isAttacker) {
                        // Ï∫êÎ¶≠ÌÑ∞Î™Ö(ÏÇ¨Ïö©Î¨¥Í∏∞Ï†ïÎ≥¥, Í≥µÍ≤©Ïûê Íµ¨Î∂Ñ) ÌòïÏãùÏúºÎ°ú Ìïú Ï§Ñ ÌëúÏãú
                        let labelText = player.name;
                        if (attackerWeapon) {
                            labelText += ` (${attackerWeapon}, attacker)`;
                        } else {
                            labelText += ' (attacker)';
                        }
                        
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 28px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(labelText, canvas.width / 2, yPos);
                    } else {
                        // ÏùºÎ∞ò ÌîåÎ†àÏù¥Ïñ¥Îäî Í∏∞Ï°¥ÎåÄÎ°ú
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 36px Arial';
                    ctx.textAlign = 'center';
                        ctx.fillText(player.name, canvas.width / 2, yPos);
                    }
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                        map: texture,
                        transparent: true,
                        depthTest: false
                    }));
                    // Í≥µÍ≤©ÏûêÏù∏ Í≤ΩÏö∞ ÎùºÎ≤®ÏùÑ Îçî ÏúÑÎ°ú Ïò¨Î†§ÏÑú Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Í≤πÏπòÏßÄ ÏïäÎèÑÎ°ù
                    const labelYOffset = isAttacker ? 50 : 35;
                    sprite.position.set(player.position[0], player.position[2] + labelYOffset, player.position[1]);
                    // ÎùºÎ≤® ÎÜíÏù¥Ïóê ÎßûÏ∂∞ Ïä§ÏºÄÏùº Ï°∞Ï†ï (Í≥µÍ≤©ÏûêÎäî Ìïú Ï§ÑÏù¥ÎØÄÎ°ú ÎÇÆÍ≤å)
                    const spriteHeight = isAttacker ? 30 : 30;
                    // Í≥µÍ≤©Ïûê ÎùºÎ≤®ÏùÄ ÌÖçÏä§Ìä∏Í∞Ä Í∏∏Ïñ¥Ïßà Ïàò ÏûàÏúºÎØÄÎ°ú ÎÑàÎπÑÎ•º ÎÑìÍ≤å
                    const spriteWidth = isAttacker ? 200 : 150;
                    sprite.scale.set(spriteWidth, spriteHeight, 1);
                    this.scene.add(sprite);
                    this.playerLabels.set(player.name, sprite);
                    
                    // Ìä∏Î†àÏùº ÏóÖÎç∞Ïù¥Ìä∏
                    this.updateTrail(player.name, player.position, color);
                });

                this.renderEvents(tickData.game_time);
                this.updateEventLog();
            }

            updateTrail(playerName, position, color) {
                if (!this.playerTrails.has(playerName)) {
                    const trailGeometry = new THREE.BufferGeometry();
                    const trailMaterial = new THREE.LineBasicMaterial({ 
                        color: color,
                        opacity: 0.4,
                        transparent: true,
                        linewidth: 2
                    });
                    const trail = new THREE.Line(trailGeometry, trailMaterial);
                    this.scene.add(trail);
                    this.playerTrails.set(playerName, {
                        line: trail,
                        points: []
                    });
                }

                const trail = this.playerTrails.get(playerName);
                trail.points.push(new THREE.Vector3(position[0], position[2], position[1]));
                
                if (trail.points.length > 100) {
                    trail.points.shift();
                }

                trail.line.geometry.setFromPoints(trail.points);
            }

            renderEvents(gameTime) {
                this.eventMarkers.forEach(m => this.scene.remove(m));
                this.eventMarkers = [];

                if (!this.data || !this.data.events) return;

                this.data.events.forEach(event => {
                    const timeDiff = Math.abs(event.game_time - gameTime);
                    // Ï†ïÌôïÌûà Ìï¥Îãπ Ìã±ÏóêÎßå ÌëúÏãú (0.05Ï¥à Ïù¥ÎÇ¥, ÏïΩ 3Ìã±)
                    // Ìè¨Ïª§Ïä§ Î™®ÎìúÏùº ÎïåÎäî ÏÑ†ÌÉùÎêú Ïù¥Î≤§Ìä∏Îßå ÌëúÏãú
                    if (this.focusMode && this.selectedEvent) {
                        // Ìè¨Ïª§Ïä§ Î™®Îìú: ÏÑ†ÌÉùÎêú Ïù¥Î≤§Ìä∏ÏôÄ ÏùºÏπòÌïòÎäî Í≤ΩÏö∞Îßå ÌëúÏãú
                        if (event.tick !== this.selectedEvent.tick || 
                            !event.attacker || !this.selectedEvent.attacker ||
                            event.attacker.name !== this.selectedEvent.attacker.name ||
                            !event.victim || !this.selectedEvent.victim ||
                            event.victim.name !== this.selectedEvent.victim.name) {
                            return; // ÏÑ†ÌÉùÎêú Ïù¥Î≤§Ìä∏Í∞Ä ÏïÑÎãàÎ©¥ Ïä§ÌÇµ
                        }
                    }
                    
                    if (timeDiff < 0.05 && event.attacker.position[0] !== null) {
                        // Í≥µÍ≤©Ïûê ÌîåÎ†àÏù¥Ïñ¥Î•º Ïõê ÌÖåÎëêÎ¶¨Î°ú Í∞êÏã∏Í∏∞
                        // ÌîåÎ†àÏù¥Ïñ¥ Î™®Îç∏ ÌÅ¨Í∏∞(Î∞òÏßÄÎ¶Ñ ÏïΩ 12-15)Î•º Í≥†Î†§ÌïòÏó¨ Ïõê ÌÖåÎëêÎ¶¨ ÏÉùÏÑ±
                        const innerRadius = 18;
                        const outerRadius = 20;
                        const ringGeometry = new THREE.RingGeometry(innerRadius, outerRadius, 32);
                        const material = new THREE.MeshPhongMaterial({ 
                            color: 0xff0000,
                            emissive: 0xff0000,
                            emissiveIntensity: 0.6,
                            side: THREE.DoubleSide
                        });
                        const marker = new THREE.Mesh(ringGeometry, material);
                        // Í≥µÍ≤©Ïûê ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπòÏóê Î∞∞Ïπò (ÏßÄÎ©¥ ÎÜíÏù¥)
                        marker.position.set(
                            event.attacker.position[0],
                            event.attacker.position[2], // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Í∞ôÏùÄ ÎÜíÏù¥
                            event.attacker.position[1]
                        );
                        // ÏàòÌèâÎ©¥Ïóê Î∞∞Ïπò (ÏßÄÎ©¥Ïóê ÎÜìÏù∏ Ïõê ÌòïÌÉú)
                        marker.rotation.x = -Math.PI / 2;
                        this.scene.add(marker);
                        this.eventMarkers.push(marker);

                        if (event.victim.position[0] !== null) {
                            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(
                                    event.attacker.position[0],
                                    event.attacker.position[2],
                                    event.attacker.position[1]
                                ),
                                new THREE.Vector3(
                                    event.victim.position[0],
                                    event.victim.position[2],
                                    event.victim.position[1]
                                )
                            ]);
                            const lineMaterial = new THREE.LineBasicMaterial({ 
                                color: 0xff6b6b,
                                opacity: 0.8,
                                transparent: true,
                                linewidth: 2
                            });
                            const line = new THREE.Line(lineGeometry, lineMaterial);
                            this.scene.add(line);
                            this.eventMarkers.push(line);

                            // Victim 'KILLED' label with HEADSHOT and fadeout
                            // Ï†ïÌôïÌûà Ìï¥Îãπ Ìã±ÏóêÎßå ÌëúÏãúÌïòÍ≥† 2Ï¥àÍ∞Ñ ÌéòÏù¥ÎìúÏïÑÏõÉ
                            if (timeDiff < 2.0) {
                                const fadeStart = 1.5; // 1.5Ï¥à ÌõÑÎ∂ÄÌÑ∞ ÌéòÏù¥Îìú ÏãúÏûë
                                const fadeEnd = 2.0; // 2Ï¥àÏóê ÏôÑÏ†ÑÌûà ÏÇ¨ÎùºÏßê
                                let opacity = 1.0;
                                
                                if (timeDiff > fadeStart) {
                                    opacity = 1.0 - ((timeDiff - fadeStart) / (fadeEnd - fadeStart));
                                    opacity = Math.max(0, opacity);
                                }
                                
                                if (opacity > 0) {
                                    const canvas = document.createElement('canvas');
                                    const ctx = canvas.getContext('2d');
                                    // Î¨¥Í∏∞ Ï†ïÎ≥¥Î•º Ìè¨Ìï®Ìïú ÌÅ¨Í∏∞Î°ú ÏÑ§Ï†ï
                                    // Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ Ï°∞Ï†ï (Î¨¥Í∏∞ Ï†ïÎ≥¥ Ï†úÍ±∞Î°ú ÌÅ¨Í∏∞ Ï∂ïÏÜå)
                                    canvas.width = 280;
                                    canvas.height = 80;
                                    
                                    // Î∞∞Í≤Ω (Ìà¨Î™ÖÎèÑ Ï†ÅÏö©)
                                    ctx.fillStyle = `rgba(0, 0, 0, ${0.85 * opacity})`;
                                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                                    
                                    // ÌÖåÎëêÎ¶¨
                                    ctx.strokeStyle = `rgba(255, 107, 107, ${opacity})`;
                                    ctx.lineWidth = 3;
                                    ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
                                    
                                    let yPos = 28;
                                    
                                    // DEAD ÌÖçÏä§Ìä∏ (victim Í¥ÄÏ†ê)
                                    ctx.fillStyle = `rgba(255, 107, 107, ${opacity})`;
                                    ctx.font = 'bold 26px Arial';
                                    ctx.textAlign = 'center';
                                    ctx.fillText('DEAD', canvas.width / 2, yPos);
                                    
                                    // HEADSHOT ÌëúÏãú (Ìó§ÎìúÏÉ∑Ïù∏ Í≤ΩÏö∞)
                                    if (event.headshot) {
                                        yPos += 22;
                                        ctx.fillStyle = `rgba(255, 215, 0, ${opacity})`;
                                        ctx.font = 'bold 16px Arial';
                                        ctx.fillText('HEADSHOT', canvas.width / 2, yPos);
                                    }
                                    
                                    // victim ÌÖçÏä§Ìä∏
                                    yPos += 20;
                                    ctx.fillStyle = `rgba(255, 107, 107, ${opacity})`;
                                    ctx.font = '12px Arial';
                                    ctx.fillText('victim', canvas.width / 2, yPos);
                                    
                                    const tex = new THREE.CanvasTexture(canvas);
                                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                                        map: tex, 
                                        transparent: true,
                                        opacity: opacity,
                                        depthTest: false // Ìï≠ÏÉÅ ÏïûÏóê ÌëúÏãú
                                    }));
                                    sprite.position.set(
                                        event.victim.position[0],
                                        event.victim.position[2] + 70, // Îçî ÏúÑÎ°ú Ïò¨Î¶º
                                        event.victim.position[1]
                                    );
                                    sprite.scale.set(140, 40, 1); // ÌÅ¨Í∏∞ Ï°∞Ï†ï (Î¨¥Í∏∞ Ï†ïÎ≥¥ Ï†úÍ±∞Î°ú ÏõêÎûò ÌÅ¨Í∏∞Î°ú Î≥µÏõê)
                                    this.scene.add(sprite);
                                    this.eventMarkers.push(sprite);
                                }
                            }
                        }
                    }
                });
            }

            togglePlay() {
                this.isPlaying = !this.isPlaying;
                document.getElementById('play-btn').textContent = this.isPlaying ? '‚è∏' : '‚ñ∂';
            }

            seekTo(percent) {
                if (!this.data) return;
                const maxTick = this.data.positions.length - 1;
                this.currentTick = Math.floor(percent * maxTick);
                this.renderTick(this.currentTick);
                this.updateTimeDisplay();
            }

            updateTimeDisplay() {
                if (!this.data) return;
                
                const tickData = this.data.positions[this.currentTick];
                if (tickData) {
                    const m = this.data.metadata;
                    const currentTime = tickData.game_time - m.time_range.min;
                    const totalTime = m.time_range.max - m.time_range.min;
                    
                    document.getElementById('time-display').textContent = 
                        `${this.formatTime(currentTime)} / ${this.formatTime(totalTime)}`;
                    
                    const progress = (this.currentTick / (this.data.positions.length - 1)) * 100;
                    document.getElementById('timeline-progress').style.width = `${progress}%`;
                }
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                const ms = Math.floor((seconds % 1) * 1000);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                if (this.updateCamera) {
                    this.updateCamera();
                }

                if (this.isPlaying && this.data) {
                    const now = Date.now();
                    if (!this.lastUpdateTime) {
                        this.lastUpdateTime = now;
                    }
                    
                    // Ìã± Í∞Ñ ÏãúÍ∞Ñ Í≥ÑÏÇ∞ (Ïã§Ï†ú Í≤åÏûÑ Ìã± ÏÜçÎèÑ Í∏∞Î∞ò)
                    const tickData = this.data.positions[this.currentTick];
                    const nextTickData = this.data.positions[this.currentTick + 1];
                    
                    let shouldAdvance = false;
                    let delta = now - this.lastUpdateTime;
                    
                    if (tickData && nextTickData) {
                        const tickInterval = (nextTickData.game_time - tickData.game_time) * 1000; // ms
                        if (tickInterval > 0 && !Number.isNaN(tickInterval)) {
                            // playSpeed Ï†ÅÏö©: 1xÎ©¥ ÏõêÎûò ÏÜçÎèÑ, 0.5xÎ©¥ 2Î∞∞ ÎäêÎ¶¨Í≤å, 2xÎ©¥ 2Î∞∞ Îπ†Î•¥Í≤å
                            const targetInterval = tickInterval / this.playSpeed;
                            
                            // playSpeedÏóê Îî∞Îùº Ìã± ÏßÑÌñâ ÏÜçÎèÑ Ï°∞Ï†à
                            shouldAdvance = delta >= targetInterval;
                            
                            // Îπ†Î•∏ ÏÜçÎèÑÏùº Îïå Ïó¨Îü¨ Ìã±ÏùÑ Ìïú Î≤àÏóê Í±¥ÎÑàÎõ∞Í∏∞
                            if (shouldAdvance && this.playSpeed > 1) {
                                const ticksToSkip = Math.floor(delta / targetInterval);
                                if (ticksToSkip > 1) {
                                    // Ïó¨Îü¨ Ìã± Í±¥ÎÑàÎõ∞Í∏∞ (ÏµúÎåÄ 10Ìã±)
                                    const skipCount = Math.min(ticksToSkip - 1, 10);
                                    this.currentTick += skipCount;
                                    shouldAdvance = false; // Ïù¥ÎØ∏ Ï¶ùÍ∞ÄÌñàÏúºÎØÄÎ°ú Ï∂îÍ∞Ä Ï¶ùÍ∞Ä Î∞©ÏßÄ
                                }
                            }
                            
                            // ÎîîÎ≤ÑÍπÖ (Í∞ÄÎÅîÎßå Ï∂úÎ†•)
                            if (this.currentTick % 100 === 0) {
                                console.log('Ïû¨ÏÉù ÏÜçÎèÑ:', this.playSpeed + 'x', 'Ìã± Í∞ÑÍ≤©:', tickInterval.toFixed(2) + 'ms', 'Î™©Ìëú Í∞ÑÍ≤©:', targetInterval.toFixed(2) + 'ms', 'Ïã§Ï†ú delta:', delta.toFixed(2) + 'ms');
                            }
                        } else {
                            // Ìã± Í∞ÑÍ≤©Ïù¥ ÏóÜÍ±∞ÎÇò ÏûòÎ™ªÎêú Í≤ΩÏö∞ Í∏∞Î≥∏ Í∞ÑÍ≤© ÏÇ¨Ïö©
                            const baseInterval = 16.67 / this.playSpeed; // Í∏∞Î≥∏ 60fps Í∏∞Ï§Ä (16.67ms)
                            shouldAdvance = delta >= baseInterval;
                        }
                    } else {
                        // Îã§Ïùå Ìã± Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ Í∏∞Î≥∏ Í∞ÑÍ≤© ÏÇ¨Ïö©
                        const baseInterval = 16.67 / this.playSpeed; // Í∏∞Î≥∏ 60fps Í∏∞Ï§Ä (16.67ms)
                        shouldAdvance = delta >= baseInterval;
                    }
                    
                    if (shouldAdvance) {
                        this.currentTick += 1;
                        
                        // Ìè¨Ïª§Ïä§ Î™®ÎìúÏù∏ Í≤ΩÏö∞ Î≤îÏúÑ Ï≤¥ÌÅ¨ (Ìã± Í∏∞Î∞ò)
                        if (this.focusMode && this.focusTickRange) {
                            if (this.currentTick > this.focusTickRange.endIdx) {
                                this.currentTick = this.focusTickRange.startIdx;
                                this.isPlaying = false;
                                document.getElementById('play-btn').textContent = '‚ñ∂';
                            }
                        }
                        
                        if (this.currentTick >= this.data.positions.length) {
                            this.currentTick = this.data.positions.length - 1;
                            this.isPlaying = false;
                            document.getElementById('play-btn').textContent = '‚ñ∂';
                        } else {
                            // Follow selected player if enabled
                            if (this.followPlayer && this.selectedPlayer && this.playerIndex.has(this.selectedPlayer)) {
                                const arr = this.playerIndex.get(this.selectedPlayer);
                                const tick = this.data.positions[this.currentTick].tick;
                                const entry = arr.find(e => e.tick === tick);
                                if (entry) {
                                    this.cameraTarget = { x: entry.position[0], y: entry.position[2], z: entry.position[1] };
                                }
                            }
                            this.renderTick(this.currentTick);
                            this.updateTimeDisplay();
                            // Aim trace Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ (ÌÉ≠Ïù¥ Ïó¥Î†§ÏûàÏùÑ Îïå)
                            const activeTabEl3 = document.querySelector('.tab-btn.active');
                            const activeTab3 = activeTabEl3 ? activeTabEl3.getAttribute('data-tab') : null;
                            if (activeTab3 === 'aim') this.renderAimTrace();
                        }
                        this.lastUpdateTime = now;
                    }
                }

                this.renderer.render(this.scene, this.camera);
            }
        }

        // Ï¶âÏãú Ïã§ÌñâÌïòÏó¨ Ï¥àÍ∏∞Ìôî Î≥¥Ïû•
        (function() {
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
            new CombatSimulation();
        });
            } else {
                // DOMÏù¥ Ïù¥ÎØ∏ Î°úÎìúÎêú Í≤ΩÏö∞ Ï¶âÏãú Ïã§Ìñâ
                new CombatSimulation();
            }
        })();
    </script>
</body>
</html>

