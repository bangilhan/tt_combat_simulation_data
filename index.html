<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS:GO Combat Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0f1419;
            color: #fff;
            overflow: hidden;
        }

        #top-nav {
            height: 50px;
            background: #1a1f2e;
            border-bottom: 1px solid #2a2f3e;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 30px;
        }

        #brand-logo {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-right: 30px;
            padding-right: 30px;
            border-right: 1px solid #2a2f3e;
        }

        #brand-logo img {
            height: 32px;
            width: auto;
            object-fit: contain;
        }

        #brand-text {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        #brand-name {
            font-size: 13px;
            font-weight: 600;
            color: #fff;
            letter-spacing: 0.5px;
        }

        #brand-tagline {
            font-size: 10px;
            color: #8a8fa5;
            font-style: italic;
        }

        .nav-item {
            padding: 8px 16px;
            cursor: pointer;
            color: #8a8fa5;
            font-size: 14px;
            transition: color 0.2s;
        }

        .nav-item:hover {
            color: #fff;
        }

        .nav-item.active {
            color: #4a90e2;
            border-bottom: 2px solid #4a90e2;
        }

        #container {
            display: flex;
            height: calc(100vh - 50px);
        }

        #sidebar {
            width: 350px;
            background: #1a1f2e;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #2a2f3e;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            background: #0a0e15;
        }

        #dashboard-view {
            flex: 1;
            padding: 40px;
            overflow-y: auto;
            overflow-x: hidden;
            background: #0f1419;
            display: none;
            height: calc(100vh - 50px);
        }

        #dashboard-view.active {
            display: block;
        }

        #dashboard-content {
            max-width: 900px;
            margin: 0 auto;
            color: #fff;
            padding-right: 20px;
        }

        #dashboard-content h1 {
            font-size: 32px;
            margin-bottom: 20px;
            color: #fff;
        }

        #dashboard-content h2 {
            font-size: 24px;
            margin-top: 30px;
            margin-bottom: 15px;
            color: #4a90e2;
            border-bottom: 2px solid #2a2f3e;
            padding-bottom: 10px;
        }

        #dashboard-content h3 {
            font-size: 18px;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #8a8fa5;
        }

        #dashboard-content h4 {
            font-size: 16px;
            margin-top: 15px;
            margin-bottom: 8px;
            color: #6a6f85;
            font-weight: 600;
        }

        #dashboard-content p, #dashboard-content li {
            line-height: 1.6;
            color: #c0c5d0;
            margin-bottom: 10px;
        }

        #dashboard-content strong {
            color: #fff;
            font-weight: 600;
        }

        #dashboard-content ul, #dashboard-content ol {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        #dashboard-content code {
            background: #1a1f2e;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #4a90e2;
        }

        #dashboard-content pre {
            background: #1a1f2e;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
        }

        #dashboard-content pre code {
            background: none;
            padding: 0;
            color: #c0c5d0;
        }

        #dashboard-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }

        #dashboard-content table th,
        #dashboard-content table td {
            border: 1px solid #2a2f3e;
            padding: 10px;
            text-align: left;
        }

        #dashboard-content table th {
            background: #1a1f2e;
            color: #4a90e2;
        }

        #canvas {
            width: 100%;
            height: 100%;
        }

        /* GitHub CSV ÏÑ†ÌÉù ÌåùÏóÖ */
        #csv-popup {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        #csv-popup.active {
            display: flex;
        }

        #csv-popup-content {
            background: #1a1f2e;
            border: 1px solid #2a2f3e;
            border-radius: 8px;
            padding: 20px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        #csv-popup-content h3 {
            margin-top: 0;
            color: #fff;
            margin-bottom: 15px;
        }

        #csv-file-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #csv-file-list li {
            padding: 12px;
            margin-bottom: 8px;
            background: #2a2f3e;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            color: #fff;
        }

        #csv-file-list li:hover {
            background: #3a3f4e;
        }

        #csv-popup-close {
            margin-top: 15px;
            padding: 10px 20px;
            background: #4a90e2;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        #csv-popup-close:hover {
            background: #5aa0f2;
        }

        #bottom-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 300px;
            background: rgba(26, 31, 46, 0.98);
            border-top: 1px solid #2a2f3e;
            display: flex;
            flex-direction: column;
        }

        /* drag handle to resize bottom panel */
        #resize-handle {
            height: 6px;
            cursor: ns-resize;
            background: linear-gradient(180deg, #2a2f3e, #1a1f2e);
        }
        #resize-handle:hover {
            background: linear-gradient(180deg, #3a3f4e, #1f2738);
        }

        #controls {
            padding: 15px 20px;
            border-bottom: 1px solid #2a2f3e;
        }

        #event-tabs {
            display: flex;
            gap: 10px;
            padding: 10px 20px;
            border-bottom: 1px solid #2a2f3e;
            background: #1a1f2e;
        }

        .tab-btn {
            padding: 8px 16px;
            background: transparent;
            border: none;
            color: #8a8fa5;
            cursor: pointer;
            font-size: 13px;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab-btn:hover {
            color: #fff;
        }

        .tab-btn.active {
            color: #4a90e2;
            border-bottom-color: #4a90e2;
        }

        #event-log {
            flex: 1;
            overflow-y: auto;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }

        .event-item {
            padding: 6px 8px;
            margin-bottom: 4px;
            background: #2a2f3e;
            border-radius: 3px;
            color: #8a8fa5;
            border-left: 3px solid transparent;
            cursor: pointer;
            transition: background 0.2s;
        }

        .event-item:hover {
            background: #3a3f4e;
        }

        .event-item.selected {
            background: #4a4f5e;
            border-left-color: #4a90e2;
        }

        .event-item.kill {
            border-left-color: #ff6b6b;
        }

        .event-item.attack {
            border-left-color: #ffa500;
        }

        .event-item.hit {
            border-left-color: #4a90e2;
        }

        .event-time {
            color: #6b9bd5;
            font-weight: 600;
        }

        .event-player {
            color: #4a90e2;
            font-weight: 500;
        }

        .event-victim {
            color: #ff6b6b;
            font-weight: 500;
        }

        .event-action {
            color: #8a8fa5;
        }

        .event-weapon {
            color: #ffa500;
            font-style: italic;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .play-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #4a90e2;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .play-btn:hover {
            background: #5aa0f2;
        }

        .timeline {
            flex: 1;
            height: 6px;
            background: #2a2f3e;
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }

        .timeline-progress {
            height: 100%;
            background: #4a90e2;
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s;
        }

        .time-display {
            min-width: 100px;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .speed-btn {
            padding: 5px 10px;
            background: #2a2f3e;
            border: 1px solid #3a3f4e;
            color: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
        }

        .speed-btn.active {
            background: #4a90e2;
            border-color: #4a90e2;
        }

        .sidebar-section {
            margin-bottom: 25px;
        }

        .sidebar-section h3 {
            font-size: 12px;
            color: #8a8fa5;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #2a2f3e;
            font-size: 12px;
        }

        .stat-label {
            color: #8a8fa5;
        }

        .stat-value {
            color: #fff;
            font-weight: 500;
        }

        .stat-group {
            margin-bottom: 15px;
        }

        .stat-group-title {
            font-size: 11px;
            color: #6a6f85;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #file-input {
            margin-bottom: 20px;
            padding: 12px;
            background: #2a2f3e;
            border-radius: 6px;
            border: 1px solid #3a3f4e;
        }

        #file-input input[type="file"] {
            color: white;
            font-size: 12px;
        }

        #loading {
            text-align: center;
            padding: 20px;
            color: #8a8fa5;
            font-size: 14px;
        }

        .player-item {
            padding: 8px;
            margin-bottom: 5px;
            background: #2a2f3e;
            border-radius: 4px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-item.ct {
            border-left: 3px solid #5b9bd5;
        }

        .player-item.terrorist {
            border-left: 3px solid #ff6b6b;
        }

        .player-kd {
            font-size: 11px;
            color: #8a8fa5;
        }

        #map-info {
            background: #2a2f3e;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
        }

        #map-info-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        #map-bounds {
            font-size: 11px;
            color: #8a8fa5;
            font-family: 'Courier New', monospace;
        }

        #focus-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(26, 31, 46, 0.95);
            padding: 15px;
            border-radius: 8px;
            display: none;
            z-index: 100;
        }

        #focus-controls.show {
            display: block;
        }

        #focus-controls button {
            padding: 8px 16px;
            background: #4a90e2;
            border: none;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 10px;
        }

        #focus-controls button:hover {
            background: #5aa0f2;
        }

        #focus-info {
            font-size: 12px;
            color: #8a8fa5;
            margin-bottom: 10px;
        }

        /* Kill event picker (top-left of canvas) */
        #event-picker {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(26, 31, 46, 0.95);
            border: 1px solid #2a2f3e;
            border-radius: 8px;
            padding: 10px;
            display: flex;
            gap: 8px;
            align-items: center;
            z-index: 120;
        }

        #event-picker select, #event-picker button {
            background: #2a2f3e;
            border: 1px solid #3a3f4e;
            color: #fff;
            border-radius: 4px;
            padding: 6px 8px;
            font-size: 12px;
        }

        #event-picker button.primary {
            background: #4a90e2;
            border-color: #4a90e2;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="top-nav">
        <div id="brand-logo">
            <img id="brand-image" src="crumb_logo.png" alt="CRUMB Logo" onerror="this.style.display='none'">
            <div id="brand-text">
                <div id="brand-name">CRUMB ‚Äî Combat Replay Unified Monitoring & Behavior-analysis</div>
                <div id="brand-tagline">"Follow every trace." üçû</div>
            </div>
        </div>
        <div class="nav-item active">Dashboard</div>
        <div class="nav-item">Manage</div>
        <div class="nav-item">Investigate</div>
        <div class="nav-item" id="report-tab">Generate Report</div>
    </div>

    <div id="container" style="display: none;">
        <div id="sidebar">
            <div class="sidebar-section">
                <h3>File Load</h3>
                <div id="file-input">
                    <button id="select-csv-btn" style="width: 100%; padding: 10px; background: #4a90e2; color: #fff; border: none; border-radius: 4px; cursor: pointer; margin-bottom: 10px;">ÌååÏùº ÏÑ†ÌÉù</button>
                    <div id="selected-file" style="font-size: 12px; color: #8a8fa5; margin-bottom: 10px;">ÏÑ†ÌÉùÎêú ÌååÏùº ÏóÜÏùå</div>
                    <input type="file" id="csv-file" accept=".csv" style="display: none;" />
                    <div id="loading" style="display: none;">CSV ÌååÏùº Ï≤òÎ¶¨ Ï§ë...</div>
                </div>
            </div>

            

            <div class="sidebar-section">
                <h3>Statistics</h3>
                
                <div class="stat-group">
                    <div class="stat-group-title">Title</div>
                    <div class="stat-item">
                        <span class="stat-label">Name:</span>
                        <span class="stat-value" id="game-name">CS2</span>
                    </div>
                </div>

                <div class="stat-group">
                    <div class="stat-group-title">Game</div>
                    <div class="stat-item">
                        <span class="stat-label">Server:</span>
                        <span class="stat-value">Valve-Counter-Strike</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Game Mode:</span>
                        <span class="stat-value">SourceTV-Demo</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Start time:</span>
                        <span class="stat-value" id="start-time">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Length:</span>
                        <span class="stat-value" id="game-length">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Players:</span>
                        <span class="stat-value" id="total-players">-</span>
                    </div>
                </div>

                <div class="stat-group">
                    <div class="stat-group-title">Match</div>
                    <div class="stat-item">
                        <span class="stat-label">Match Start Time:</span>
                        <span class="stat-value" id="match-start-time">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Match Length:</span>
                        <span class="stat-value" id="match-length">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Match Mode:</span>
                        <span class="stat-value">5v5</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Map Name:</span>
                        <span class="stat-value" id="map-name">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Total Events:</span>
                        <span class="stat-value" id="total-events">-</span>
                    </div>
                </div>

                <div id="map-info">
                    <div id="map-info-title">Map Bounds</div>
                    <div id="map-bounds">Calculating...</div>
                    <div style="margin-top: 10px; padding: 10px; background: #1a1f2e; border-radius: 4px; font-size: 11px; color: #8a8fa5;">
                        <div style="margin-bottom: 5px;"><strong>Îßµ Î†åÎçîÎßÅ Ï†ïÎ≥¥:</strong></div>
                        <div>ÌòÑÏû¨ Îßµ: Anubis (Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò)</div>
                        <div style="margin-top: 5px;">Îßµ ÏßÄÏò§Î©îÌä∏Î¶¨ Îç∞Ïù¥ÌÑ∞Îäî CS2 Í≤åÏûÑ ÌååÏùº(.bsp)ÏóêÏÑú Ï∂îÏ∂úÌïòÍ±∞ÎÇò</div>
                        <div>Ïô∏Î∂Ä Îßµ Îç∞Ïù¥ÌÑ∞ APIÎ•º ÏÇ¨Ïö©Ìï¥Ïïº Ìï©ÎãàÎã§.</div>
                        <div style="margin-top: 5px; color: #4a90e2;">Ï∞∏Í≥†: ÌòÑÏû¨Îäî ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπò Í∏∞Î∞ò Í≤ΩÍ≥ÑÎßå ÌëúÏãúÎê©ÎãàÎã§.</div>
                    </div>
                </div>

                <div class="stat-group">
                    <div class="stat-group-title">Players (K/D Ratio)</div>
                    <div style="font-size: 10px; color: #6a6f85; margin-bottom: 8px; font-style: italic;">
                        K/D: Kills / Deaths - Click to filter
                    </div>
                    <div id="player-list"></div>
                </div>
            </div>
        </div>

        <div id="canvas-container">
            <canvas id="canvas"></canvas>
            <div id="event-picker">
                <select id="kill-select">
                    <option value="">Kill events will appear here</option>
                </select>
                <button id="go-kill" class="primary">Go</button>
                <button id="reset-view">Reset View</button>

                <span style="width:12px"></span>
                <select id="player-select">
                    <option value="">Players</option>
                </select>
                <button id="prev-player-tick">Prev</button>
                <button id="next-player-tick">Next</button>
                <button id="follow-toggle">Follow</button>
            </div>
            <div id="focus-controls">
                <div id="focus-info">Focus Mode: Event selected</div>
                <button id="exit-focus-btn">Exit Focus Mode</button>
            </div>
        </div>
    </div>

    

    <div id="bottom-panel">
        <div id="resize-handle" title="Drag to resize"></div>
        <div id="controls">
            <div class="control-group">
                <button class="play-btn" id="play-btn">‚ñ∂</button>
                <div class="timeline" id="timeline">
                    <div class="timeline-progress" id="timeline-progress"></div>
                </div>
                <div class="time-display" id="time-display">00:00 / 00:00</div>
                <div class="speed-control">
                    <button class="speed-btn" data-speed="0.5">0.5x</button>
                    <button class="speed-btn active" data-speed="1">1x</button>
                    <button class="speed-btn" data-speed="2">2x</button>
                    <button class="speed-btn" data-speed="3">3x</button>
                </div>
            </div>
        </div>

        <div id="event-tabs">
            <button class="tab-btn active" data-tab="actions">Action Stream</button>
            <button class="tab-btn" data-tab="chat">Match Chat</button>
            <button class="tab-btn" data-tab="aim">Aim Trace</button>
        </div>

        <div id="event-log"></div>
    </div>

    <!-- Dashboard View -->
    <div id="dashboard-view">
        <div id="dashboard-content"></div>
    </div>

    <!-- GitHub CSV ÏÑ†ÌÉù ÌåùÏóÖ -->
    <div id="csv-popup">
        <div id="csv-popup-content">
            <h3>ÌòÑÏû¨ Í≤ΩÎ°úÏóêÏÑú ÌôïÏù∏ÎêòÎäî Î¶¨ÌîåÎ†àÏù¥ ÌååÏùº ÏÑ†ÌÉù</h3>
            <div id="csv-loading" style="color: #8a8fa5;">ÌååÏùº Î™©Î°ù Î°úÎî© Ï§ë...</div>
            <ul id="csv-file-list"></ul>
            <button id="csv-popup-close">Îã´Í∏∞</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script>
        class CombatSimulation {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                
                this.data = null;
                this.currentTick = 0;
                this.isPlaying = false;
                this.playSpeed = 1;
                
                this.playerObjects = new Map();
                this.playerLabels = new Map();
                this.playerTrails = new Map();
                this.eventMarkers = [];
                this.mapBounds = null;
                this.selectedEvent = null;
                this.focusMode = false;
                this.focusTimeRange = null;
                this.focusTickRange = null;
                this.baseCameraDistance = 1500;
                this.cameraRotationX = 0.3;
                this.cameraRotationY = 0;
                this.cameraDistance = 1500;
                this.killLabels = new Map(); // ÌÇ¨ ÎùºÎ≤® Ï∂îÏ†Å (ÌéòÏù¥ÎìúÏïÑÏõÉÏö©)
                this.playerIndex = new Map(); // name -> [{tick, pos}]
                this.selectedPlayer = null;
                this.followPlayer = false;
                
                this.init();
            }

            init() {
                this.setupScene();
                this.setupControls();
                this.setupFileInput();
                this.setupTabs();
                this.setupResizableBottom();
                this.setupNavigation();
                // Ï¥àÍ∏∞ Î°úÎìú Ïãú Dashboard ÌëúÏãú
                this.showDashboard();
                this.animate();
            }

            setupFileInput() {
                const selectBtn = document.getElementById('select-csv-btn');
                const inputEl = document.getElementById('csv-file');
                
                if (selectBtn) {
                    selectBtn.addEventListener('click', () => {
                        this.showCSVPopup();
                    });
                }
                
                if (!inputEl) {
                    console.error('ÌååÏùº ÏûÖÎ†• ÏöîÏÜå(#csv-file)Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
                    return;
                }
                // Í∞ôÏùÄ ÌååÏùºÏùÑ Ïó∞ÏÜç ÏÑ†ÌÉùÌï† Îïå change Ïù¥Î≤§Ìä∏Í∞Ä Ïïà Îú®Îäî Î¨∏Ï†ú Î∞©ÏßÄ
                inputEl.addEventListener('click', () => {
                    inputEl.value = '';
                });
                inputEl.addEventListener('change', (e) => {
                    const file = e.target.files && e.target.files[0];
                    const loading = document.getElementById('loading');
                    if (loading) {
                        loading.style.display = 'block';
                        loading.innerHTML = 'Parsing CSV file...';
                    }
                    if (file) {
                        console.log('CSV ÌååÏùº ÏÑ†ÌÉùÎê®:', file.name, file.size, 'bytes');
                        document.getElementById('selected-file').textContent = file.name;
                        this.loadCSV(file);
                    } else {
                        console.warn('ÏÑ†ÌÉùÎêú ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.');
                        if (loading) loading.style.display = 'none';
                    }
                });

                // ÌåùÏóÖ Îã´Í∏∞ Î≤ÑÌäº
                const closeBtn = document.getElementById('csv-popup-close');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => {
                        document.getElementById('csv-popup').classList.remove('active');
                    });
                }
            }

            setupNavigation() {
                const navItems = document.querySelectorAll('.nav-item');
                navItems.forEach(item => {
                    item.addEventListener('click', () => {
                        const text = item.textContent.trim();
                        if (text === 'Dashboard') {
                            this.showDashboard();
                        } else if (text === 'Investigate') {
                            this.showInvestigate();
                        } else {
                            // Îã§Î•∏ ÌÉ≠Îì§ÏùÄ ÎÇòÏ§ëÏóê Íµ¨ÌòÑ
                            navItems.forEach(n => n.classList.remove('active'));
                            item.classList.add('active');
                        }
                    });
                });
            }

            showDashboard() {
                document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                document.querySelectorAll('.nav-item').forEach(n => {
                    if (n.textContent.trim() === 'Dashboard') n.classList.add('active');
                });
                
                const dashboardView = document.getElementById('dashboard-view');
                const container = document.getElementById('container');
                const bottomPanel = document.getElementById('bottom-panel');
                
                if (dashboardView && container) {
                    container.style.display = 'none';
                    dashboardView.classList.add('active');
                    // ÌïòÎã® Ìå®ÎÑê Ïà®Í∏∞Í∏∞
                    if (bottomPanel) {
                        bottomPanel.style.display = 'none';
                    }
                    this.renderDashboard();
                }
            }

            showInvestigate() {
                document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                document.querySelectorAll('.nav-item').forEach(n => {
                    if (n.textContent.trim() === 'Investigate') n.classList.add('active');
                });
                
                const dashboardView = document.getElementById('dashboard-view');
                const container = document.getElementById('container');
                const bottomPanel = document.getElementById('bottom-panel');
                
                if (dashboardView && container) {
                    dashboardView.classList.remove('active');
                    container.style.display = 'flex';
                    // ÌïòÎã® Ìå®ÎÑê Îã§Ïãú ÌëúÏãú
                    if (bottomPanel) {
                        bottomPanel.style.display = 'flex';
                    }
                }
            }

            async renderDashboard() {
                const content = document.getElementById('dashboard-content');
                if (!content) return;

                // Î∏åÎûúÎìú Ìó§Îçî Ï∂îÍ∞Ä
                const brandHeader = `
                    <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 40px; padding-bottom: 20px; border-bottom: 2px solid #2a2f3e;">
                        <img src="crumb_logo.png" alt="CRUMB Logo" onerror="this.style.display='none'" style="height: 64px; width: auto; object-fit: contain;">
                        <div>
                            <h1 style="margin: 0; font-size: 28px; color: #fff; font-weight: 600; letter-spacing: 0.5px;">CRUMB ‚Äî Combat Replay Unified Monitoring & Behavior-analysis</h1>
                            <p style="margin: 8px 0 0 0; font-size: 14px; color: #8a8fa5; font-style: italic;">"Follow every trace." üçû</p>
                        </div>
                    </div>
                `;

                // README ÎÇ¥Ïö©ÏùÑ HTMLÎ°ú Î≥ÄÌôò
                const readmeContent = `FPS Ï†ÑÌà¨ ÍµêÏ†Ñ ÏÉÅÌô©ÏùÑ 3DÎ°ú ÏãúÎÆ¨Î†àÏù¥ÏÖòÌïòÍ≥† Î∂ÑÏÑùÌïòÎäî Ï¢ÖÌï© Ïõπ ÌîåÎû´ÌèºÏûÖÎãàÎã§. Ìï¥Îãπ ÌîåÎû´ÌèºÏùÄ Ï†ÑÌà¨ ÏÉÅÌô©ÏùÑ ÏãúÍ∞ÅÌôîÌïòÍ≥†, ÌîåÎ†àÏù¥Ïñ¥ ÌñâÎèô Ìå®ÌÑ¥ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§.

## üìã Î™©Ï∞®

1. [ÏãúÎÆ¨Î†àÏù¥ÏÖò ÌîåÎû´Ìèº Íµ¨ÏÑ±](#ÏãúÎÆ¨Î†àÏù¥ÏÖò-ÌîåÎû´Ìèº-Íµ¨ÏÑ±)
2. [ÏûÖÎ†• Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞](#ÏûÖÎ†•-Îç∞Ïù¥ÌÑ∞-Íµ¨Ï°∞)
3. [Ï£ºÏöî Í∏∞Îä•](#Ï£ºÏöî-Í∏∞Îä•)
4. [Î™©Ï†Å Î∞è Í∞ÄÏπò](#Î™©Ï†Å-Î∞è-Í∞ÄÏπò)
5. [ÏÇ¨Ïö© Î∞©Î≤ï](#ÏÇ¨Ïö©-Î∞©Î≤ï)
6. [üéÆ Ïª®Ìä∏Î°§ ÏöîÏïΩ](#-Ïª®Ìä∏Î°§-ÏöîÏïΩ)
7. [üîß Í∏∞Ïà† Ïä§ÌÉù](#-Í∏∞Ïà†-Ïä§ÌÉù)
8. [üìù Ìñ•ÌõÑ Í∞úÏÑ† Í∞ÄÎä• ÏÇ¨Ìï≠](#-Ìñ•ÌõÑ-Í∞úÏÑ†-Í∞ÄÎä•-ÏÇ¨Ìï≠)

---

## üèóÔ∏è ÏãúÎÆ¨Î†àÏù¥ÏÖò ÌîåÎû´Ìèº Íµ¨ÏÑ±

### ÏïÑÌÇ§ÌÖçÏ≤ò
- **ÌîÑÎ°†Ìä∏ÏóîÎìú**: ÏàúÏàò HTML/CSS/JavaScript (Three.js Í∏∞Î∞ò)
- **Î∞±ÏóîÎìú**: ÏóÜÏùå (Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú ÏßÅÏ†ë CSV ÌååÏùº Ï≤òÎ¶¨)
- **3D ÏóîÏßÑ**: Three.js r128
- **Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨**: PapaParse (CSV ÌååÏã±)

### UI Î†àÏù¥ÏïÑÏõÉ

\`\`\`
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Top Navigation (Dashboard, Manage, Investigate)       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ          ‚îÇ                                              ‚îÇ
‚îÇ Sidebar  ‚îÇ         3D Simulation Canvas                ‚îÇ
‚îÇ          ‚îÇ      (Three.js Î†åÎçîÎßÅ ÏòÅÏó≠)                  ‚îÇ
‚îÇ - File   ‚îÇ                                              ‚îÇ
‚îÇ - Stats  ‚îÇ                                              ‚îÇ
‚îÇ - Players‚îÇ                                              ‚îÇ
‚îÇ          ‚îÇ                                              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Bottom Panel (ÎìúÎûòÍ∑∏Î°ú ÌÅ¨Í∏∞ Ï°∞Ï†à Í∞ÄÎä•)                  ‚îÇ
‚îÇ  ‚îú‚îÄ Controls (Ïû¨ÏÉù, ÌÉÄÏûÑÎùºÏù∏, ÏÜçÎèÑ)                      ‚îÇ
‚îÇ  ‚îú‚îÄ Tabs (Action Stream / Match Chat / Aim Trace)       ‚îÇ
‚îÇ  ‚îî‚îÄ Event Log / Aim Trace Visualization                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
\`\`\`

---

## üìä ÏûÖÎ†• Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞

### ÌïÑÏàò CSV Ïª¨Îüº

#### Í∏∞Î≥∏ Ï†ïÎ≥¥
- \`tick\`: Í≤åÏûÑ Ìã± Î≤àÌò∏ (Ï†ïÏàò)
- \`game_time\`: Í≤åÏûÑ ÏãúÍ∞Ñ (Ï¥à, Ïã§Ïàò)
- \`round\`: ÎùºÏö¥Îìú Î≤àÌò∏ (Ï†ïÏàò)
- \`team_name\`: ÌåÄÎ™Ö (\`CT\` ÎòêÎäî \`TERRORIST\`)
- \`name\`: ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Î¶Ñ (Î¨∏ÏûêÏó¥)

#### ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπò (Î™®Îì† Ìã±Ïóê Ï°¥Ïû¨)
- \`X\`, \`Y\`, \`Z\`: ÌîåÎ†àÏù¥Ïñ¥ 3D Ï¢åÌëú (Ïã§Ïàò)
- \`health\`: ÌîåÎ†àÏù¥Ïñ¥ Ï≤¥Î†• (0-100, Ïã§Ïàò)

#### ÌÇ¨ Ïù¥Î≤§Ìä∏ Îç∞Ïù¥ÌÑ∞ (ÌÇ¨ Î∞úÏÉù ÏãúÏ†êÏóêÎßå Ï°¥Ïû¨)
- \`event\`: Ïù¥Î≤§Ìä∏ ÌÉÄÏûÖ (Ïòà: "kill", "died")
- \`attacker_name\`: Í≥µÍ≤©Ïûê Ïù¥Î¶Ñ
- \`attacker_team_name\`: Í≥µÍ≤©Ïûê ÌåÄ
- \`attacker_X\`, \`attacker_Y\`, \`attacker_Z\`: Í≥µÍ≤©Ïûê ÏúÑÏπò
- \`attacker_yaw\`, \`attacker_pitch\`: Í≥µÍ≤©Ïûê ÎßàÏö∞Ïä§ Ï°∞Ï§Ä Í∞ÅÎèÑ
- \`attacker_health\`: Í≥µÍ≤©Ïûê Ï≤¥Î†•
- \`victim_name\`: ÌîºÌï¥Ïûê Ïù¥Î¶Ñ
- \`victim_team_name\`: ÌîºÌï¥Ïûê ÌåÄ
- \`victim_X\`, \`victim_Y\`, \`victim_Z\`: ÌîºÌï¥Ïûê ÏúÑÏπò
- \`victim_health\`: ÌîºÌï¥Ïûê Ï≤¥Î†•
- \`weapon\`: ÏÇ¨Ïö© Î¨¥Í∏∞
- \`headshot\`: Ìó§ÎìúÏÉ∑ Ïó¨Î∂Ä (boolean)

### Îç∞Ïù¥ÌÑ∞ ÌäπÏÑ±

- **ÏãúÍ∞Ñ Í∏∞Î∞ò ÏãúÌÄÄÏä§ Îç∞Ïù¥ÌÑ∞**: Í∞Å ÌñâÏùÄ ÌäπÏ†ï Ìã±Ïùò Ïä§ÎÉÖÏÉ∑
- **Ïä§ÌååÏä§ Ïù¥Î≤§Ìä∏**: ÌÇ¨ Ïù¥Î≤§Ìä∏Îäî Ìï¥Îãπ Ìã±ÏóêÎßå Ï°¥Ïû¨ (ÎÇòÎ®∏ÏßÄ ÌïÑÎìúÎäî null)
- **ÌîåÎ†àÏù¥Ïñ¥ Ï∂îÏ†Å**: Î™®Îì† Ìã±ÏóêÏÑú ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπò Ï†ïÎ≥¥ Ï†úÍ≥µ
- **Ï¢åÌëúÍ≥Ñ**: Source ÏóîÏßÑ Ï¢åÌëúÍ≥Ñ (X: Ï¢åÏö∞, Y: Ï†ÑÌõÑ, Z: ÎÜíÏù¥)

---

## üéØ Ï£ºÏöî Í∏∞Îä•

### 1. 3D ÏãúÎÆ¨Î†àÏù¥ÏÖò ÏãúÍ∞ÅÌôî

#### ÌîåÎ†àÏù¥Ïñ¥ ÌëúÌòÑ
- **CT ÌåÄ**: ÌååÎûÄÏÉâ Íµ¨Ìòï ÎßàÏª§
- **T ÌåÄ**: Îπ®Í∞ÑÏÉâ ÏÇºÍ∞ÅÌòï ÏõêÎøî ÎßàÏª§
- **ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Î¶Ñ ÎùºÎ≤®**: ÌÅ∞ Ìè∞Ìä∏(36px) + ÌåÄ ÏÉâÏÉÅ ÌÖåÎëêÎ¶¨
- **Ïù¥Îèô Í≤ΩÎ°ú Ìä∏Î†àÏùº**: ÏµúÍ∑º 100Ìã±Ïùò Ïù¥Îèô Í≤ΩÎ°ú ÌëúÏãú

#### Îßµ Í≤ΩÍ≥Ñ Î∞è Íµ¨Ïó≠
- **ÏûêÎèô Í≤ΩÍ≥Ñ Í≥ÑÏÇ∞**: Î™®Îì† ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπò Í∏∞Î∞òÏúºÎ°ú Îßµ Í≤ΩÍ≥Ñ ÏûêÎèô ÏÇ∞Ï†ï
- **Íµ¨Ïó≠ ÌëúÏãú**: 10x10 Í∑∏Î¶¨ÎìúÎ°ú Îßµ Íµ¨Ïó≠ Íµ¨Î∂Ñ (A1~C3 ÎùºÎ≤®)
- **Ï¢åÌëúÏ∂ï**: Ï§ëÏã¨Ï†ê Í∏∞Ï§Ä X, Y, Z Ï∂ï ÌëúÏãú

#### ÌÇ¨ Ïù¥Î≤§Ìä∏ ÏãúÍ∞ÅÌôî
- **Í≥µÍ≤©Ïûê ÎßàÏª§**: Îπ®Í∞ÑÏÉâ ÏõêÎøî (Í≥µÍ≤© ÏúÑÏπò)
- **Í≥µÍ≤©-ÌîºÌï¥ Ïó∞Í≤∞ÏÑ†**: Í≥µÍ≤©ÏûêÏóêÏÑú ÌîºÌï¥ÏûêÎ°ú Îπ®Í∞ÑÏÉâ ÏÑ†
- **ÌîºÌï¥Ïûê ÎùºÎ≤®**: "KILLED" + "HEADSHOT" (Ìó§ÎìúÏÉ∑Ïù∏ Í≤ΩÏö∞)
- **ÌéòÏù¥ÎìúÏïÑÏõÉ**: ÌÇ¨ Î∞úÏÉù ÌõÑ 2-3Ï¥à ÎèôÏïà Ï†êÏßÑÏ†ÅÏúºÎ°ú ÏÇ¨ÎùºÏßê

### 2. Ïù∏ÌÑ∞ÎûôÌã∞Î∏å Ïª®Ìä∏Î°§

#### Ïπ¥Î©îÎùº Ï†úÏñ¥
- **ÎßàÏö∞Ïä§ ÎìúÎûòÍ∑∏**: Ïπ¥Î©îÎùº ÌöåÏ†Ñ (Í∂§ÎèÑ Ïª®Ìä∏Î°§)
- **ÎßàÏö∞Ïä§ Ìú†**: Ï§å Ïù∏/ÏïÑÏõÉ (Îßµ ÌÅ¨Í∏∞ Í∏∞Î∞ò ÏµúÏÜå/ÏµúÎåÄ Í±∞Î¶¨)
- **Reset View**: Îßµ Ï§ëÏã¨ÏúºÎ°ú Ïπ¥Î©îÎùº Î≥µÍ∑Ä

#### Ïû¨ÏÉù Ïª®Ìä∏Î°§
- **Ïû¨ÏÉù/ÏùºÏãúÏ†ïÏßÄ**: ‚ñ∂/‚è∏ Î≤ÑÌäº
- **ÌÉÄÏûÑÎùºÏù∏**: ÌÅ¥Î¶≠ÏúºÎ°ú ÌäπÏ†ï ÏãúÏ†ê Ïù¥Îèô
- **Ïû¨ÏÉù ÏÜçÎèÑ**: 0.5x, 1x, 2x, 3x
- **ÏãúÍ∞Ñ ÌëúÏãú**: ÌòÑÏû¨ ÏãúÍ∞Ñ / Ï¥ù ÏãúÍ∞Ñ (mm:ss.mmm ÌòïÏãù)

### 3. ÌÇ¨ Ïù¥Î≤§Ìä∏ ÌïÑÌÑ∞ÎßÅ Î∞è Ìè¨Ïª§Ïä§

#### Kill Event Picker (Ï¢åÏ∏° ÏÉÅÎã®)
- ÎìúÎ°≠Îã§Ïö¥ÏóêÏÑú ÌÇ¨ Ïù¥Î≤§Ìä∏ ÏÑ†ÌÉù
- "Go" Î≤ÑÌäºÏúºÎ°ú Ìï¥Îãπ ÏãúÏ†êÏúºÎ°ú Ï¶âÏãú Ïù¥Îèô
- **Ìè¨Ïª§Ïä§ Î™®Îìú**: ÏÑ†ÌÉùÌïú ÌÇ¨ Ïù¥Î≤§Ìä∏ Í∏∞Ï§Ä ¬±30Ìã± Î≤îÏúÑ ÏûêÎèô ÏÑ§Ï†ï
  - Ïû¨ÏÉù Î≤îÏúÑÍ∞Ä Ìï¥Îãπ Íµ¨Í∞ÑÏúºÎ°ú Ï†úÌïú
  - Ïù¥Î≤§Ìä∏ Î°úÍ∑∏ÎèÑ Ìï¥Îãπ Íµ¨Í∞ÑÎßå ÌëúÏãú
  - Aim TraceÎèÑ ÎèôÏùº Íµ¨Í∞ÑÏúºÎ°ú ÎèôÍ∏∞Ìôî

#### Action Stream (ÌïòÎã®)
- Ïã§ÏãúÍ∞Ñ Ïù¥Î≤§Ìä∏ Î°úÍ∑∏
- **ÏÉâÏÉÅ Íµ¨Î∂Ñ**:
  - ÏãúÍ∞Ñ: ÌååÎûÄÏÉâ (#6b9bd5)
  - Í≥µÍ≤©Ïûê: ÌååÎûÄÏÉâ (#4a90e2)
  - ÎèôÏÇ¨: ÌöåÏÉâ (#8a8fa5)
  - ÌîºÌï¥Ïûê: Îπ®Í∞ÑÏÉâ (#ff6b6b)
  - Î¨¥Í∏∞: Ï£ºÌô©ÏÉâ (#ffa500)
- Ïù¥Î≤§Ìä∏ ÌÅ¥Î¶≠ Ïãú Ìè¨Ïª§Ïä§ Î™®Îìú ÌôúÏÑ±Ìôî

### 4. ÌîåÎ†àÏù¥Ïñ¥ Ï∂îÏ†Å ÏãúÏä§ÌÖú

#### ÌîåÎ†àÏù¥Ïñ¥ ÏÑ†ÌÉù (Ï¢åÏ∏° ÏÉÅÎã®)
- ÎìúÎ°≠Îã§Ïö¥ÏóêÏÑú ÌîåÎ†àÏù¥Ïñ¥ ÏÑ†ÌÉù
- **Prev/Next Î≤ÑÌäº**: ÏÑ†ÌÉùÌïú ÌîåÎ†àÏù¥Ïñ¥Ïùò Ïù¥Ï†Ñ/Îã§Ïùå ÏãúÏ†êÏúºÎ°ú Ï†êÌîÑ
- **Follow Î≤ÑÌäº**: Ïπ¥Î©îÎùºÍ∞Ä ÏÑ†ÌÉùÌïú ÌîåÎ†àÏù¥Ïñ¥Î•º Îî∞ÎùºÍ∞ÄÎ©∞ Ï§ëÏïôÏóê Î∞∞Ïπò
  - Ïû¨ÏÉù Ï§ëÏóêÎèÑ ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπòÎ•º Ï§ëÏã¨ÏúºÎ°ú Ïπ¥Î©îÎùº ÏûêÎèô Ïù¥Îèô

#### ÌîåÎ†àÏù¥Ïñ¥ Ï†ïÎ≥¥ (Ï¢åÏ∏° ÏÇ¨Ïù¥ÎìúÎ∞î)
- **K/D Ratio**: Kills / Deaths ÌëúÏãú
- **ÌîåÎ†àÏù¥Ïñ¥ ÌÅ¥Î¶≠**: Ìï¥Îãπ ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Ï∞∏Ïó¨Ìïú Ï≤´ Î≤àÏß∏ ÌÇ¨ Ïù¥Î≤§Ìä∏Î°ú Ïù¥Îèô

### 5. Aim Trace Î∂ÑÏÑù

#### 2D Ï°∞Ï§Ä Í∂§Ï†Å ÏãúÍ∞ÅÌôî
- **Ï¢åÌëúÍ≥Ñ**: 
  - XÏ∂ï: Yaw (-180¬∞ ~ 180¬∞)
  - YÏ∂ï: Pitch (-90¬∞ ~ 90¬∞)
- **Ìè¨Ïù∏Ìä∏ ÏÉâÏÉÅ**:
  - ÌååÎûÄÏÉâ: ÌòÑÏû¨ ÎßàÏö∞Ïä§ ÏúÑÏπò (ÏùºÎ∞ò Ïù¥Îèô)
  - ÎÖ∏ÎûÄÏÉâ: Í≥µÍ≤© ÏãúÏ†ê ÎßàÏö∞Ïä§ ÏúÑÏπò
  - Îπ®Í∞ÑÏÉâ: Hit ÏãúÏ†ê ÎßàÏö∞Ïä§ ÏúÑÏπò
  - ÏßÑÎπ®Í∞ï: Kill ÏãúÏ†ê ÎßàÏö∞Ïä§ ÏúÑÏπò (ÌÅ∞ Ïõê + ÌÖåÎëêÎ¶¨)
- **ÌòÑÏû¨ Ìã± ÌïòÏù¥ÎùºÏù¥Ìä∏**: Ïû¨ÏÉù Ï§ëÏù∏ Ìã±Ïùò ÎßàÏö∞Ïä§ ÏúÑÏπòÎ•º ÌÅ∞ ÌååÎûÄ Ï†êÏúºÎ°ú ÌëúÏãú

#### Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî
- Ïû¨ÏÉù Ï§ë Aim TraceÎèÑ Ìï®Íªò ÏóÖÎç∞Ïù¥Ìä∏
- Ìè¨Ïª§Ïä§ Î™®Îìú Ïãú Ìï¥Îãπ Íµ¨Í∞Ñ(¬±30Ìã±)Îßå ÌëúÏãú
- ÌÇ¨ Ïù¥Î≤§Ìä∏ ÏÑ†ÌÉù Ïãú Í≥µÍ≤©ÏûêÏùò Aim Trace ÏûêÎèô ÌëúÏãú

#### ÏóêÏûÑÎ¥á ÌÉêÏßÄ ÏßÄÌëú
- **Straightness Score**: ÏßÅÏÑ†ÏÑ± ÏßÄÌëú
  - Í≥ÑÏÇ∞Ïãù: ÏßÅÏÑ† Í±∞Î¶¨ / Í≤ΩÎ°ú Í∏∏Ïù¥
  - 1Ïóê Í∞ÄÍπåÏö∏ÏàòÎ°ù ÏßÅÏÑ† Ïù¥Îèô (ÏóêÏûÑÎ¥á ÏùòÏã¨)
  - Ï†úÎ™©Ïóê Ïã§ÏãúÍ∞Ñ ÌëúÏãú

### 6. ÌÜµÍ≥Ñ Ï†ïÎ≥¥ (Ï¢åÏ∏° ÏÇ¨Ïù¥ÎìúÎ∞î)

#### Match Info
- **Title**: Í≤åÏûÑ Ïù¥Î¶Ñ (CS2)
- **Game**: ÏÑúÎ≤Ñ, Î™®Îìú, ÏãúÏûë ÏãúÍ∞Ñ, Í∏∏Ïù¥, ÌîåÎ†àÏù¥Ïñ¥ Ïàò
- **Match**: Îß§Ïπò ÏãúÏûë ÏãúÍ∞Ñ, Í∏∏Ïù¥, Î™®Îìú, Îßµ Ïù¥Î¶Ñ, Ï¥ù Ïù¥Î≤§Ìä∏ Ïàò
- **Map Bounds**: Îßµ Í≤ΩÍ≥Ñ Ï¢åÌëú Î∞è ÌÅ¨Í∏∞
- **Players**: ÌîåÎ†àÏù¥Ïñ¥ Î™©Î°ù Î∞è K/D Ratio

### 7. UI Ïª§Ïä§ÌÑ∞ÎßàÏù¥Ïßï

#### ÌïòÎã® Ìå®ÎÑê ÌÅ¨Í∏∞ Ï°∞Ï†à
- ÏÉÅÎã® Í∞ÄÏû•ÏûêÎ¶¨Î•º ÎìúÎûòÍ∑∏ÌïòÏó¨ ÎÜíÏù¥ Ï°∞Ï†à
- ÏµúÏÜå 160px, ÏµúÎåÄ ÌôîÎ©¥ ÎÜíÏù¥Ïùò 80%
- ÏÑ§Ï†ïÏùÄ localStorageÏóê Ï†ÄÏû•ÎêòÏñ¥ Ïû¨Î∞©Î¨∏ Ïãú Ïú†ÏßÄ

#### ÌÉ≠ Ï†ÑÌôò
- **Action Stream**: Ïã§ÏãúÍ∞Ñ Ïù¥Î≤§Ìä∏ Î°úÍ∑∏
- **Match Chat**: Ï±ÑÌåÖ Î°úÍ∑∏ (Ìñ•ÌõÑ ÌôïÏû•)
- **Aim Trace**: Ï°∞Ï§Ä Í∂§Ï†Å Î∂ÑÏÑù

---

## üí° Î™©Ï†Å Î∞è Í∞ÄÏπò

### 1. Ï†ÑÌà¨ Î∂ÑÏÑù
- **Ï†ÑÏà† Î∂ÑÏÑù**: ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπò, Ïù¥Îèô Ìå®ÌÑ¥, Ï†ÑÌà¨ ÏÉÅÌô© ÌååÏïÖ
- **ÌÇ¨ Ïù¥Î≤§Ìä∏ ÏÉÅÏÑ∏ Î∂ÑÏÑù**: Í≥µÍ≤©Ïûê-ÌîºÌï¥Ïûê Í¥ÄÍ≥Ñ, Î¨¥Í∏∞ ÏÇ¨Ïö©, Ìó§ÎìúÏÉ∑ ÎπÑÏú®
- **ÏãúÍ∞Ñ Í∏∞Î∞ò Î∂ÑÏÑù**: ÌäπÏ†ï ÏãúÏ†ê Ï†ÑÌõÑ ÏÉÅÌô© Ï∂îÏ†Å

### 2. ÏπòÌåÖ ÌÉêÏßÄ
- **ÏóêÏûÑÎ¥á ÌÉêÏßÄ**: Aim TraceÏùò ÏßÅÏÑ†ÏÑ± Î∂ÑÏÑùÏúºÎ°ú ÎπÑÏ†ïÏÉÅÏ†ÅÏù∏ ÎßàÏö∞Ïä§ Ïù¥Îèô Ìå®ÌÑ¥ ÏãùÎ≥Ñ
- **ÌñâÎèô Ìå®ÌÑ¥ Î∂ÑÏÑù**: ÌîåÎ†àÏù¥Ïñ¥Î≥Ñ Ïù¥Îèô Î∞è Ï°∞Ï§Ä Ìå®ÌÑ¥ ÎπÑÍµê
- **ÏùòÏã¨ÎèÑ ÏßÄÌëú**: Straightness ScoreÎ°ú Í∞ùÍ¥ÄÏ†Å ÌèâÍ∞Ä

### 3. ÍµêÏú° Î∞è ÌïôÏäµ
- **Ï†ÑÌà¨ ÏãúÎÆ¨Î†àÏù¥ÏÖò**: Ïã§Ï†ú Í≤ΩÍ∏∞ ÏÉÅÌô©ÏùÑ 3DÎ°ú Ïû¨ÌòÑÌïòÏó¨ ÌïôÏäµ
- **ÌîåÎ†àÏù¥Ïñ¥ Ï∂îÏ†Å**: Í∞úÎ≥Ñ ÌîåÎ†àÏù¥Ïñ¥Ïùò ÏõÄÏßÅÏûÑÍ≥º Ï†ÑÏà† Î∂ÑÏÑù
- **Ïã§ÏãúÍ∞Ñ Ïû¨ÏÉù**: Îã§ÏñëÌïú ÏÜçÎèÑÎ°ú ÏÉÅÌô© Ïû¨ÌòÑ

### 4. Îç∞Ïù¥ÌÑ∞ ÏãúÍ∞ÅÌôî
- **ÎåÄÍ∑úÎ™® Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨**: ÏàòÎßå Ï§ÑÏùò CSV Îç∞Ïù¥ÌÑ∞Î•º Ïã§ÏãúÍ∞ÑÏúºÎ°ú Ï≤òÎ¶¨
- **Ïù∏ÌÑ∞ÎûôÌã∞Î∏å ÌÉêÏÉâ**: ÌÅ¥Î¶≠, ÎìúÎûòÍ∑∏, ÌïÑÌÑ∞ÎßÅÏúºÎ°ú ÏõêÌïòÎäî Ï†ïÎ≥¥ Ï¶âÏãú Ï†ëÍ∑º
- **Îßµ Í∏∞Î∞ò ÏãúÍ∞ÅÌôî**: 3D Í≥µÍ∞ÑÏóêÏÑú ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπòÏôÄ Ïù¥Î≤§Ìä∏Î•º ÏßÅÍ¥ÄÏ†ÅÏúºÎ°ú ÌëúÏãú

---

## üöÄ ÏÇ¨Ïö© Î∞©Î≤ï

### 1. ÌååÏùº Ï§ÄÎπÑ
- CSV ÌååÏùº Ï§ÄÎπÑ: \`sample_dataset_kill_tick_info.csv\` ÌòïÏãù Ï§ÄÏàò

### 2. Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú Ïã§Ìñâ
\`\`\`bash
# ÌååÏùº ÌÉêÏÉâÍ∏∞ÏóêÏÑú simulation_enhanced.html ÎçîÎ∏îÌÅ¥Î¶≠
# ÎòêÎäî
explorer simulation_enhanced.html
\`\`\`

### 3. Îç∞Ïù¥ÌÑ∞ Î°úÎìú
1. Ï¢åÏ∏° ÏÇ¨Ïù¥ÎìúÎ∞î "File Load" ÏÑπÏÖòÏóêÏÑú CSV ÌååÏùº ÏÑ†ÌÉù
2. Ï≤òÎ¶¨ ÏôÑÎ£åÍπåÏßÄ ÎåÄÍ∏∞ (ÏßÑÌñâ ÏÉÅÌô© ÏΩòÏÜîÏóê ÌëúÏãú)

### 4. ÏãúÎÆ¨Î†àÏù¥ÏÖò ÌÉêÏÉâ
- **3D ÏãúÍ∞ÅÌôî**: Ï∫îÎ≤ÑÏä§ÏóêÏÑú ÎßàÏö∞Ïä§Î°ú Ïπ¥Î©îÎùº Ï°∞Ïûë
- **ÌÇ¨ Ïù¥Î≤§Ìä∏ ÏÑ†ÌÉù**: Ï¢åÏ∏° ÏÉÅÎã® Kill Event PickerÏóêÏÑú ÏÑ†ÌÉù
- **ÌîåÎ†àÏù¥Ïñ¥ Ï∂îÏ†Å**: Players ÎìúÎ°≠Îã§Ïö¥ÏóêÏÑú ÌîåÎ†àÏù¥Ïñ¥ ÏÑ†ÌÉù ÌõÑ Follow ÌôúÏÑ±Ìôî
- **Aim Trace Î∂ÑÏÑù**: ÌïòÎã® Aim Trace ÌÉ≠ÏóêÏÑú Ï°∞Ï§Ä Í∂§Ï†Å ÌôïÏù∏

### 5. Ìè¨Ïª§Ïä§ Î™®Îìú ÌôúÏö©
1. ÌÇ¨ Ïù¥Î≤§Ìä∏ ÏÑ†ÌÉù (Event Picker ÎòêÎäî Action Stream)
2. ÏûêÎèôÏúºÎ°ú ¬±30Ìã± Î≤îÏúÑ ÏÑ§Ï†ï
3. Ïû¨ÏÉù Î≤ÑÌäºÏúºÎ°ú Ìï¥Îãπ Íµ¨Í∞Ñ Î∞òÎ≥µ Ïû¨ÏÉù
4. Aim TraceÏóêÏÑú Í≥µÍ≤©ÏûêÏùò ÎßàÏö∞Ïä§ Ïù¥Îèô Ìå®ÌÑ¥ ÌôïÏù∏

---

## üéÆ Ïª®Ìä∏Î°§ ÏöîÏïΩ

| ÏûÖÎ†• | ÎèôÏûë |
|------|------|
| ÎßàÏö∞Ïä§ ÎìúÎûòÍ∑∏ | Ïπ¥Î©îÎùº ÌöåÏ†Ñ |
| ÎßàÏö∞Ïä§ Ìú† | Ï§å Ïù∏/ÏïÑÏõÉ |
| Ïû¨ÏÉù Î≤ÑÌäº | ÏãúÎÆ¨Î†àÏù¥ÏÖò ÏãúÏûë/ÏùºÏãúÏ†ïÏßÄ |
| ÌÉÄÏûÑÎùºÏù∏ ÌÅ¥Î¶≠ | ÌäπÏ†ï ÏãúÏ†êÏúºÎ°ú Ïù¥Îèô |
| ÏÜçÎèÑ Î≤ÑÌäº | Ïû¨ÏÉù ÏÜçÎèÑ Ï°∞Ï†à (0.5x ~ 3x) |
| ÌïòÎã® Ìå®ÎÑê ÏÉÅÎã® Í∞ÄÏû•ÏûêÎ¶¨ ÎìúÎûòÍ∑∏ | Ìå®ÎÑê ÎÜíÏù¥ Ï°∞Ï†à |
| ESC ÌÇ§ | Ìè¨Ïª§Ïä§ Î™®Îìú Ï¢ÖÎ£å |

---

## üîß Í∏∞Ïà† Ïä§ÌÉù

- **Three.js r128**: 3D Î†åÎçîÎßÅ
- **PapaParse**: CSV ÌååÏã±
- **Canvas API**: 2D Í∑∏ÎûòÌîÑ Î∞è ÎùºÎ≤® Î†åÎçîÎßÅ
- **LocalStorage**: UI ÏÑ§Ï†ï Ï†ÄÏû•
- **ÏàúÏàò JavaScript**: Ïô∏Î∂Ä ÌîÑÎ†àÏûÑÏõåÌÅ¨ ÏóÜÏù¥ Íµ¨ÌòÑ

---

## üìù Ìñ•ÌõÑ Í∞úÏÑ† Í∞ÄÎä• ÏÇ¨Ìï≠

- [ ] Ïã§Ï†ú CS:GO Îßµ ÌÖçÏä§Ï≤ò Î∞è ÏßÄÌòï Î°úÎìú
- [ ] Îã§Ï§ë ÌîåÎ†àÏù¥Ïñ¥ ÎèôÏãú Ï∂îÏ†Å
- [ ] ÌûàÌä∏Îßµ ÏãúÍ∞ÅÌôî
- [ ] ÌÜµÍ≥Ñ ÎåÄÏãúÎ≥¥Îìú ÌôïÏû•
- [ ] ÏóêÏûÑÎ¥á ÌÉêÏßÄ ÏïåÍ≥†Î¶¨Ï¶ò Í≥†ÎèÑÌôî
- [ ] Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Í∏∞Îä•

---

## üìÑ ÎùºÏù¥ÏÑ†Ïä§

Ïù¥ ÌîÑÎ°úÏ†ùÌä∏Îäî ÍµêÏú° Î∞è Ïó∞Íµ¨ Î™©Ï†ÅÏúºÎ°ú Ï†úÏûëÎêòÏóàÏäµÎãàÎã§.`;

                // Í∞ÑÎã®Ìïú ÎßàÌÅ¨Îã§Ïö¥ ÌååÏÑú (Í∏∞Î≥∏Ï†ÅÏù∏ Î≥ÄÌôò)
                content.innerHTML = brandHeader + this.markdownToHTML(readmeContent);
            }

            markdownToHTML(markdown) {
                let html = markdown;
                
                // Ìó§ÎçîÏóê ID Ï∂îÍ∞ÄÎ•º ÏúÑÌïú Ìó¨Ìçº Ìï®Ïàò
                const createId = (text) => {
                    return text.toLowerCase()
                        .replace(/[^\w\u3131-\u318E\uAC00-\uD7A3]+/g, '-')
                        .replace(/^-+|-+$/g, '');
                };
                
                // ÎßÅÌÅ¨ Î≥ÄÌôò (Ìó§Îçî Î≥ÄÌôò Ï†ÑÏóê Ï≤òÎ¶¨)
                html = html.replace(/\[([^\]]+)\]\(#([^\)]+)\)/g, (match, text, anchor) => {
                    return `<a href="#${anchor}" style="color: #4a90e2; text-decoration: none; border-bottom: 1px solid #4a90e2;">${text}</a>`;
                });
                
                // Ìó§Îçî Î≥ÄÌôò (ID Ìè¨Ìï®) - ÏàúÏÑú Ï§ëÏöî: h4 -> h3 -> h2 -> h1
                html = html.replace(/^#### (.*$)/gim, (match, text) => {
                    const id = createId(text);
                    return `<h4 id="${id}">${text}</h4>`;
                });
                html = html.replace(/^### (.*$)/gim, (match, text) => {
                    const id = createId(text);
                    return `<h3 id="${id}">${text}</h3>`;
                });
                html = html.replace(/^## (.*$)/gim, (match, text) => {
                    const id = createId(text);
                    return `<h2 id="${id}">${text}</h2>`;
                });
                html = html.replace(/^# (.*$)/gim, (match, text) => {
                    const id = createId(text);
                    return `<h1 id="${id}">${text}</h1>`;
                });
                
                // Î≥ºÎìúÏ≤¥ Î≥ÄÌôò (**ÌÖçÏä§Ìä∏**)
                html = html.replace(/\*\*([^\*]+)\*\*/g, '<strong>$1</strong>');
                
                // ÏΩîÎìú Î∏îÎ°ù
                html = html.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>');
                html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
                
                // Î¶¨Ïä§Ìä∏
                html = html.replace(/^- (.*$)/gim, '<li>$1</li>');
                html = html.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
                
                // ÌÖåÏù¥Î∏î (Í∞ÑÎã®Ìïú Ï≤òÎ¶¨)
                html = html.replace(/\|(.+)\|/g, (match) => {
                    const cells = match.split('|').filter(c => c.trim());
                    if (cells.length > 0) {
                        return '<tr>' + cells.map(c => '<td>' + c.trim() + '</td>').join('') + '</tr>';
                    }
                    return match;
                });
                
                // Îã®ÎùΩ
                html = html.replace(/\n\n/g, '</p><p>');
                html = '<p>' + html + '</p>';
                
                // Ï§ÑÎ∞îÍøà
                html = html.replace(/\n/g, '<br>');
                
                // ÏïµÏª§ ÎßÅÌÅ¨ ÌÅ¥Î¶≠ Ïãú DashboardÎ°ú Ïù¥ÎèôÌïòÍ≥† Î∂ÄÎìúÎü¨Ïö¥ Ïä§ÌÅ¨Î°§
                setTimeout(() => {
                    document.querySelectorAll('#dashboard-content a[href^="#"]').forEach(link => {
                        link.addEventListener('click', (e) => {
                            e.preventDefault();
                            
                            // DashboardÍ∞Ä Ïó¥Î†§ÏûàÏßÄ ÏïäÏúºÎ©¥ DashboardÎ°ú Ïù¥Îèô
                            const dashboardView = document.getElementById('dashboard-view');
                            const container = document.getElementById('container');
                            if (dashboardView && !dashboardView.classList.contains('active')) {
                                // Dashboard ÌÉ≠ ÌôúÏÑ±Ìôî
                                document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                                document.querySelectorAll('.nav-item').forEach(n => {
                                    if (n.textContent.trim() === 'Dashboard') n.classList.add('active');
                                });
                                
                                // Dashboard Î∑∞ ÌëúÏãú
                                if (container) {
                                    container.style.display = 'none';
                                }
                                dashboardView.classList.add('active');
                                
                                // ÌïòÎã® Ìå®ÎÑê Ïà®Í∏∞Í∏∞
                                const bottomPanel = document.getElementById('bottom-panel');
                                if (bottomPanel) {
                                    bottomPanel.style.display = 'none';
                                }
                            }
                            
                            // Ìï¥Îãπ ÏÑπÏÖòÏúºÎ°ú Ïä§ÌÅ¨Î°§
                            const targetId = link.getAttribute('href').substring(1);
                            setTimeout(() => {
                                const targetElement = document.getElementById(targetId);
                                if (targetElement) {
                                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                }
                            }, dashboardView && !dashboardView.classList.contains('active') ? 200 : 0);
                        });
                    });
                }, 100);
                
                return html;
            }

            async showCSVPopup() {
                const popup = document.getElementById('csv-popup');
                const fileList = document.getElementById('csv-file-list');
                const loading = document.getElementById('csv-loading');
                
                if (!popup || !fileList) return;
                
                popup.classList.add('active');
                fileList.innerHTML = '';
                loading.style.display = 'block';
                
                try {
                    // GitHub APIÎ°ú CSV ÌååÏùº Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞
                    const repo = 'bangilhan/fps_combat_simulation';
                    const response = await fetch(`https://api.github.com/repos/${repo}/contents`);
                    const files = await response.json();
                    
                    // CSV ÌååÏùºÎßå ÌïÑÌÑ∞ÎßÅ
                    const csvFiles = files.filter(file => 
                        file.type === 'file' && file.name.endsWith('.csv')
                    );
                    
                    loading.style.display = 'none';
                    
                    if (csvFiles.length === 0) {
                        fileList.innerHTML = '<li style="color: #8a8fa5;">CSV ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.</li>';
                        return;
                    }
                    
                    csvFiles.forEach(file => {
                        const li = document.createElement('li');
                        li.textContent = file.name;
                        li.addEventListener('click', () => {
                            this.loadCSVFromGitHub(file.download_url, file.name);
                            popup.classList.remove('active');
                        });
                        fileList.appendChild(li);
                    });
                } catch (error) {
                    console.error('GitHub ÌååÏùº Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®:', error);
                    loading.style.display = 'none';
                    fileList.innerHTML = '<li style="color: #ff6b6b;">ÌååÏùº Î™©Î°ùÏùÑ Í∞ÄÏ†∏Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.</li>';
                }
            }

            async loadCSVFromGitHub(url, filename) {
                const loading = document.getElementById('loading');
                const selectedFile = document.getElementById('selected-file');
                
                if (loading) {
                    loading.style.display = 'block';
                    loading.innerHTML = 'GitHubÏóêÏÑú CSV ÌååÏùº Îã§Ïö¥Î°úÎìú Ï§ë...';
                }
                
                if (selectedFile) {
                    selectedFile.textContent = filename;
                }
                
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const text = await response.text();
                    
                    // ÌÖçÏä§Ìä∏Î•º BlobÏúºÎ°ú Î≥ÄÌôòÌïòÏó¨ File Í∞ùÏ≤¥Ï≤òÎüº ÏÇ¨Ïö©
                    const blob = new Blob([text], { type: 'text/csv' });
                    const file = new File([blob], filename, { type: 'text/csv' });
                    
                    await this.loadCSV(file);
                } catch (error) {
                    console.error('CSV ÌååÏùº Îã§Ïö¥Î°úÎìú Ïã§Ìå®:', error);
                    if (loading) {
                        loading.innerHTML = 'Ïò§Î•ò: ' + error.message;
                    }
                    alert('CSV ÌååÏùºÏùÑ Îã§Ïö¥Î°úÎìúÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + error.message);
                }
            }

            setupTabs() {
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        // ÌÉ≠ Ï†ÑÌôò
                        const tab = btn.getAttribute('data-tab');
                        if (tab === 'aim') {
                            this.renderAimTrace();
                        } else if (tab === 'actions') {
                            this.updateEventLog();
                        } else {
                            // chat placeholder
                            const eventLog = document.getElementById('event-log');
                            eventLog.innerHTML = '<div style="padding:10px;color:#8a8fa5;">Chat view TBD</div>';
                        }
                    });
                });

                // Ìè¨Ïª§Ïä§ Î™®Îìú Ï¢ÖÎ£å Î≤ÑÌäº
                document.getElementById('exit-focus-btn').addEventListener('click', () => {
                    this.exitFocusMode();
                });
                
                // Î≥¥Í≥†ÏÑú ÏÉùÏÑ± ÌÉ≠
                document.getElementById('report-tab').addEventListener('click', () => {
                    const playerName = this.selectedPlayer || (this.selectedEvent && this.selectedEvent.attacker && this.selectedEvent.attacker.name) || 
                                    ((this.data && this.data.metadata && this.data.metadata.players && this.data.metadata.players[0]) || null);
                    if (playerName) {
                        this.generateReport(playerName);
                    } else {
                        alert('Please select a player first');
                    }
                });
            }

            async loadCSV(file) {
                const loading = document.getElementById('loading');
                if (loading) {
                    loading.style.display = 'block';
                    loading.innerHTML = 'Parsing CSV file...';
                }
                
                return new Promise((resolve) => {
                    try {
                        // PapaParse Î°úÎìú ÌôïÏù∏
                        if (typeof Papa === 'undefined' || !Papa || !Papa.parse) {
                            console.error('PapaParseÍ∞Ä Î°úÎìúÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');
                            if (loading) loading.innerHTML = 'Error: CSV parser not loaded. ÎÑ§Ìä∏ÏõåÌÅ¨Î•º ÌôïÏù∏ÌïòÍ≥† ÏÉàÎ°úÍ≥†Ïπ®(Ctrl+F5) Ìï¥Ï£ºÏÑ∏Ïöî.';
                            resolve();
                            return;
                        }
                        Papa.parse(file, {
                            header: true,
                            skipEmptyLines: true,
                            complete: async (results) => {
                                console.log('CSV ÌååÏã± ÏôÑÎ£å:', results.data.length, 'Ï§Ñ');
                                console.log('Ï≤´ Î≤àÏß∏ Ìñâ ÏÉòÌîå:', results.data[0]);
                                
                                if (!results || !results.data || results.data.length === 0) {
                                    console.error('CSV ÌååÏã± Í≤∞Í≥ºÍ∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§');
                                    alert('CSV ÌååÏùºÏóê Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.');
                                    if (loading) loading.style.display = 'none';
                                    resolve();
                                    return;
                                }
                                
                                if (loading) loading.innerHTML = 'Processing data... 0%';
                                try {
                                    await this.processData(results.data);
                                } catch (procError) {
                                    console.error('processData Ïò§Î•ò:', procError);
                                    alert('Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò: ' + procError.message);
                                }
                                if (loading) loading.style.display = 'none';
                                resolve();
                            },
                            error: (error) => {
                                console.error('CSV ÌååÏã± Ïò§Î•ò:', error);
                                if (loading) loading.style.display = 'none';
                                alert('CSV ÌååÏùºÏùÑ ÏùΩÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + error.message);
                                resolve();
                            }
                        });
                    } catch (error) {
                        console.error('loadCSV Ïò§Î•ò:', error);
                        if (loading) loading.style.display = 'none';
                        alert('ÌååÏùº Î°úÎìú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + error.message);
                        resolve();
                    }
                });
            }

            async processData(rows) {
                try {
                    console.log('processData ÏãúÏûë, Ï¥ù Ìñâ Ïàò:', rows.length);
                    if (!rows || rows.length === 0) {
                        console.error('Îç∞Ïù¥ÌÑ∞Í∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§');
                        alert('CSV ÌååÏùºÏóê Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.');
                        return;
                    }
                    
                    const positions = [];
                    const events = [];
                    const aimIndex = new Map(); // name -> [{yaw,pitch,time,type}]
                    
                    // Îßµ Í≤ΩÍ≥Ñ Ï∂îÏ†ÅÏö© (Î≥ÑÎèÑ Î∞∞Ïó¥ ÏóÜÏù¥ ÏßÅÏ†ë Í≥ÑÏÇ∞)
                    let minX = Infinity, maxX = -Infinity;
                    let minY = Infinity, maxY = -Infinity;
                    let minZ = Infinity, maxZ = -Infinity;
                    
                    let tickData = {};
                    let currentTick = null;
                    
                    const totalRows = rows.length;
                    const chunkSize = 1000; // Ï≤≠ÌÅ¨ Îã®ÏúÑÎ°ú Ï≤òÎ¶¨ÌïòÏó¨ UI Ï∞®Îã® Î∞©ÏßÄ
                    
                    // ÏßÑÌñâ ÏÉÅÌô© ÌëúÏãú
                    const loading = document.getElementById('loading');
                    const updateProgress = (progress) => {
                        if (loading) {
                            loading.style.display = 'block';
                            loading.innerHTML = 'Processing data... ' + Math.round(progress) + '%';
                        }
                    };
                    
                    // Ï≤≠ÌÅ¨ Îã®ÏúÑ Ï≤òÎ¶¨
                    for (let chunkStart = 0; chunkStart < totalRows; chunkStart += chunkSize) {
                        const chunkEnd = Math.min(chunkStart + chunkSize, totalRows);
                        const chunk = rows.slice(chunkStart, chunkEnd);
                        
                        chunk.forEach((row, localIdx) => {
                        const idx = chunkStart + localIdx;
                        
                        const tickStr = row.tick && row.tick.trim ? row.tick.trim() : null;
                        if (!tickStr) return;
                        
                        const tick = parseInt(tickStr);
                        const gameTime = parseFloat(row.game_time || 0);
                        
                        if (currentTick !== tick && currentTick !== null && tickData.players && tickData.players.length) {
                            positions.push({
                                tick: currentTick,
                                game_time: tickData.game_time || 0,
                                players: tickData.players || []
                            });
                            tickData = { players: [] };
                        }
                        
                        currentTick = tick;
                        tickData.game_time = gameTime;
                        
                        const x = row.X && row.X.trim ? row.X.trim() : null;
                        const y = row.Y && row.Y.trim ? row.Y.trim() : null;
                        const z = row.Z && row.Z.trim ? row.Z.trim() : null;
                        if (x && y && z && row.name && row.name.trim && row.name.trim()) {
                            const posX = parseFloat(x);
                            const posY = parseFloat(y);
                            const posZ = parseFloat(z);
                            
                            // Îßµ Í≤ΩÍ≥Ñ ÏßÅÏ†ë ÏóÖÎç∞Ïù¥Ìä∏ (Î∞∞Ïó¥ Ï†ÄÏû• Î∂àÌïÑÏöî)
                            if (!Number.isNaN(posX)) {
                                if (posX < minX) minX = posX;
                                if (posX > maxX) maxX = posX;
                            }
                            if (!Number.isNaN(posY)) {
                                if (posY < minY) minY = posY;
                                if (posY > maxY) maxY = posY;
                            }
                            if (!Number.isNaN(posZ)) {
                                if (posZ < minZ) minZ = posZ;
                                if (posZ > maxZ) maxZ = posZ;
                            }
                            
                            tickData.players = tickData.players || [];
                            // yaw, pitch Ï†ïÎ≥¥ÎèÑ ÏàòÏßë (ÌîåÎ†àÏù¥Ïñ¥ Îç∞Ïù¥ÌÑ∞Ïóê) - ÏÉà Îç∞Ïù¥ÌÑ∞Îäî Í∞Å Ìã±Î≥ÑÎ°ú Î™®Îì† ÌîåÎ†àÏù¥Ïñ¥Ïùò yaw/pitchÍ∞Ä ÏûàÏùå
                            const yawStr = row.yaw && row.yaw.trim ? row.yaw.trim() : null;
                            const pitchStr = row.pitch && row.pitch.trim ? row.pitch.trim() : null;
                            // attacker_yaw/pitchÎäî fallbackÏúºÎ°úÎßå ÏÇ¨Ïö© (ÌÇ¨ Ïù¥Î≤§Ìä∏ Ïãú)
                            const yaw = yawStr ? parseFloat(yawStr) : (row.attacker_yaw && row.attacker_yaw.trim ? parseFloat(row.attacker_yaw.trim()) : null);
                            const pitch = pitchStr ? parseFloat(pitchStr) : (row.attacker_pitch && row.attacker_pitch.trim ? parseFloat(row.attacker_pitch.trim()) : null);
                            
                            tickData.players.push({
                                name: row.name.trim(),
                            team: (row.team_name && row.team_name.trim ? row.team_name.trim() : '') || '',
                                position: [posX, posZ, posY],
                                health: parseFloat(row.health || 100),
                                round: parseInt(row.round || 1),
                            weapon: (row.weapon && row.weapon.trim ? row.weapon.trim() : null),
                                yaw: !Number.isNaN(yaw) ? yaw : null,
                                pitch: !Number.isNaN(pitch) ? pitch : null
                            });
                        }
                        
                        if (row.event && row.event.trim && row.event.trim()) {
                            const eventType = row.event.trim().toLowerCase();
                            
                            // ÌÇ¨ Ïù¥Î≤§Ìä∏ Ï§ëÎ≥µ Ï≤¥ÌÅ¨: Í∞ôÏùÄ tickÏùò ÌÇ¨ Ïù¥Î≤§Ìä∏Í∞Ä Ïù¥ÎØ∏ ÏûàÏúºÎ©¥ Ï∂îÍ∞ÄÌïòÏßÄ ÏïäÏùå
                            let shouldAddEvent = true;
                            if (eventType.includes('kill') || eventType.includes('died')) {
                                const attackerName = row.attacker_name && row.attacker_name.trim ? row.attacker_name.trim() : null;
                                const victimName = row.victim_name && row.victim_name.trim ? row.victim_name.trim() : null;
                                const existingKill = events.find(e => 
                                    e.tick === tick && 
                                    (e.event_type_lower && (e.event_type_lower.includes('kill') || e.event_type_lower.includes('died'))) &&
                                    e.attacker && e.attacker.name === attackerName &&
                                    e.victim && e.victim.name === victimName
                                );
                                if (existingKill) {
                                    // Ïù¥ÎØ∏ Í∞ôÏùÄ ÌÇ¨ Ïù¥Î≤§Ìä∏Í∞Ä ÏûàÏúºÎ©¥ Ï∂îÍ∞ÄÌïòÏßÄ ÏïäÏùå
                                    shouldAddEvent = false;
                                }
                            }
                            
                            if (shouldAddEvent) {
                                events.push({
                                tick: tick,
                                game_time: gameTime,
                                event_type: row.event.trim(),
                                event_type_lower: eventType,
                            attacker: {
                                    name: (row.attacker_name && row.attacker_name.trim ? row.attacker_name.trim() : null),
                                    team: (row.attacker_team_name && row.attacker_team_name.trim ? row.attacker_team_name.trim() : null),
                                    position: [
                                        (row.attacker_X && row.attacker_X.trim ? parseFloat(row.attacker_X) : null),
                                        (row.attacker_Z && row.attacker_Z.trim ? parseFloat(row.attacker_Z) : null),
                                        (row.attacker_Y && row.attacker_Y.trim ? parseFloat(row.attacker_Y) : null)
                                    ],
                                    weapon: (row.weapon && row.weapon.trim ? row.weapon.trim() : null)
                                },
                                victim: {
                                    name: (row.victim_name && row.victim_name.trim ? row.victim_name.trim() : null),
                                    team: (row.victim_team_name && row.victim_team_name.trim ? row.victim_team_name.trim() : null),
                                    position: [
                                        (row.victim_X && row.victim_X.trim ? parseFloat(row.victim_X) : null),
                                        (row.victim_Z && row.victim_Z.trim ? parseFloat(row.victim_Z) : null),
                                        (row.victim_Y && row.victim_Y.trim ? parseFloat(row.victim_Y) : null)
                                    ]
                                },
                            weapon: (row.weapon && row.weapon.trim ? row.weapon.trim() : null),
                            headshot: (row.headshot && row.headshot.trim ? row.headshot.trim().toLowerCase() === 'true' : false)
                                });
                            }

                            // ÌÇ¨ Ïù¥Î≤§Ìä∏Ïùò Í≥µÍ≤©Ïûê Aim Îç∞Ïù¥ÌÑ∞ ÏàòÏßë (ÎÇòÏ§ëÏóê ÏùºÍ¥Ñ Ï≤òÎ¶¨)
                            if (eventType.includes('kill') || eventType.includes('died')) {
                            const yawStr = row.attacker_yaw && row.attacker_yaw.trim ? row.attacker_yaw.trim() : null;
                            const pitchStr = row.attacker_pitch && row.attacker_pitch.trim ? row.attacker_pitch.trim() : null;
                            const attackerName = row.attacker_name && row.attacker_name.trim ? row.attacker_name.trim() : null;
                                if (attackerName && yawStr && pitchStr) {
                                    const yaw = parseFloat(yawStr);
                                    const pitch = parseFloat(pitchStr);
                                    if (!Number.isNaN(yaw) && !Number.isNaN(pitch)) {
                                        if (!aimIndex.has(attackerName)) aimIndex.set(attackerName, []);
                                        // Ï§ëÎ≥µ Ï≤¥ÌÅ¨: Í∞ôÏùÄ tickÏùò ÌÇ¨Ïù¥ Ïù¥ÎØ∏ ÏûàÏúºÎ©¥ Ï∂îÍ∞ÄÌïòÏßÄ ÏïäÏùå
                                        const existingKill = aimIndex.get(attackerName).find(a => 
                                            a.type === 'kill' && a.tick === tick && Math.abs(a.time - gameTime) < 0.01
                                        );
                                        if (!existingKill) {
                                            // ÏûÑÏãúÎ°ú Ï†ÄÏû• (ÎÇòÏ§ëÏóê ÏùºÍ¥Ñ Ï≤òÎ¶¨)
                                            aimIndex.get(attackerName).push({ 
                                                yaw, pitch, time: gameTime, tick: tick, type: 'kill',
                                                _temp: true // ÏûÑÏãú ÌëúÏãú
                                            });
                                        }
                                    }
                                }
                            }
                            }
                        });
                        
                        // ÏßÑÌñâ ÏÉÅÌô© ÏóÖÎç∞Ïù¥Ìä∏ Î∞è UI Ï∞®Îã® Î∞©ÏßÄ
                        updateProgress((chunkEnd / totalRows) * 100);
                        await new Promise(resolve => setTimeout(resolve, 0)); // Îã§Ïùå Ïù¥Î≤§Ìä∏ Î£®ÌîÑÎ°ú
                    }
                    
                    if (currentTick !== null && tickData.players && tickData.players.length) {
                        positions.push({
                            tick: currentTick,
                            game_time: tickData.game_time || 0,
                            players: tickData.players || []
                        });
                    }
                    
                    // Îßµ Í≤ΩÍ≥Ñ Í≥ÑÏÇ∞ (Ïù¥ÎØ∏ Í≥ÑÏÇ∞Îê®)
                    if (minX !== Infinity && maxX !== -Infinity) {
                        this.mapBounds = {
                            minX: minX,
                            maxX: maxX,
                            minY: minY,
                            maxY: maxY,
                            minZ: minZ,
                            maxZ: maxZ,
                            centerX: (minX + maxX) / 2,
                            centerY: (minY + maxY) / 2,
                            centerZ: (minZ + maxZ) / 2,
                            width: maxX - minX,
                            height: maxY - minY,
                            depth: maxZ - minZ
                        };
                    }
                    
                    const gameTimes = positions.map(p => p.game_time).filter(t => t);
                    const ticks = positions.map(p => p.tick).filter(t => t);
                    const players = new Set();
                    const playerStats = new Map();
                    const playerIndex = new Map();
                    
                    // ÌîåÎ†àÏù¥Ïñ¥ Ïù∏Îç±Ïä§ Î∞è Aim Îç∞Ïù¥ÌÑ∞ ÏàòÏßë (ÏµúÏ†ÅÌôî)
                    positions.forEach(p => {
                    p.players.forEach(pl => {
                        if (pl.name) {
                            players.add(pl.name);
                            if (!playerStats.has(pl.name)) {
                                playerStats.set(pl.name, { kills: 0, deaths: 0, team: pl.team });
                            }
                            if (!playerIndex.has(pl.name)) playerIndex.set(pl.name, []);
                            playerIndex.get(pl.name).push({ tick: p.tick, time: p.game_time, position: pl.position });
                            
                            // Aim Îç∞Ïù¥ÌÑ∞ ÏàòÏßë (Î™®Îì† Ìã±ÏóêÏÑú yaw/pitch)
                            if (pl.yaw !== null && pl.yaw !== undefined && 
                                pl.pitch !== null && pl.pitch !== undefined) {
                                if (!aimIndex.has(pl.name)) aimIndex.set(pl.name, []);
                                aimIndex.get(pl.name).push({ 
                                    yaw: pl.yaw, 
                                    pitch: pl.pitch, 
                                    time: p.game_time, 
                                    tick: p.tick,
                                    type: 'move' 
                                });
                            }
                            }
                        });
                    });
                    
                    // Kill Ïù¥Î≤§Ìä∏Ïùò aim Îç∞Ïù¥ÌÑ∞Î•º move Îç∞Ïù¥ÌÑ∞ÏôÄ Î≥ëÌï© (ÏùºÍ¥Ñ Ï≤òÎ¶¨)
                    aimIndex.forEach((arr, name) => {
                        const kills = arr.filter(a => a.type === 'kill' && a._temp);
                        const moves = arr.filter(a => a.type === 'move');
                        
                        // kill ÌÉÄÏûÖÏùÑ Í∞ôÏùÄ ÏãúÍ∞Ñ/Ìã±Ïùò moveÏóê Î≥ëÌï©
                        kills.forEach(kill => {
                            const existing = moves.find(m => 
                                Math.abs(m.time - kill.time) < 0.01 && m.tick === kill.tick
                            );
                            if (existing) {
                                existing.type = 'kill';
                            }
                        });
                        
                        // ÏûÑÏãú kill Ìï≠Î™© Ï†úÍ±∞ (Î≥ëÌï©Îêú Í≤ÉÎßå ÎÇ®ÍπÄ)
                        arr.splice(0, arr.length, ...moves, ...kills.filter(k => {
                            const exists = moves.some(m => 
                                Math.abs(m.time - k.time) < 0.01 && m.tick === k.tick
                            );
                            return !exists;
                        }));
                    });
                    
                    events.forEach(e => {
                        if (e.event_type_lower && (e.event_type_lower.includes('kill') || e.event_type_lower.includes('died'))) {
                            if (e.attacker && e.attacker.name) {
                                const stats = playerStats.get(e.attacker.name);
                                if (stats) stats.kills++;
                            }
                            if (e.victim && e.victim.name) {
                                const stats = playerStats.get(e.victim.name);
                                if (stats) stats.deaths++;
                            }
                        }
                    });
                    
                    this.data = {
                        metadata: {
                            total_ticks: positions.length,
                            total_events: events.length,
                            time_range: {
                                min: gameTimes.length ? Math.min(...gameTimes) : 0,
                                max: gameTimes.length ? Math.max(...gameTimes) : 0
                            },
                            tick_range: {
                                min: ticks.length ? Math.min(...ticks) : 0,
                                max: ticks.length ? Math.max(...ticks) : 0
                            },
                            players: Array.from(players).sort(),
                            playerStats: Object.fromEntries(playerStats),
                            teams: ['CT', 'TERRORIST']
                        },
                        positions: positions,
                        events: events
                    };
                    this.playerIndex = playerIndex;
                    // aimIndex Ï†ïÎ†¨ (ÏãúÍ∞ÑÏàú)
                    aimIndex.forEach((arr, name) => {
                        arr.sort((a, b) => a.time - b.time);
                    });
                    this.aimIndex = aimIndex;
                    
                    console.log('Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ ÏôÑÎ£å:', this.data.metadata);
                    console.log('Îßµ Í≤ΩÍ≥Ñ:', this.mapBounds);
                    console.log('Positions Ïàò:', positions.length);
                    console.log('Events Ïàò:', events.length);
                    
                    if (positions.length === 0) {
                        console.error('PositionsÍ∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§. Îç∞Ïù¥ÌÑ∞ Ìè¨Îß∑ÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.');
                        alert('Îç∞Ïù¥ÌÑ∞Î•º Ï≤òÎ¶¨Ìï† Ïàò ÏóÜÏäµÎãàÎã§. CSV ÌååÏùº Ìè¨Îß∑ÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.');
                        return;
                    }
                    
                    this.updateUI();
                    this.setupMapBounds();
                    this.populateKillPicker();
                    this.populatePlayerPicker();
                    
                    // ÌååÏùº Î°úÎìú ÌõÑ Investigate ÌÉ≠ÏúºÎ°ú ÏûêÎèô Ï†ÑÌôò
                    this.showInvestigate();
                    
                    // ÏãúÎÆ¨Î†àÏù¥ÏÖò Î†åÎçîÎßÅ Ï¥àÍ∏∞Ìôî
                    setTimeout(() => {
                        this.renderTick(0);
                        // renderer ÌÅ¨Í∏∞ Ïû¨Ï°∞Ï†ï (containerÍ∞Ä Ïà®Í≤®Ï†∏ ÏûàÏùÑ Ïàò ÏûàÏùå)
                        const container = document.getElementById('canvas-container');
                        if (container && this.renderer) {
                            const width = container.clientWidth;
                            const height = container.clientHeight;
                            if (width > 0 && height > 0) {
                                this.camera.aspect = width / height;
                                this.camera.updateProjectionMatrix();
                                this.renderer.setSize(width, height);
                            }
                        }
                    }, 100);
                } catch (error) {
                    console.error('processData Ïò§Î•ò:', error);
                    alert('Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + error.message);
                    const loading = document.getElementById('loading');
                    if (loading) loading.style.display = 'none';
                }
            }

            renderAimTrace() {
                const container = document.getElementById('event-log');
                container.innerHTML = '';
                const canvas = document.createElement('canvas');
                canvas.width = container.clientWidth - 20;
                canvas.height = container.clientHeight - 20;
                canvas.style.background = '#0a0e15';
                canvas.style.border = '1px solid #2a2f3e';
                container.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                const W = canvas.width;
                const H = canvas.height;

                // Focus Î™®ÎìúÍ∞Ä ÏïÑÎãàÎ©¥ Î©îÏãúÏßÄ ÌëúÏãú
                if (!this.focusMode || !this.focusTickRange) {
                    ctx.fillStyle = '#8a8fa5';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Aim TraceÎäî Focus Î™®ÎìúÏóêÏÑúÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.', W/2, H/2);
                    ctx.fillText('ÌÇ¨ Ïù¥Î≤§Ìä∏Î•º ÏÑ†ÌÉùÌïòÏó¨ Focus Î™®ÎìúÎ•º ÌôúÏÑ±ÌôîÌïòÏÑ∏Ïöî.', W/2, H/2 + 30);
                    return;
                }

                // ÏÑ†ÌÉùÎêú ÌîåÎ†àÏù¥Ïñ¥ Ïö∞ÏÑ†ÏàúÏúÑ: Ìè¨Ïª§Ïä§ Î™®ÎìúÏùº ÎïåÎäî Î∞òÎìúÏãú Í≥µÍ≤©Ïûê -> ÏÑ†ÌÉùÎêú ÌîåÎ†àÏù¥Ïñ¥ -> Ï≤´ Î≤àÏß∏
                let name = null;
                if (this.focusMode && this.selectedEvent && this.selectedEvent.attacker && this.selectedEvent.attacker.name) {
                    // Ìè¨Ïª§Ïä§ Î™®ÎìúÏùº ÎïåÎäî Î¨¥Ï°∞Í±¥ Í≥µÍ≤©ÏûêÎ•º ÌëúÏãú
                    name = this.selectedEvent.attacker.name;
                    console.log('Aim Trace - Ìè¨Ïª§Ïä§ Î™®Îìú: Í≥µÍ≤©Ïûê', name, 'Ïùò aim trace ÌëúÏãú');
                } else if (this.selectedEvent && this.selectedEvent.attacker && this.selectedEvent.attacker.name) {
                    name = this.selectedEvent.attacker.name;
                } else {
                    name = this.selectedPlayer || ((this.data && this.data.metadata && this.data.metadata.players && this.data.metadata.players[0]) || null);
                }
                
                // Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ÏóêÏÑú Aim Ï†ïÎ≥¥ ÏàòÏßë
                let samples = [];
                if (name && this.data) {
                    console.log('Aim Trace - ÌîåÎ†àÏù¥Ïñ¥:', name);
                    
                    // Ìè¨Ïª§Ïä§ Î™®ÎìúÏùº ÎïåÎäî Ìã± Ïù∏Îç±Ïä§ Î≤îÏúÑÎ°ú ÏßÅÏ†ë ÏàòÏßë (Î™®Îì† Ìã±, ÎàÑÏ†Å)
                    if (this.focusMode && this.focusTickRange) {
                        console.log('Aim Trace - Ìè¨Ïª§Ïä§ Î™®Îìú: Ìã± Î≤îÏúÑ', this.focusTickRange.startIdx, '-', this.focusTickRange.endIdx, 'Ï¥ù', (this.focusTickRange.endIdx - this.focusTickRange.startIdx + 1), 'Ìã±');
                        let foundCount = 0;
                        let missingCount = 0;
                        let lastYaw = null;
                        let lastPitch = null;
                        
                        // Ï≤´ Î≤àÏß∏ Ïú†Ìö®Ìïú Í∞íÏùÑ Ï∞æÍ∏∞ ÏúÑÌï¥ Ïó≠Î∞©Ìñ•ÏúºÎ°úÎèÑ Í≤ÄÏÉâ
                        for (let idx = this.focusTickRange.startIdx - 1; idx >= 0 && idx >= this.focusTickRange.startIdx - 10; idx--) {
                            const pos = this.data.positions[idx];
                            if (pos) {
                                const player = pos.players.find(p => p.name === name);
                                if (player && player.yaw !== null && player.yaw !== undefined && !Number.isNaN(player.yaw) &&
                                    player.pitch !== null && player.pitch !== undefined && !Number.isNaN(player.pitch)) {
                                    lastYaw = player.yaw;
                                    lastPitch = player.pitch;
                                    break;
                                }
                            }
                        }
                        
                        // Î™®Îì† Ìã±ÏùÑ ÏàúÌöåÌïòÎ©¥ÏÑú Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÎäî Ìã±Îßå ÏàòÏßë (Ï§ëÎ≥µ Ï†úÍ±∞)
                        for (let idx = this.focusTickRange.startIdx; idx <= this.focusTickRange.endIdx; idx++) {
                            const pos = this.data.positions[idx];
                            if (pos) {
                                const player = pos.players.find(p => p.name === name);
                                if (player) {
                                    const yaw = player.yaw;
                                    const pitch = player.pitch;
                                    
                                    // Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÎäî Í≤ΩÏö∞Îßå Ï∂îÍ∞Ä (Î≥¥Í∞Ñ ÏóÜÏù¥)
                                    if (yaw !== null && yaw !== undefined && !Number.isNaN(yaw) &&
                                        pitch !== null && pitch !== undefined && !Number.isNaN(pitch)) {
                                        // Ïù¥Ï†Ñ ÏÉòÌîåÍ≥º Í∞íÏù¥ Îã§Î•º ÎïåÎßå Ï∂îÍ∞Ä (Ï§ëÎ≥µ Ï†úÍ±∞)
                                        if (lastYaw === null || lastPitch === null || 
                                            Math.abs(yaw - lastYaw) > 0.01 || Math.abs(pitch - lastPitch) > 0.01) {
                                            samples.push({
                                                yaw: yaw,
                                                pitch: pitch,
                                                time: pos.game_time,
                                                tick: pos.tick,
                                                tickIdx: idx, // Ìã± Ïù∏Îç±Ïä§ Î™ÖÏãúÏ†Å Ï†ÄÏû•
                                                type: 'move'
                                            });
                                            lastYaw = yaw;
                                            lastPitch = pitch;
                                            foundCount++;
                                        } else {
                                            // Í∞ôÏùÄ Í∞íÏù¥Î©¥ Ïä§ÌÇµ (Ï§ëÎ≥µ Ï†úÍ±∞)
                                            missingCount++;
                                        }
                                    } else {
                                        missingCount++;
                                    }
                                } else {
                                    missingCount++;
                                }
                            }
                        }
                        console.log('Aim Trace - Ìè¨Ïª§Ïä§ Î™®Îìú ÏàòÏßë:', foundCount, 'Í≥†Ïú† ÏÉòÌîå, Ï§ëÎ≥µ/ÏóÜÏùå:', missingCount, '/ Ï†ÑÏ≤¥ Ìã±:', (this.focusTickRange.endIdx - this.focusTickRange.startIdx + 1));
                        console.log('Aim Trace - Ìè¨Ïª§Ïä§ Î™®Îìú Î≤îÏúÑ:', this.focusTickRange.startIdx, '~', this.focusTickRange.endIdx, 'Ìã±');
                    } else {
                        // ÏùºÎ∞ò Î™®Îìú: Ï†ÑÏ≤¥ positionsÏóêÏÑú ÏàòÏßë (Ï§ëÎ≥µ Ï†úÍ±∞ Ìè¨Ìï®)
                        let foundCount = 0;
                        let missingCount = 0;
                        let lastYaw = null;
                        let lastPitch = null;
                        this.data.positions.forEach(pos => {
                            const player = pos.players.find(p => p.name === name);
                            if (player) {
                                // yaw/pitch ÌôïÏù∏ (null Ï≤¥ÌÅ¨ Î∞è Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨)
                                const yaw = player.yaw;
                                const pitch = player.pitch;
                                if (yaw !== null && yaw !== undefined && !Number.isNaN(yaw) &&
                                    pitch !== null && pitch !== undefined && !Number.isNaN(pitch)) {
                                    // Ïù¥Ï†Ñ ÏÉòÌîåÍ≥º Í∞íÏù¥ Îã§Î•º ÎïåÎßå Ï∂îÍ∞Ä (Ï§ëÎ≥µ Ï†úÍ±∞)
                                    if (lastYaw === null || lastPitch === null || 
                                        Math.abs(yaw - lastYaw) > 0.01 || Math.abs(pitch - lastPitch) > 0.01) {
                                        samples.push({
                                            yaw: yaw,
                                            pitch: pitch,
                                            time: pos.game_time,
                                            tick: pos.tick,
                                            type: 'move'
                                        });
                                        lastYaw = yaw;
                                        lastPitch = pitch;
                                        foundCount++;
                                    } else {
                                        missingCount++;
                                    }
                                } else {
                                    missingCount++;
                                }
                            } else {
                                missingCount++;
                            }
                        });
                        console.log('Aim Trace - ÏùºÎ∞ò Î™®Îìú ÏàòÏßë:', foundCount, 'Í≥†Ïú† ÏÉòÌîå, Ï§ëÎ≥µ/ÏóÜÏùå:', missingCount, '/ Ï†ÑÏ≤¥:', this.data.positions.length);
                    }
                    
                    // ÌÇ¨ Ïù¥Î≤§Ìä∏ÏóêÏÑú kill ÌÉÄÏûÖ ÎßàÌÇπ (Ï§ëÎ≥µ Ï†úÍ±∞ Í∞ïÌôî)
                    if (this.aimIndex && this.aimIndex.has(name)) {
                        let killPoints = this.aimIndex.get(name).filter(a => a.type === 'kill');

                        // Ìè¨Ïª§Ïä§ Î™®ÎìúÏóêÏÑúÎäî ÏÑ†ÌÉùÎêú Ïù¥Î≤§Ìä∏Ïùò ÌÇ¨Îßå ÌëúÏãú (Ï§ëÎ≥µ Î∂âÏùÄ Ï†ê Î∞©ÏßÄ)
                        if (this.focusMode && this.selectedEvent && this.selectedEvent.tick !== undefined) {
                            const focusTick = this.selectedEvent.tick;
                            const focusVictim = this.selectedEvent.victim ? this.selectedEvent.victim.name : null;
                            killPoints = killPoints.filter(kp => {
                                if (kp.tick !== focusTick) return false;
                                // victim Ï†ïÎ≥¥Í∞Ä ÏûàÏúºÎ©¥ ÏùºÏπòÌïòÎäî Í≤ΩÏö∞Îßå ÌëúÏãú
                                return focusVictim ? true : true;
                            });
                        }
                        console.log('Aim Trace - Kill Ìè¨Ïù∏Ìä∏ Ïàò (Ï§ëÎ≥µ Ï†úÍ±∞ Ï†Ñ):', killPoints.length);
                        
                        // Ï§ëÎ≥µ Ï†úÍ±∞: Í∞ôÏùÄ tickÏùò ÌÇ¨ÏùÄ ÌïòÎÇòÎßå ÎÇ®ÍπÄ
                        const uniqueKillPoints = [];
                        const seenTicks = new Set();
                        killPoints.forEach(kp => {
                            if (!seenTicks.has(kp.tick)) {
                                seenTicks.add(kp.tick);
                                uniqueKillPoints.push(kp);
                            }
                        });
                        
                        console.log('Aim Trace - Kill Ìè¨Ïù∏Ìä∏ Ïàò (Ï§ëÎ≥µ Ï†úÍ±∞ ÌõÑ):', uniqueKillPoints.length);
                        
                        uniqueKillPoints.forEach(kp => {
                            const existing = samples.find(s => 
                                Math.abs(s.time - kp.time) < 0.01 && s.tick === kp.tick
                            );
                            if (existing) {
                                existing.type = 'kill';
                            } else {
                                samples.push(kp);
                            }
                        });
                    }
                    
                    samples.sort((a, b) => a.time - b.time);
                    console.log('Aim Trace - ÏµúÏ¢Ö ÏÉòÌîå Ïàò:', samples.length);
                    
                    // Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ Í≤ΩÍ≥†
                    if (samples.length === 0) {
                        console.warn('Aim Trace - Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§. ÌîåÎ†àÏù¥Ïñ¥:', name);
                    }
                } else {
                    console.warn('Aim Trace - ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Î¶Ñ ÎòêÎäî Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.');
                }

                // ÌòÑÏû¨ Ïû¨ÏÉù Íµ¨Í∞Ñ - Ìè¨Ïª§Ïä§ Î™®ÎìúÏùº ÎïåÎäî Ìè¨Ïª§Ïä§ Î≤îÏúÑ ÏÇ¨Ïö©
                let tStart, tEnd;
                if (this.focusMode && this.focusTickRange) {
                    // Ìè¨Ïª§Ïä§ Î™®Îìú: ÏÑ†ÌÉùÎêú Ïù¥Î≤§Ìä∏ Ï†ÑÌõÑ ¬±30Ìã± Î≤îÏúÑ
                    tStart = this.data.positions[this.focusTickRange.startIdx].game_time;
                    tEnd = this.data.positions[this.focusTickRange.endIdx].game_time;
                    console.log('Aim Trace - Ìè¨Ïª§Ïä§ Î™®Îìú Î≤îÏúÑ:', tStart.toFixed(2), '-', tEnd.toFixed(2), 'Î≤îÏúÑ:', (tEnd - tStart).toFixed(2), 'Ï¥à');
                } else {
                    const endIdx = this.currentTick;
                    // Îçî ÎÑìÏùÄ Î≤îÏúÑ: ÏµúÍ∑º 300Ìã± ÎòêÎäî 5Ï¥à
                    const startIdx = Math.max(0, endIdx - 300);
                    tStart = (this.data.positions[startIdx] && this.data.positions[startIdx].game_time != null) ? this.data.positions[startIdx].game_time : 0;
                    const currentTime = (this.data.positions[endIdx] && this.data.positions[endIdx].game_time != null) ? this.data.positions[endIdx].game_time : tStart;
                    tEnd = currentTime;
                    // ÏµúÏÜå 5Ï¥à Î≤îÏúÑ Î≥¥Ïû•
                    if (tEnd - tStart < 5) {
                        tStart = Math.max(0, tEnd - 5);
                    }
                }
                const currentTime = (this.data.positions[this.currentTick] && this.data.positions[this.currentTick].game_time != null) ? this.data.positions[this.currentTick].game_time : tStart;
                
                // Ìè¨Ïª§Ïä§ Î™®ÎìúÏùº ÎïåÎäî Ïû¨ÏÉù Ï§ëÏù¥Î©¥ ÌòÑÏû¨ Ìã±ÍπåÏßÄ ÎàÑÏ†Å, ÏïÑÎãàÎ©¥ Ï†ÑÏ≤¥ ÌëúÏãú
                // ÏùºÎ∞ò Î™®ÎìúÏùº ÎïåÎßå ÏãúÍ∞Ñ Î≤îÏúÑÎ°ú ÌïÑÌÑ∞ÎßÅ
                let windowSamples;
                if (this.focusMode && this.focusTickRange) {
                    // Ìè¨Ïª§Ïä§ Î™®Îìú: Ïû¨ÏÉù Ï§ëÏù¥Î©¥ ÌòÑÏû¨ Ìã±ÍπåÏßÄ ÎàÑÏ†Å ÌëúÏãú (Ìã± Ïù∏Îç±Ïä§ Í∏∞Î∞ò)
                    const currentTickIdx = this.currentTick;
                    const startTickIdx = this.focusTickRange.startIdx;
                    
                    // Ìè¨Ïª§Ïä§ Î™®ÎìúÏóêÏÑúÎäî Ìï≠ÏÉÅ Ï†ÑÏ≤¥ ÏÉòÌîå ÌëúÏãú (ÎàÑÏ†Å)
                    // Ïû¨ÏÉù Ï§ëÏù¥Î©¥ ÌòÑÏû¨ Ìã±ÍπåÏßÄÎßå ÌëúÏãúÌïòÎèÑÎ°ù ÏòµÏÖò Ï†úÍ≥µ
                    if (this.isPlaying && currentTickIdx > startTickIdx) {
                        // Ïû¨ÏÉù Ï§ë: ÌòÑÏû¨ Ìã±ÍπåÏßÄÏùò ÏÉòÌîåÎßå ÌëúÏãú (ÏàúÏ∞®Ï†Å ÎàÑÏ†Å)
                        windowSamples = samples.filter(s => {
                            // tickIdxÍ∞Ä ÏûàÏúºÎ©¥ ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ positionsÏóêÏÑú Ï∞æÍ∏∞
                            let sampleTickIdx = s.tickIdx;
                            if (sampleTickIdx === undefined) {
                                sampleTickIdx = this.data.positions.findIndex(p => p.tick === s.tick);
                            }
                            return sampleTickIdx !== -1 && sampleTickIdx <= currentTickIdx && sampleTickIdx >= startTickIdx;
                        });
                        console.log('Aim Trace - Ìè¨Ïª§Ïä§ Î™®Îìú (Ïû¨ÏÉù Ï§ë): Ìã±', startTickIdx, '~', currentTickIdx, 'ÍπåÏßÄ', windowSamples.length, 'ÏÉòÌîå ÎàÑÏ†Å (Ï†ÑÏ≤¥ samples:', samples.length, ')');
                    } else {
                        // Ï†ïÏßÄ ÏÉÅÌÉúÎ©¥ Ï†ÑÏ≤¥ ÌëúÏãú (Î™®Îì† ÏÉòÌîå)
                        windowSamples = samples;
                        console.log('Aim Trace - Ìè¨Ïª§Ïä§ Î™®Îìú (Ï†ïÏßÄ): Ï†ÑÏ≤¥', windowSamples.length, 'ÏÉòÌîå ÌëúÏãú');
                    }
                } else {
                    // ÏùºÎ∞ò Î™®Îìú: ÏãúÍ∞Ñ Î≤îÏúÑÎ°ú ÌïÑÌÑ∞ÎßÅ
                    windowSamples = samples.filter(s => s.time >= tStart && s.time <= tEnd);
                }
                
                console.log('Aim Trace - ÏúàÎèÑÏö∞ ÏÉòÌîå Ïàò:', windowSamples.length, 'ÏãúÍ∞Ñ Î≤îÏúÑ:', tStart.toFixed(2), '-', tEnd.toFixed(2), 'Î≤îÏúÑ:', (tEnd - tStart).toFixed(2), 'Ï¥à');
                console.log('Aim Trace - ÏÉòÌîå yaw Î≤îÏúÑ:', windowSamples.length > 0 ? [Math.min(...windowSamples.map(s => s.yaw)).toFixed(2), Math.max(...windowSamples.map(s => s.yaw)).toFixed(2)] : 'ÏóÜÏùå');
                console.log('Aim Trace - ÏÉòÌîå pitch Î≤îÏúÑ:', windowSamples.length > 0 ? [Math.min(...windowSamples.map(s => s.pitch)).toFixed(2), Math.max(...windowSamples.map(s => s.pitch)).toFixed(2)] : 'ÏóÜÏùå');
                
                // Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ Î©îÏãúÏßÄ ÌëúÏãú
                if (samples.length === 0) {
                    ctx.fillStyle = '#8a8fa5';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('No aim data available for ' + (name || 'selected player'), W/2, H/2);
                    ctx.textAlign = 'left';
                    return;
                }
                
                if (windowSamples.length === 0) {
                    ctx.fillStyle = '#8a8fa5';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('No data in current time window', W/2, H/2);
                    ctx.textAlign = 'left';
                    return;
                }

                // Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ Î≤îÏúÑ Í≥ÑÏÇ∞ (ÎèôÏ†Å Ïä§ÏºÄÏùºÎßÅ)
                const yaws = windowSamples.map(s => s.yaw).filter(v => !Number.isNaN(v));
                const pitches = windowSamples.map(s => s.pitch).filter(v => !Number.isNaN(v));
                
                let xMin, xMax, yMin, yMax;
                if (yaws.length > 0 && pitches.length > 0) {
                    const yawMin = Math.min(...yaws);
                    const yawMax = Math.max(...yaws);
                    const pitchMin = Math.min(...pitches);
                    const pitchMax = Math.max(...pitches);
                    
                    const yawRange = yawMax - yawMin;
                    const pitchRange = pitchMax - pitchMin;
                    
                    // Î≤îÏúÑÍ∞Ä Îß§Ïö∞ Ï¢ÅÏúºÎ©¥ (10ÎèÑ Ïù¥Ìïò) ÌôïÎåÄ, ÏïÑÎãàÎ©¥ Ï†ÑÏ≤¥ Î≤îÏúÑ ÏÇ¨Ïö©
                    if (yawRange < 10 && pitchRange < 10) {
                        // ÌôïÎåÄ: Ï§ëÏïô Í∏∞Ï§ÄÏúºÎ°ú ¬±20ÎèÑ Î≤îÏúÑ
                        const yawCenter = (yawMin + yawMax) / 2;
                        const pitchCenter = (pitchMin + pitchMax) / 2;
                        xMin = yawCenter - 20;
                        xMax = yawCenter + 20;
                        yMin = pitchCenter - 20;
                        yMax = pitchCenter + 20;
                        console.log('Aim Trace - ÌôïÎåÄ Î™®Îìú:', {yawCenter, pitchCenter, range: '¬±20¬∞'});
                    } else {
                        // Ïó¨Î∞± Ï∂îÍ∞Ä (10% padding)
                        const yawPadding = Math.max(yawRange * 0.1, 5);
                        const pitchPadding = Math.max(pitchRange * 0.1, 5);
                        xMin = yawMin - yawPadding;
                        xMax = yawMax + yawPadding;
                        yMin = pitchMin - pitchPadding;
                        yMax = pitchMax + pitchPadding;
                        console.log('Aim Trace - ÎèôÏ†Å Î≤îÏúÑ:', {yaw: [xMin, xMax], pitch: [yMin, yMax]});
                    }
                } else {
                    // Í∏∞Î≥∏ Î≤îÏúÑ
                    xMin = -180; xMax = 180; yMin = -90; yMax = 90;
                }
                
                console.log('Aim Trace - Ï¢åÌëú Î≤îÏúÑ:', {yaw: [xMin.toFixed(1), xMax.toFixed(1)], pitch: [yMin.toFixed(1), yMax.toFixed(1)]});
                
                const pad = 40;
                
                function xScale(v){ return pad + (v - xMin) / (xMax - xMin) * (W - 2*pad); }
                function yScale(v){ return H - (pad + (v - yMin) / (yMax - yMin) * (H - 2*pad)); }

                // Î∞∞Í≤Ω Í∑∏Î¶¨Îìú (ÎèôÏ†Å Î≤îÏúÑÏóê ÎßûÏ∂∞)
                ctx.strokeStyle = '#2a2f3e'; ctx.lineWidth = 1;
                const gridStepX = Math.max(1, Math.ceil((xMax - xMin) / 20)); // ÏïΩ 20Í∞ú Í∑∏Î¶¨Îìú
                const gridStepY = Math.max(1, Math.ceil((yMax - yMin) / 15)); // ÏïΩ 15Í∞ú Í∑∏Î¶¨Îìú
                
                for (let x = Math.floor(xMin / gridStepX) * gridStepX; x <= xMax; x += gridStepX) {
                    const sx = xScale(x);
                    if (sx >= pad && sx <= W - pad) {
                        ctx.beginPath(); ctx.moveTo(sx, pad); ctx.lineTo(sx, H - pad); ctx.stroke();
                    }
                }
                for (let y = Math.floor(yMin / gridStepY) * gridStepY; y <= yMax; y += gridStepY) {
                    const sy = yScale(y);
                    if (sy >= pad && sy <= H - pad) {
                        ctx.beginPath(); ctx.moveTo(pad, sy); ctx.lineTo(W - pad, sy); ctx.stroke();
                    }
                }
                
                // Ï∂ï ÎùºÎ≤® (Î≤îÏúÑ ÌëúÏãú)
                ctx.fillStyle = '#8a8fa5'; ctx.font = '12px Arial';
                ctx.fillText(`Yaw (¬∞) [${xMin.toFixed(1)} ~ ${xMax.toFixed(1)}]`, W/2 - 80, H-10);
                ctx.save(); ctx.translate(10, H/2); ctx.rotate(-Math.PI/2); 
                ctx.fillText(`Pitch (¬∞) [${yMin.toFixed(1)} ~ ${yMax.toFixed(1)}]`, 0, 0); ctx.restore();

                // Î™®Îì† Ìè¨Ïù∏Ìä∏ ÌëúÏãú (ÎàÑÏ†Å Ïù¥Îèô Í≤ΩÎ°ú) - Í≥†Ïú†Ìïú Í∞íÎßå ÌëúÏãú
                console.log('Aim Trace - Î†åÎçîÎßÅÌï† Ìè¨Ïù∏Ìä∏ Ïàò:', windowSamples.length);
                
                // Ï§ëÎ≥µ Ï†úÍ±∞: Ïó∞ÏÜçÎêú Í∞ôÏùÄ Í∞í Ï†úÍ±∞ (Î®ºÏ†Ä ÏÉùÏÑ±)
                const uniqueSamples = [];
                let lastRenderedYaw = null;
                let lastRenderedPitch = null;
                
                windowSamples.forEach((s, idx) => {
                    // Í∞íÏù¥ Î≥ÄÍ≤ΩÎêòÏóàÍ±∞ÎÇò Ï≤´ Î≤àÏß∏ ÏÉòÌîåÏù¥Î©¥ Ï∂îÍ∞Ä
                    if (lastRenderedYaw === null || lastRenderedPitch === null ||
                        Math.abs(s.yaw - lastRenderedYaw) > 0.01 || Math.abs(s.pitch - lastRenderedPitch) > 0.01) {
                        uniqueSamples.push(s);
                        lastRenderedYaw = s.yaw;
                        lastRenderedPitch = s.pitch;
                    }
                });
                
                console.log('Aim Trace - Ï§ëÎ≥µ Ï†úÍ±∞ ÌõÑ Í≥†Ïú† Ìè¨Ïù∏Ìä∏ Ïàò:', uniqueSamples.length, '/', windowSamples.length);

                // Í≤ΩÎ°ú Ïó∞Í≤∞ÏÑ† (Í∏∞Î≥∏ ÌöåÏÉâ) - Í≥†Ïú† Ìè¨Ïù∏Ìä∏Îßå Ïó∞Í≤∞
                if (uniqueSamples.length > 1){
                    ctx.beginPath();
                    ctx.strokeStyle = '#5a637a'; ctx.lineWidth = 1.5;
                    let firstPoint = true;
                    for (let i = 0; i < uniqueSamples.length; i++) {
                        const s = uniqueSamples[i];
                        const x = xScale(s.yaw);
                        const y = yScale(s.pitch);
                        if (firstPoint) {
                            ctx.moveTo(x, y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                }
                
                // Ìè¨Ïù∏Ìä∏ Î†åÎçîÎßÅ
                if (uniqueSamples.length === 0) {
                    console.warn('Aim Trace - Î†åÎçîÎßÅÌï† Í≥†Ïú† Ìè¨Ïù∏Ìä∏Í∞Ä ÏóÜÏäµÎãàÎã§. windowSamples:', windowSamples.length);
                } else {
                    console.log('Aim Trace - Î†åÎçîÎßÅ ÏãúÏûë: Í≥†Ïú† Ìè¨Ïù∏Ìä∏', uniqueSamples.length, 'Í∞ú');
                }
                
                uniqueSamples.forEach((s, idx) => {
                    const x = xScale(s.yaw);
                    const y = yScale(s.pitch);
                    
                    // Ï∫îÎ≤ÑÏä§ Î≤îÏúÑ Ï≤¥ÌÅ¨
                    if (x < 0 || x > W || y < 0 || y > H) {
                        if (idx < 3) {
                            console.warn(`Ìè¨Ïù∏Ìä∏ ${idx}Í∞Ä Ï∫îÎ≤ÑÏä§ Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇ®: canvas(${x.toFixed(1)}, ${y.toFixed(1)})`);
                        }
                        return; // Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇú Ìè¨Ïù∏Ìä∏Îäî Ïä§ÌÇµ
                    }
                    
                    // ÎîîÎ≤ÑÍπÖ: Ï≤òÏùå 3Í∞úÏôÄ ÎßàÏßÄÎßâ 3Í∞ú Ìè¨Ïù∏Ìä∏Îßå Î°úÍ∑∏
                    if (idx < 3 || idx >= uniqueSamples.length - 3) {
                        console.log(`Í≥†Ïú† Ìè¨Ïù∏Ìä∏ ${idx}/${uniqueSamples.length}: yaw=${s.yaw.toFixed(2)}, pitch=${s.pitch.toFixed(2)}, canvas(${x.toFixed(1)}, ${y.toFixed(1)})`);
                    }
                    
                    if (s.type === 'kill') {
                        // Kill ÏãúÏ†ê: ÏßÑÎπ®Í∞ï ÌÅ∞ Ïõê + ÌÖåÎëêÎ¶¨
                        ctx.fillStyle = '#cc0000';
                        ctx.beginPath(); ctx.arc(x, y, 5, 0, Math.PI*2); ctx.fill();
                        ctx.strokeStyle = '#ff3333'; ctx.lineWidth = 2; ctx.stroke();
                    } else {
                        // ÏùºÎ∞ò Ïù¥Îèô Ìè¨Ïù∏Ìä∏: ÏûëÏùÄ ÌöåÏÉâ Ï†ê (Î™®Îëê ÌëúÏãú)
                        ctx.fillStyle = '#8a8fa5';
                        ctx.beginPath(); ctx.arc(x, y, 2, 0, Math.PI*2); ctx.fill();
                    }
                });

                // ÌòÑÏû¨ Ìã±Ïùò ÎßàÏö∞Ïä§ ÏúÑÏπò ÌïòÏù¥ÎùºÏù¥Ìä∏ (ÌååÎûë ÌÅ∞ Ï†ê) - Í≥†Ïú† ÏÉòÌîåÏóêÏÑú Ï∞æÍ∏∞
                const curr = uniqueSamples.reduce((prev, s) => {
                    const prevDiff = prev ? Math.abs(s.time - currentTime) : Infinity;
                    const currDiff = Math.abs(s.time - currentTime);
                    return currDiff < prevDiff ? s : prev;
                }, null);
                if (curr) {
                    const cx = xScale(curr.yaw), cy = yScale(curr.pitch);
                    ctx.fillStyle = '#4a90e2';
                    ctx.beginPath(); ctx.arc(cx, cy, 6, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 2; ctx.stroke();
                }

                // Î≤îÎ°Ä
                const legend = [
                    {label:'Current', color:'#4a90e2'},
                    {label:'Kill', color:'#cc0000'}
                ];
                let lx = pad, ly = pad-12;
                legend.forEach(l =>{
                    ctx.fillStyle = l.color; ctx.beginPath(); ctx.arc(lx,ly,4,0,Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#8a8fa5'; ctx.fillText(l.label, lx+10, ly+4);
                    lx += 80;
                });

                // Ï†úÎ™©
                ctx.fillStyle = '#ffffff'; ctx.font = '14px Arial';
                ctx.fillText(`Aim Trace - ${name || 'N/A'}`, pad, 20);
            }

            generateReport(playerName) {
                if (!this.data || !playerName) return;
                
                const stats = this.data.metadata.playerStats[playerName] || { kills: 0, deaths: 0, team: '' };
                // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä ÌÇ¨Ìïú Ïù¥Î≤§Ìä∏Îßå ÌïÑÌÑ∞ÎßÅ (Ï§ëÎ≥µ Ï†úÍ±∞)
                let playerKills = this.data.events.filter(e => 
                    e.attacker && e.attacker.name === playerName &&
                    e.event_type_lower && e.event_type_lower.includes('kill')
                );
                
                // Í∞ôÏùÄ tickÏùò Ï§ëÎ≥µ ÌÇ¨ Ï†úÍ±∞
                const seenTicks = new Set();
                playerKills = playerKills.filter(e => {
                    if (seenTicks.has(e.tick)) {
                        return false;
                    }
                    seenTicks.add(e.tick);
                    return true;
                });
                
                console.log('Generate Report - ÌîåÎ†àÏù¥Ïñ¥ ÌÇ¨ Ïàò (Ï§ëÎ≥µ Ï†úÍ±∞ ÌõÑ):', playerKills.length);
                
                // Í∞Å ÌÇ¨ Ïù¥Î≤§Ìä∏Î≥ÑÎ°ú Aim Trace ÏÉùÏÑ± (¬±30Ìã± Î≤îÏúÑ)
                const killTraceImages = [];
                
                playerKills.forEach((killEvent, killIdx) => {
                    // ÌÇ¨ Ïù¥Î≤§Ìä∏Ïùò Ìã± Ïù∏Îç±Ïä§ Ï∞æÍ∏∞
                    const killTickIdx = this.data.positions.findIndex(p => p.tick === killEvent.tick);
                    if (killTickIdx === -1) return;
                    
                    // ¬±30Ìã± Î≤îÏúÑ Í≥ÑÏÇ∞
                    const startIdx = Math.max(0, killTickIdx - 30);
                    const endIdx = Math.min(this.data.positions.length - 1, killTickIdx + 30);
                    
                    // Ìï¥Îãπ Î≤îÏúÑÏùò Aim Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
                    const killAimData = [];
                    for (let idx = startIdx; idx <= endIdx; idx++) {
                        const pos = this.data.positions[idx];
                        if (pos) {
                            const player = pos.players.find(p => p.name === playerName);
                            if (player && player.yaw !== null && player.yaw !== undefined && !Number.isNaN(player.yaw) &&
                                player.pitch !== null && player.pitch !== undefined && !Number.isNaN(player.pitch)) {
                                killAimData.push({
                                    yaw: player.yaw,
                                    pitch: player.pitch,
                                    time: pos.game_time,
                                    tick: pos.tick,
                                    tickIdx: idx,
                                    type: idx === killTickIdx ? 'kill' : 'move'
                                });
                            }
                        }
                    }
                    
                    if (killAimData.length === 0) return;
                    
                    // Ï§ëÎ≥µ Ï†úÍ±∞ (Ïó∞ÏÜçÎêú Í∞ôÏùÄ Í∞í)
                    const uniqueKillAimData = [];
                    let lastYaw = null;
                    let lastPitch = null;
                    killAimData.forEach(s => {
                        if (lastYaw === null || lastPitch === null ||
                            Math.abs(s.yaw - lastYaw) > 0.01 || Math.abs(s.pitch - lastPitch) > 0.01) {
                            uniqueKillAimData.push(s);
                            lastYaw = s.yaw;
                            lastPitch = s.pitch;
                        }
                    });
                    
                    // Aim Trace Ï∫îÎ≤ÑÏä§ ÏÉùÏÑ±
                    const killTraceCanvas = document.createElement('canvas');
                    killTraceCanvas.width = 800;
                    killTraceCanvas.height = 600;
                    const killCtx = killTraceCanvas.getContext('2d');
                    
                    // ÎèôÏ†Å Î≤îÏúÑ Í≥ÑÏÇ∞
                    const yaws = uniqueKillAimData.map(s => s.yaw);
                    const pitches = uniqueKillAimData.map(s => s.pitch);
                    let xMin = Math.min(...yaws);
                    let xMax = Math.max(...yaws);
                    let yMin = Math.min(...pitches);
                    let yMax = Math.max(...pitches);
                    
                    // Î≤îÏúÑÍ∞Ä ÎÑàÎ¨¥ Ï¢ÅÏúºÎ©¥ ÌôïÎåÄ
                    const xRange = xMax - xMin;
                    const yRange = yMax - yMin;
                    if (xRange < 10) {
                        const center = (xMin + xMax) / 2;
                        xMin = center - 10;
                        xMax = center + 10;
                    }
                    if (yRange < 10) {
                        const center = (yMin + yMax) / 2;
                        yMin = center - 10;
                        yMax = center + 10;
                    }
                    
                    // Ìå®Îî© Ï∂îÍ∞Ä
                    const xPadding = (xMax - xMin) * 0.1;
                    const yPadding = (yMax - yMin) * 0.1;
                    xMin -= xPadding;
                    xMax += xPadding;
                    yMin -= yPadding;
                    yMax += yPadding;
                    
                    const pad = 40;
                    const W = killTraceCanvas.width, H = killTraceCanvas.height;
                    
                    function xScale(v){ return pad + (v - xMin) / (xMax - xMin) * (W - 2*pad); }
                    function yScale(v){ return H - (pad + (v - yMin) / (yMax - yMin) * (H - 2*pad)); }
                    
                    // Î∞∞Í≤Ω
                    killCtx.fillStyle = '#0a0e15';
                    killCtx.fillRect(0, 0, W, H);
                    
                    // Í∑∏Î¶¨Îìú
                    killCtx.strokeStyle = '#2a2f3e';
                    killCtx.lineWidth = 1;
                    const xStep = Math.max(10, Math.ceil((xMax - xMin) / 10));
                    const yStep = Math.max(5, Math.ceil((yMax - yMin) / 10));
                    for (let x = Math.floor(xMin / xStep) * xStep; x <= xMax; x += xStep) {
                        const sx = xScale(x);
                        if (sx >= pad && sx <= W - pad) {
                            killCtx.beginPath();
                            killCtx.moveTo(sx, pad);
                            killCtx.lineTo(sx, H - pad);
                            killCtx.stroke();
                        }
                    }
                    for (let y = Math.floor(yMin / yStep) * yStep; y <= yMax; y += yStep) {
                        const sy = yScale(y);
                        if (sy >= pad && sy <= H - pad) {
                            killCtx.beginPath();
                            killCtx.moveTo(pad, sy);
                            killCtx.lineTo(W - pad, sy);
                            killCtx.stroke();
                        }
                    }
                    
                    // Í≤ΩÎ°ú Ïó∞Í≤∞ÏÑ†
                    if (uniqueKillAimData.length > 1) {
                        killCtx.beginPath();
                        killCtx.strokeStyle = '#5a637a';
                        killCtx.lineWidth = 1.5;
                        killCtx.moveTo(xScale(uniqueKillAimData[0].yaw), yScale(uniqueKillAimData[0].pitch));
                        for (let i = 1; i < uniqueKillAimData.length; i++) {
                            killCtx.lineTo(xScale(uniqueKillAimData[i].yaw), yScale(uniqueKillAimData[i].pitch));
                        }
                        killCtx.stroke();
                    }
                    
                    // Ìè¨Ïù∏Ìä∏
                    uniqueKillAimData.forEach(s => {
                        const x = xScale(s.yaw), y = yScale(s.pitch);
                        if (s.type === 'kill') {
                            // Kill ÏãúÏ†ê: ÏßÑÎπ®Í∞ï ÌÅ∞ Ïõê + ÌÖåÎëêÎ¶¨
                            killCtx.fillStyle = '#cc0000';
                            killCtx.beginPath();
                            killCtx.arc(x, y, 5, 0, Math.PI*2);
                            killCtx.fill();
                            killCtx.strokeStyle = '#ff3333';
                            killCtx.lineWidth = 2;
                            killCtx.stroke();
                        } else {
                            // ÏùºÎ∞ò Ïù¥Îèô Ìè¨Ïù∏Ìä∏: ÏûëÏùÄ ÌöåÏÉâ Ï†ê
                            killCtx.fillStyle = '#8a8fa5';
                            killCtx.beginPath();
                            killCtx.arc(x, y, 2, 0, Math.PI*2);
                            killCtx.fill();
                        }
                    });
                    
                    // Ï†úÎ™© Î∞è Ï†ïÎ≥¥
                    killCtx.fillStyle = '#ffffff';
                    killCtx.font = 'bold 16px Arial';
                    killCtx.fillText(`Kill #${killIdx + 1} - ${killEvent.victim ? killEvent.victim.name : 'Unknown'}`, pad, 25);
                    killCtx.font = '12px Arial';
                    killCtx.fillStyle = '#8a8fa5';
                    const timeStr = killEvent.game_time ? `${Math.floor(killEvent.game_time / 60)}:${(killEvent.game_time % 60).toFixed(2)}` : 'N/A';
                    killCtx.fillText(`Time: ${timeStr} | Tick: ${killEvent.tick}`, pad, 45);
                    killCtx.fillText(`Yaw: [${xMin.toFixed(1)} ~ ${xMax.toFixed(1)}] Pitch: [${yMin.toFixed(1)} ~ ${yMax.toFixed(1)}]`, pad, H - 15);
                    
                    killTraceImages.push({
                        image: killTraceCanvas.toDataURL('image/png'),
                        killNum: killIdx + 1,
                        victim: killEvent.victim ? killEvent.victim.name : 'Unknown',
                        time: timeStr
                    });
                });
                
                // Î™®Îì† ÌÇ¨ Ìä∏Î†àÏù¥Ïä§Î•º ÌïòÎÇòÏùò Ïù¥ÎØ∏ÏßÄÎ°ú Ìï©ÏπòÍ∏∞ (ÏÑ∏Î°úÎ°ú Î∞∞Ïπò) - ÎπÑÎèôÍ∏∞ Ï≤òÎ¶¨
                const generateCombinedImage = () => {
                    return new Promise((resolve) => {
                        if (killTraceImages.length === 0) {
                            resolve('');
                            return;
                        }
                        
                        const combinedCanvas = document.createElement('canvas');
                        const traceHeight = 600;
                        const traceSpacing = 20;
                        combinedCanvas.width = 800;
                        combinedCanvas.height = killTraceImages.length * (traceHeight + traceSpacing) - traceSpacing;
                        const combinedCtx = combinedCanvas.getContext('2d');
                        
                        combinedCtx.fillStyle = '#1a1f2e';
                        combinedCtx.fillRect(0, 0, combinedCanvas.width, combinedCanvas.height);
                        
                        let loadedCount = 0;
                        killTraceImages.forEach((trace, idx) => {
                            const img = new Image();
                            img.onload = () => {
                                const y = idx * (traceHeight + traceSpacing);
                                combinedCtx.drawImage(img, 0, y);
                                loadedCount++;
                                if (loadedCount === killTraceImages.length) {
                                    resolve(combinedCanvas.toDataURL('image/png'));
                                }
                            };
                            img.onerror = () => {
                                loadedCount++;
                                if (loadedCount === killTraceImages.length) {
                                    resolve(combinedCanvas.toDataURL('image/png'));
                                }
                            };
                            img.src = trace.image;
                        });
                    });
                };
                
                // Î≥¥Í≥†ÏÑú ÏÉùÏÑ± (Ïù¥ÎØ∏ÏßÄ Î°úÎî© ÎåÄÍ∏∞)
                generateCombinedImage().then(combinedAimTraceImage => {
                
                    // Î≥¥Í≥†ÏÑú HTML ÏÉùÏÑ±
                    const reportHTML = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Player Report - ${playerName}</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #1a1f2e; color: #fff; }
        .header { border-bottom: 2px solid #4a90e2; padding-bottom: 10px; margin-bottom: 20px; }
        .section { margin: 20px 0; padding: 15px; background: #2a2f3e; border-radius: 8px; }
        .stat-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; }
        .stat-item { padding: 10px; background: #1a1f2e; border-radius: 4px; }
        .stat-label { color: #8a8fa5; font-size: 12px; }
        .stat-value { color: #fff; font-size: 18px; font-weight: bold; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #3a3f4e; }
        th { background: #1a1f2e; color: #4a90e2; }
    </style>
</head>
<body>
    <button id="download-btn" style="position:fixed; top:16px; right:16px; background:#4a90e2; color:#fff; border:none; padding:8px 12px; border-radius:4px; cursor:pointer; box-shadow:0 2px 6px rgba(0,0,0,0.3);">Download</button>
    <div class="header">
        <h1>Player Analysis Report</h1>
        <h2>${playerName}</h2>
        <p>Generated: ${new Date().toLocaleString()}</p>
    </div>
    
    <div class="section">
        <h3>Match Statistics</h3>
        <div class="stat-grid">
            <div class="stat-item">
                <div class="stat-label">Team</div>
                <div class="stat-value">${stats.team || 'N/A'}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Kills</div>
                <div class="stat-value">${stats.kills}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Deaths</div>
                <div class="stat-value">${stats.deaths}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">K/D Ratio</div>
                <div class="stat-value">${stats.deaths > 0 ? (stats.kills / stats.deaths).toFixed(2) : stats.kills.toFixed(2)}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Total Kills</div>
                <div class="stat-value">${playerKills.length}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Kill Traces</div>
                <div class="stat-value">${killTraceImages.length}</div>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Kill Events</h3>
        <table>
            <tr><th>Time</th><th>Event</th><th>Victim</th><th>Weapon</th><th>Headshot</th></tr>
            ${playerKills.slice(0, 20).map(e => `
                <tr>
                    <td>${this.formatTime(e.game_time)}</td>
                    <td>${e.attacker.name === playerName ? 'KILLED' : 'DIED'}</td>
                    <td>${e.attacker.name === playerName ? e.victim.name : e.attacker.name}</td>
                    <td>${e.weapon || 'N/A'}</td>
                    <td>${e.headshot ? 'Yes' : 'No'}</td>
                </tr>
            `).join('')}
        </table>
    </div>
    
    <div class="section">
        <h3>Aim Movement Analysis - Kill Events</h3>
        <p>Total Kills: ${playerKills.length}</p>
        <p>Kill Traces Generated: ${killTraceImages.length}</p>
        ${killTraceImages.length > 0 ? `
            <div style="margin-top: 15px;">
                <h4>Individual Kill Aim Traces (¬±30 ticks around each kill)</h4>
                ${killTraceImages.map(trace => `
                    <div style="margin-bottom: 30px; padding: 15px; background: #1a1f2e; border-radius: 4px;">
                        <h5 style="color: #4a90e2; margin-bottom: 10px;">Kill #${trace.killNum} - ${trace.victim} (Time: ${trace.time})</h5>
                        <img src="${trace.image}" style="max-width: 100%; border: 1px solid #3a3f4e; border-radius: 4px;" />
                    </div>
                `).join('')}
                
            </div>
        ` : '<p>No kill events with aim data available</p>'}
    </div>
</body>
<script>
    (function(){
        const btn = document.getElementById('download-btn');
        if (btn) {
            btn.addEventListener('click', function(){
                const html = document.documentElement.outerHTML;
                const blob = new Blob([html], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const filename = 'report_' + '${playerName}' + '_' + Date.now() + '.html';
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            });
        }
    })();
<\/script>
</html>
                `;
                    
                    // ÏÉà Ï∞ΩÏúºÎ°ú Ïó¥Í∏∞
                    const win = window.open('', '_blank');
                    win.document.write(reportHTML);
                    win.document.close();
                    
                    // Îã§Ïö¥Î°úÎìúÎäî Î¶¨Ìè¨Ìä∏ Ïö∞Ï∏° ÏÉÅÎã® Î≤ÑÌäºÏùÑ ÌÜµÌï¥ ÏàòÌñâ
                });
            }

            setupMapBounds() {
                if (!this.mapBounds) return;
                
                // Îßµ Í≤ΩÍ≥Ñ Î∞ïÏä§ ÌëúÏãú
                const bounds = this.mapBounds;
                const width = bounds.width;
                const height = bounds.depth;
                const depth = bounds.height;
                
                const geometry = new THREE.BoxGeometry(width, depth, height);
                const edges = new THREE.EdgesGeometry(geometry);
                const line = new THREE.LineSegments(
                    edges,
                    new THREE.LineBasicMaterial({ color: 0x4a90e2, opacity: 0.3, transparent: true })
                );
                line.position.set(bounds.centerX, bounds.centerZ, bounds.centerY);
                this.scene.add(line);
                
                // Ïπ¥Î©îÎùº ÏúÑÏπò Ï°∞Ï†ï Î∞è Í∏∞Î≥∏ Í±∞Î¶¨ ÏÑ§Ï†ï
                const maxDim = Math.max(width, height, depth);
                this.baseCameraDistance = maxDim * 1.2;
                this.cameraDistance = this.baseCameraDistance;
                this.camera.position.set(
                    bounds.centerX,
                    bounds.centerZ + maxDim * 0.8,
                    bounds.centerY + maxDim * 1.2
                );
                this.camera.lookAt(bounds.centerX, bounds.centerZ, bounds.centerY);
                
                // Í∑∏Î¶¨Îìú Ï°∞Ï†ï (Îçî Î™ÖÌôïÌïòÍ≤å)
                const gridSize = Math.max(width, height) * 1.2;
                const gridDivisions = Math.ceil(gridSize / 100); // 100 Îã®ÏúÑÎ°ú Íµ¨Î∂Ñ
                const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x4a90e2, 0x2a3f5a);
                gridHelper.position.set(bounds.centerX, 0, bounds.centerY);
                this.scene.add(gridHelper);
                
                // Íµ¨Ïó≠ ÌëúÏãúÎ•º ÏúÑÌïú ÏÑ† Ï∂îÍ∞Ä (10x10 Íµ¨Ïó≠)
                const sectorSize = Math.max(width, height) / 10;
                const sectorsHelper = new THREE.Group();
                
                // XÏ∂ï ÏÑ†
                for (let i = 0; i <= 10; i++) {
                    const x = bounds.minX + (width / 10) * i;
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(x, bounds.centerZ, bounds.minY),
                        new THREE.Vector3(x, bounds.centerZ, bounds.maxY)
                    ]);
                    const lineMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x3a4f6a, 
                        opacity: 0.3, 
                        transparent: true 
                    });
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    sectorsHelper.add(line);
                }
                
                // YÏ∂ï ÏÑ†
                for (let i = 0; i <= 10; i++) {
                    const y = bounds.minY + (height / 10) * i;
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(bounds.minX, bounds.centerZ, y),
                        new THREE.Vector3(bounds.maxX, bounds.centerZ, y)
                    ]);
                    const lineMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x3a4f6a, 
                        opacity: 0.3, 
                        transparent: true 
                    });
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    sectorsHelper.add(line);
                }
                
                this.scene.add(sectorsHelper);
                
                // Ï¢åÌëúÏ∂ï ÌëúÏãú (ÏõêÏ†ê Î∞è Ï£ºÏöî Íµ¨Ïó≠)
                const axesHelper = new THREE.AxesHelper(Math.max(width, height) * 0.1);
                axesHelper.position.set(bounds.centerX, bounds.centerZ, bounds.centerY);
                this.scene.add(axesHelper);
                
                // Íµ¨Ïó≠ ÎùºÎ≤® Ï∂îÍ∞Ä (Ï£ºÏöî Ìè¨Ïù∏Ìä∏)
                const labelPoints = [
                    { x: bounds.minX, y: bounds.minY, label: 'A1' },
                    { x: bounds.centerX, y: bounds.minY, label: 'B1' },
                    { x: bounds.maxX, y: bounds.minY, label: 'C1' },
                    { x: bounds.minX, y: bounds.centerY, label: 'A2' },
                    { x: bounds.centerX, y: bounds.centerY, label: 'Center' },
                    { x: bounds.maxX, y: bounds.centerY, label: 'C2' },
                    { x: bounds.minX, y: bounds.maxY, label: 'A3' },
                    { x: bounds.centerX, y: bounds.maxY, label: 'B3' },
                    { x: bounds.maxX, y: bounds.maxY, label: 'C3' }
                ];
                
                labelPoints.forEach(point => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 128;
                    canvas.height = 32;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#8a8fa5';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(point.label, canvas.width / 2, canvas.height / 2 + 4);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                        map: texture, 
                        transparent: true 
                    }));
                    sprite.position.set(point.x, bounds.centerZ + 5, point.y);
                    sprite.scale.set(40, 10, 1);
                    this.scene.add(sprite);
                });
                
                // UI ÏóÖÎç∞Ïù¥Ìä∏
                document.getElementById('map-bounds').textContent = 
                    `X: ${bounds.minX.toFixed(0)} ~ ${bounds.maxX.toFixed(0)}\n` +
                    `Y: ${bounds.minY.toFixed(0)} ~ ${bounds.maxY.toFixed(0)}\n` +
                    `Z: ${bounds.minZ.toFixed(0)} ~ ${bounds.maxZ.toFixed(0)}\n` +
                    `Size: ${width.toFixed(0)} √ó ${height.toFixed(0)} √ó ${depth.toFixed(0)}`;
            }

            setupScene() {
                const container = document.getElementById('canvas-container');
                const width = container.clientWidth;
                const height = container.clientHeight;

                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0e15);
                this.scene.fog = new THREE.Fog(0x0a0e15, 1000, 5000);

                this.camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 10000);
                this.camera.position.set(0, 500, 1000);
                this.camera.lookAt(0, 0, 0);

                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('canvas'),
                    antialias: true 
                });
                this.renderer.setSize(width, height);
                this.renderer.shadowMap.enabled = true;

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
                directionalLight.position.set(500, 1000, 500);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);

                window.addEventListener('resize', () => {
                    const width = container.clientWidth;
                    const height = container.clientHeight;
                    this.camera.aspect = width / height;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(width, height);
                });
            }

            setupControls() {
                let isMouseDown = false;
                let mouseX = 0, mouseY = 0;

                const canvas = document.getElementById('canvas');
                
                canvas.addEventListener('mousedown', (e) => {
                    isMouseDown = true;
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });

                canvas.addEventListener('mousemove', (e) => {
                    if (isMouseDown) {
                        const deltaX = e.clientX - mouseX;
                        const deltaY = e.clientY - mouseY;
                        this.cameraRotationY += deltaX * 0.01;
                        this.cameraRotationX += deltaY * 0.01;
                        this.cameraRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.cameraRotationX));
                        mouseX = e.clientX;
                        mouseY = e.clientY;
                    }
                });

                canvas.addEventListener('mouseup', () => {
                    isMouseDown = false;
                });

                canvas.addEventListener('wheel', (e) => {
                    const speed = e.shiftKey ? 2 : 1; // ShiftÎ°ú Îçî Îπ†Î•¥Í≤å
                    this.cameraDistance += e.deltaY * 5 * speed;
                    // ÌôïÎåÄ/Ï∂ïÏÜå ÌïúÍ≥Ñ ÏôÑÌôî
                    const minDist = this.baseCameraDistance * 0.05; // Îçî Í∞ÄÍπåÏù¥ ÌôïÎåÄ
                    const maxDist = this.baseCameraDistance * 10.0;  // Îçî Î©ÄÎ¶¨ Ï∂ïÏÜå
                    this.cameraDistance = Math.max(minDist, Math.min(maxDist, this.cameraDistance));
                    e.preventDefault();
                });

                this.updateCamera = () => {
                    // ÌÉÄÍ≤üÏù¥ ÏÑ§Ï†ïÎêòÏñ¥ ÏûàÏúºÎ©¥ ÌÉÄÍ≤ü Ï§ëÏã¨, ÏóÜÏúºÎ©¥ Îßµ Ï§ëÏã¨
                    if (this.cameraTarget) {
                        this.updateCameraToTarget();
                    } else if (this.mapBounds) {
                        const bounds = this.mapBounds;
                        const x = bounds.centerX + this.cameraDistance * Math.sin(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                        const y = bounds.centerZ + this.cameraDistance * Math.sin(this.cameraRotationX);
                        const z = bounds.centerY + this.cameraDistance * Math.cos(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                        this.camera.position.set(x, y, z);
                        this.camera.lookAt(bounds.centerX, bounds.centerZ, bounds.centerY);
                    } else {
                        const x = this.cameraDistance * Math.sin(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                        const y = this.cameraDistance * Math.sin(this.cameraRotationX);
                        const z = this.cameraDistance * Math.cos(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                        this.camera.position.set(x, y, z);
                        this.camera.lookAt(0, 0, 0);
                    }
                };

                document.getElementById('play-btn').addEventListener('click', () => {
                    this.togglePlay();
                });

                document.getElementById('timeline').addEventListener('click', (e) => {
                    const rect = e.currentTarget.getBoundingClientRect();
                    const percent = (e.clientX - rect.left) / rect.width;
                    this.seekTo(percent);
                });

                document.querySelectorAll('.speed-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        const newSpeed = parseFloat(btn.dataset.speed);
                        console.log('Ïû¨ÏÉù ÏÜçÎèÑ Î≥ÄÍ≤Ω:', this.playSpeed, '->', newSpeed);
                        this.playSpeed = newSpeed;
                        // Ïû¨ÏÉù ÏÜçÎèÑ Î≥ÄÍ≤Ω Ïãú Ï¶âÏãú Î∞òÏòÅÎêòÎèÑÎ°ù lastUpdateTime Î¶¨ÏÖã
                        this.lastUpdateTime = Date.now();
                    });
                });

                // ESC ÌÇ§Î°ú Ìè¨Ïª§Ïä§ Î™®Îìú Ï¢ÖÎ£å
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.focusMode) {
                        this.exitFocusMode();
                    }
                });

                // Reset view
                document.getElementById('reset-view').addEventListener('click', () => {
                    this.cameraRotationX = 0.3;
                    this.cameraRotationY = 0;
                    this.cameraDistance = this.baseCameraDistance;
                    this.cameraTarget = null; // ÌÉÄÍ≤ü Ìï¥Ï†ú
                    this.updateCamera();
                });
            }

            setupResizableBottom() {
                const panel = document.getElementById('bottom-panel');
                const handle = document.getElementById('resize-handle');
                const minH = 160; // px
                const maxH = Math.floor(window.innerHeight * 0.8);
                // Load saved height
                const saved = localStorage.getItem('bottomPanelHeight');
                if (saved) panel.style.height = `${parseInt(saved,10)}px`;

                let dragging = false;
                let startY = 0;
                let startH = 0;

                handle.addEventListener('mousedown', (e) => {
                    dragging = true;
                    startY = e.clientY;
                    startH = panel.getBoundingClientRect().height;
                    document.body.style.userSelect = 'none';
                });

                window.addEventListener('mousemove', (e) => {
                    if (!dragging) return;
                    const dy = startY - e.clientY; // drag up increases height
                    let h = startH + dy;
                    h = Math.max(minH, Math.min(maxH, h));
                    panel.style.height = `${h}px`;
                });

                window.addEventListener('mouseup', () => {
                    if (!dragging) return;
                    dragging = false;
                    document.body.style.userSelect = '';
                    const h = panel.getBoundingClientRect().height;
                    localStorage.setItem('bottomPanelHeight', String(Math.round(h)));
                });
            }

            updateUI() {
                if (!this.data) return;

                const m = this.data.metadata;
                document.getElementById('total-players').textContent = m.players.length;
                document.getElementById('total-events').textContent = m.total_events;
                
                const duration = m.time_range.max - m.time_range.min;
                const mins = Math.floor(duration / 60);
                const secs = Math.floor(duration % 60);
                document.getElementById('game-length').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
                document.getElementById('match-length').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
                
                const startDate = new Date();
                startDate.setHours(8, 55, 0);
                document.getElementById('start-time').textContent = startDate.toLocaleDateString('ko-KR');
                document.getElementById('match-start-time').textContent = startDate.toLocaleDateString('ko-KR');

                const playerList = document.getElementById('player-list');
                playerList.innerHTML = '';
                m.players.forEach(name => {
                    const stats = m.playerStats[name] || { kills: 0, deaths: 0, team: '' };
                    const item = document.createElement('div');
                    item.className = `player-item ${stats.team.toLowerCase()}`;
                    const kd = stats.deaths > 0 ? (stats.kills / stats.deaths).toFixed(2) : stats.kills.toFixed(2);
                    item.innerHTML = `
                        <span>${name}</span>
                        <span class="player-kd">${stats.kills}/${stats.deaths} (${kd})</span>
                    `;
                    item.style.cursor = 'pointer';
                    item.addEventListener('click', () => {
                        // ÌîåÎ†àÏù¥Ïñ¥ ÌÅ¥Î¶≠ Ïãú Ìï¥Îãπ ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Ï∞∏Ïó¨Ìïú ÌÇ¨ Ïù¥Î≤§Ìä∏Î°ú ÌïÑÌÑ∞ÎßÅ
                        const playerKills = this.data.events.filter(e => 
                            (e.attacker.name === name || e.victim.name === name) &&
                            (e.event_type_lower.includes('kill') || e.event_type_lower.includes('died'))
                        );
                        if (playerKills.length > 0) {
                            this.selectEvent(playerKills[0]);
                        }
                    });
                    playerList.appendChild(item);
                });

                this.updateEventLog();
            }

            populateKillPicker() {
                if (!this.data) return;
                const select = document.getElementById('kill-select');
                const goBtn = document.getElementById('go-kill');
                select.innerHTML = '';
                const kills = this.data.events.filter(e => (e.event_type_lower||'').includes('kill') || (e.event_type_lower||'').includes('died'));
                if (kills.length === 0) {
                    const opt = document.createElement('option');
                    opt.textContent = 'No kill events';
                    opt.value = '';
                    select.appendChild(opt);
                    goBtn.disabled = true;
                    return;
                }
                goBtn.disabled = false;
                kills.forEach((e, idx) => {
                    const opt = document.createElement('option');
                    const t = this.formatTime(e.game_time);
                    const label = `${t} ${e.attacker.name || 'Unknown'} ‚Üí ${e.victim.name || 'Unknown'}`;
                    opt.value = String(idx);
                    opt.textContent = label;
                    select.appendChild(opt);
                });

                goBtn.onclick = () => {
                    const i = parseInt(select.value);
                    if (isNaN(i)) return;
                    const e = kills[i];
                    this.selectEvent(e);
                };
            }

            populatePlayerPicker() {
                if (!this.data || !this.playerIndex) return;
                const select = document.getElementById('player-select');
                select.innerHTML = '<option value="">Players</option>';
                Array.from(this.playerIndex.keys()).sort().forEach(name => {
                    const opt = document.createElement('option');
                    opt.value = name;
                    opt.textContent = name;
                    select.appendChild(opt);
                });

                select.onchange = () => {
                    this.selectedPlayer = select.value || null;
                };

                document.getElementById('follow-toggle').onclick = () => {
                    if (!this.selectedPlayer) return;
                    this.followPlayer = !this.followPlayer;
                    document.getElementById('follow-toggle').textContent = this.followPlayer ? 'Following' : 'Follow';
                    if (!this.followPlayer) {
                        this.cameraTarget = null;
                    }
                };

                document.getElementById('prev-player-tick').onclick = () => {
                    this.seekToPlayerTick(-1);
                };
                document.getElementById('next-player-tick').onclick = () => {
                    this.seekToPlayerTick(1);
                };
            }

            seekToPlayerTick(direction) {
                if (!this.selectedPlayer || !this.playerIndex.has(this.selectedPlayer)) return;
                const arr = this.playerIndex.get(this.selectedPlayer);
                if (!arr || arr.length === 0) return;
                // ÌòÑÏû¨ Ìã± Í∏∞Ï§Ä Ïù¥Ï†Ñ/Îã§Ïùå Ìï≠Î™© Ï∞æÍ∏∞
                let idx = arr.findIndex(e => e.tick >= this.data.positions[this.currentTick].tick);
                if (idx === -1) idx = arr.length - 1;
                idx = idx + direction;
                idx = Math.max(0, Math.min(arr.length - 1, idx));
                const target = arr[idx];
                const tickIdx = this.findTickByTime(target.time);
                if (tickIdx !== -1) {
                    this.currentTick = tickIdx;
                    if (this.followPlayer) {
                        this.cameraTarget = { x: target.position[0], y: target.position[2], z: target.position[1] };
                    }
                    this.renderTick(this.currentTick);
                    this.updateTimeDisplay();
                }
            }

            updateEventLog() {
                if (!this.data) return;
                
                const eventLog = document.getElementById('event-log');
                eventLog.innerHTML = '';
                
                let eventsToShow = this.data.events;
                
                // Ìè¨Ïª§Ïä§ Î™®ÎìúÏù∏ Í≤ΩÏö∞ ÏãúÍ∞Ñ Î≤îÏúÑ ÌïÑÌÑ∞ÎßÅ
                if (this.focusMode && this.focusTickRange) {
                    const startT = this.data.positions[this.focusTickRange.startIdx].game_time;
                    const endT = this.data.positions[this.focusTickRange.endIdx].game_time;
                    eventsToShow = this.data.events.filter(e => e.game_time >= startT && e.game_time <= endT);
                } else {
                    // ÌòÑÏû¨ ÏãúÍ∞Ñ Í∏∞Ï§Ä ¬±5Ï¥à Ïù¥ÎÇ¥ Ïù¥Î≤§Ìä∏ ÌëúÏãú
                    const currentTickData = this.data.positions[this.currentTick];
                    const currentTime = currentTickData ? currentTickData.game_time : 0;
                    eventsToShow = this.data.events.filter(e => 
                        Math.abs(e.game_time - currentTime) < 5
                    );
                }
                
                eventsToShow.slice(0, 100).forEach((event, idx) => {
                    const item = document.createElement('div');
                    let className = 'event-item';
                    const isSelected = this.selectedEvent && this.selectedEvent.tick === event.tick;
                    
                    if (event.event_type_lower.includes('kill') || event.event_type_lower.includes('died')) {
                        className += ' kill';
                    } else if (event.event_type_lower.includes('attack')) {
                        className += ' attack';
                    } else if (event.event_type_lower.includes('hit')) {
                        className += ' hit';
                    }
                    
                    if (isSelected) {
                        className += ' selected';
                    }
                    
                    item.className = className;
                    
                    // HTMLÎ°ú ÏÉâÏÉÅ Íµ¨Î∂ÑÌïòÏó¨ ÌëúÏãú
                    const time = this.formatTime(event.game_time);
                    let html = `<span class="event-time">${time}</span> `;
                    
                    if (event.event_type_lower.includes('kill') || event.event_type_lower.includes('died')) {
                        if (event.attacker.name && event.victim.name) {
                            html += `<span class="event-action">killed</span> `;
                            html += `<span class="event-victim">${event.victim.name}</span>`;
                            if (event.weapon) {
                                html += ` <span class="event-weapon">with ${event.weapon}</span>`;
                            }
                            html = `<span class="event-player">${event.attacker.name}</span> ` + html;
                        } else {
                            html += `<span class="event-action">${event.event_type}</span>`;
                        }
                    } else if (event.event_type_lower.includes('attack')) {
                        html += `<span class="event-player">${event.attacker.name || 'Unknown'}</span> `;
                        html += `<span class="event-action">initiated an Attack</span>`;
                        if (event.weapon) {
                            html += ` <span class="event-action">with weapon</span> <span class="event-weapon">${event.weapon}</span>`;
                        }
                    } else {
                        html += `<span class="event-action">${event.event_type}</span>`;
                    }
                    
                    item.innerHTML = html;
                    
                    // ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ Ï∂îÍ∞Ä
                    item.addEventListener('click', () => {
                        this.selectEvent(event);
                    });
                    
                    eventLog.appendChild(item);
                });
                
                // Ïä§ÌÅ¨Î°§ÏùÑ Îß® ÏúÑÎ°ú
                eventLog.scrollTop = 0;
            }

            selectEvent(event) {
                // Í∏∞Ï°¥ ÏÑ†ÌÉù Ìï¥Ï†ú
                if (this.selectedEvent) {
                    document.querySelectorAll('.event-item.selected').forEach(item => {
                        item.classList.remove('selected');
                    });
                }
                
                this.selectedEvent = event;
                
                // Ìè¨Ïª§Ïä§ Î™®Îìú ÌôúÏÑ±Ìôî (Ïù¥Î≤§Ìä∏ Ï†ÑÌõÑ 30Ìã±)
                this.focusMode = true;
                const centerIdx = this.findTickByTime(event.game_time);
                const startIdx = Math.max(0, centerIdx - 30);
                const endIdx = Math.min(this.data.positions.length - 1, centerIdx + 30);
                this.focusTickRange = { startIdx, endIdx, centerIdx };
                this.focusTimeRange = {
                    start: this.data.positions[startIdx].game_time,
                    end: this.data.positions[endIdx].game_time
                };
                
                // Ìï¥Îãπ ÏãúÍ∞ÑÏúºÎ°ú Ïù¥Îèô
                const targetTick = this.findTickByTime(event.game_time);
                if (targetTick !== -1) {
                    this.currentTick = targetTick;
                    this.renderTick(this.currentTick);
                    this.updateTimeDisplay();
                }
                
                // Í≥µÍ≤©ÏûêÎ•º ÏãúÎÆ¨Î†àÏù¥ÏÖò Ï§ëÏïôÏóê Î∞∞Ïπò
                if (event.attacker.position[0] !== null && this.mapBounds) {
                    const attackerPos = {
                        x: event.attacker.position[0],
                        y: event.attacker.position[2],
                        z: event.attacker.position[1]
                    };
                    
                    // Ïπ¥Î©îÎùºÎ•º Í≥µÍ≤©Ïûê ÏúÑÏπòÎ•º Ï§ëÏã¨ÏúºÎ°ú Ï°∞Ï†ï
                    const bounds = this.mapBounds;
                    const maxDim = Math.max(bounds.width, bounds.height, bounds.depth);
                    this.cameraDistance = maxDim * 0.8;
                    
                    // Í≥µÍ≤©Ïûê ÏúÑÏπòÎ•º Ï§ëÏã¨ÏúºÎ°ú Ïπ¥Î©îÎùº Î∞∞Ïπò
                    this.cameraRotationX = 0.4;
                    this.cameraRotationY = Math.PI / 4; // 45ÎèÑ Í∞ÅÎèÑ
                    
                    // Ïπ¥Î©îÎùº ÌÉÄÍ≤üÏùÑ Í≥µÍ≤©Ïûê ÏúÑÏπòÎ°ú ÏÑ§Ï†ï
                    this.cameraTarget = attackerPos;
                    
                    // Ïπ¥Î©îÎùº ÏóÖÎç∞Ïù¥Ìä∏
                    this.updateCameraToTarget();
                }
                
                // Ïù¥Î≤§Ìä∏ Î°úÍ∑∏ ÏóÖÎç∞Ïù¥Ìä∏
                this.updateEventLog();
                
                // Ìè¨Ïª§Ïä§ Î™®Îìú ÌëúÏãú
                this.showFocusModeIndicator();
                // Aim Trace ÌÉ≠Ïù¥ Ïó¥Î†§ÏûàÎã§Î©¥ Í∞±Ïã†
                const activeTabEl = document.querySelector('.tab-btn.active');
                const activeTab = activeTabEl ? activeTabEl.getAttribute('data-tab') : null;
                if (activeTab === 'aim') this.renderAimTrace();
            }
            
            updateCameraToTarget() {
                if (!this.cameraTarget || !this.mapBounds) return;
                
                const target = this.cameraTarget;
                const x = target.x + this.cameraDistance * Math.sin(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                const y = target.y + this.cameraDistance * Math.sin(this.cameraRotationX);
                const z = target.z + this.cameraDistance * Math.cos(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                
                this.camera.position.set(x, y, z);
                this.camera.lookAt(target.x, target.y, target.z);
            }

            findTickByTime(targetTime) {
                if (!this.data) return -1;
                
                let closestTick = 0;
                let minDiff = Infinity;
                
                this.data.positions.forEach((pos, idx) => {
                    const diff = Math.abs(pos.game_time - targetTime);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestTick = idx;
                    }
                });
                
                return closestTick;
            }

            showFocusModeIndicator() {
                // Ìè¨Ïª§Ïä§ Î™®Îìú Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ ÌëúÏãú
                const focusControls = document.getElementById('focus-controls');
                const timeDisplay = document.getElementById('time-display');
                
                if (this.focusMode && this.focusTimeRange) {
                    focusControls.classList.add('show');
                    const range = this.focusTimeRange.end - this.focusTimeRange.start;
                    const info = document.getElementById('focus-info');
                    info.textContent = `Focus: ${this.formatTime(this.focusTimeRange.start)} - ${this.formatTime(this.focusTimeRange.end)} (${this.formatTime(range)})`;
                    timeDisplay.style.color = '#4a90e2';
                    timeDisplay.style.fontWeight = 'bold';
                } else {
                    focusControls.classList.remove('show');
                    timeDisplay.style.color = '';
                    timeDisplay.style.fontWeight = '';
                }
            }

            exitFocusMode() {
                this.focusMode = false;
                this.focusTimeRange = null;
                this.selectedEvent = null;
                this.cameraTarget = null; // ÌÉÄÍ≤ü Ìï¥Ï†ú
                this.updateCamera();
                this.showFocusModeIndicator();
                this.updateEventLog();
            }

            renderTick(tickIndex) {
                if (!this.data || !this.data.positions) return;

                const tickData = this.data.positions[tickIndex];
                if (!tickData) return;

                // Í∏∞Ï°¥ Ïò§Î∏åÏ†ùÌä∏ Ï†úÍ±∞
                this.playerObjects.forEach(obj => this.scene.remove(obj));
                this.playerLabels.forEach(obj => this.scene.remove(obj));
                this.playerObjects.clear();
                this.playerLabels.clear();

                // ÌîåÎ†àÏù¥Ïñ¥ Î†åÎçîÎßÅ
                tickData.players.forEach(player => {
                    const isCT = player.team === 'CT';
                    const color = isCT ? 0x5b9bd5 : 0xff6b6b;
                    
                    // CTÎäî ÏõêÌòï, TÎäî ÏÇºÍ∞ÅÌòï
                    let geometry;
                    if (isCT) {
                        geometry = new THREE.SphereGeometry(12, 16, 16);
                    } else {
                        geometry = new THREE.ConeGeometry(12, 24, 3);
                        geometry.rotateX(-Math.PI / 2);
                    }
                    
                    const material = new THREE.MeshPhongMaterial({ 
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.4
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(player.position[0], player.position[2], player.position[1]);
                    this.scene.add(mesh);
                    this.playerObjects.set(player.name, mesh);

                    // ÌîåÎ†àÏù¥Ïñ¥ ID ÎùºÎ≤® (ÌÅ¨Í≤å)
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 512;
                    canvas.height = 96;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Î∞∞Í≤Ω ÌÖåÎëêÎ¶¨
                    ctx.strokeStyle = isCT ? '#5b9bd5' : '#ff6b6b';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 36px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(player.name, canvas.width / 2, canvas.height / 2 + 12);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                        map: texture,
                        transparent: true,
                        depthTest: false
                    }));
                    sprite.position.set(player.position[0], player.position[2] + 35, player.position[1]);
                    sprite.scale.set(150, 30, 1);
                    this.scene.add(sprite);
                    this.playerLabels.set(player.name, sprite);
                    
                    // Ìä∏Î†àÏùº ÏóÖÎç∞Ïù¥Ìä∏
                    this.updateTrail(player.name, player.position, color);
                });

                this.renderEvents(tickData.game_time);
                this.updateEventLog();
            }

            updateTrail(playerName, position, color) {
                if (!this.playerTrails.has(playerName)) {
                    const trailGeometry = new THREE.BufferGeometry();
                    const trailMaterial = new THREE.LineBasicMaterial({ 
                        color: color,
                        opacity: 0.4,
                        transparent: true,
                        linewidth: 2
                    });
                    const trail = new THREE.Line(trailGeometry, trailMaterial);
                    this.scene.add(trail);
                    this.playerTrails.set(playerName, {
                        line: trail,
                        points: []
                    });
                }

                const trail = this.playerTrails.get(playerName);
                trail.points.push(new THREE.Vector3(position[0], position[2], position[1]));
                
                if (trail.points.length > 100) {
                    trail.points.shift();
                }

                trail.line.geometry.setFromPoints(trail.points);
            }

            renderEvents(gameTime) {
                this.eventMarkers.forEach(m => this.scene.remove(m));
                this.eventMarkers = [];

                if (!this.data || !this.data.events) return;

                this.data.events.forEach(event => {
                    const timeDiff = Math.abs(event.game_time - gameTime);
                    // Ï†ïÌôïÌûà Ìï¥Îãπ Ìã±ÏóêÎßå ÌëúÏãú (0.05Ï¥à Ïù¥ÎÇ¥, ÏïΩ 3Ìã±)
                    if (timeDiff < 0.05 && event.attacker.position[0] !== null) {
                        const geometry = new THREE.ConeGeometry(15, 50, 8);
                        const material = new THREE.MeshPhongMaterial({ 
                            color: 0xff0000,
                            emissive: 0xff0000,
                            emissiveIntensity: 0.6
                        });
                        const marker = new THREE.Mesh(geometry, material);
                        marker.position.set(
                            event.attacker.position[0],
                            event.attacker.position[2] + 25,
                            event.attacker.position[1]
                        );
                        marker.rotation.x = -Math.PI / 2;
                        this.scene.add(marker);
                        this.eventMarkers.push(marker);

                        if (event.victim.position[0] !== null) {
                            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(
                                    event.attacker.position[0],
                                    event.attacker.position[2],
                                    event.attacker.position[1]
                                ),
                                new THREE.Vector3(
                                    event.victim.position[0],
                                    event.victim.position[2],
                                    event.victim.position[1]
                                )
                            ]);
                            const lineMaterial = new THREE.LineBasicMaterial({ 
                                color: 0xff6b6b,
                                opacity: 0.8,
                                transparent: true,
                                linewidth: 2
                            });
                            const line = new THREE.Line(lineGeometry, lineMaterial);
                            this.scene.add(line);
                            this.eventMarkers.push(line);

                            // Victim 'KILLED' label with HEADSHOT and fadeout
                            // Ï†ïÌôïÌûà Ìï¥Îãπ Ìã±ÏóêÎßå ÌëúÏãúÌïòÍ≥† 2Ï¥àÍ∞Ñ ÌéòÏù¥ÎìúÏïÑÏõÉ
                            if (timeDiff < 2.0) {
                                const fadeStart = 1.5; // 1.5Ï¥à ÌõÑÎ∂ÄÌÑ∞ ÌéòÏù¥Îìú ÏãúÏûë
                                const fadeEnd = 2.0; // 2Ï¥àÏóê ÏôÑÏ†ÑÌûà ÏÇ¨ÎùºÏßê
                                let opacity = 1.0;
                                
                                if (timeDiff > fadeStart) {
                                    opacity = 1.0 - ((timeDiff - fadeStart) / (fadeEnd - fadeStart));
                                    opacity = Math.max(0, opacity);
                                }
                                
                                if (opacity > 0) {
                                    const canvas = document.createElement('canvas');
                                    const ctx = canvas.getContext('2d');
                                    canvas.width = 320;
                                    canvas.height = 80;
                                    
                                    // Î∞∞Í≤Ω (Ìà¨Î™ÖÎèÑ Ï†ÅÏö©)
                                    ctx.fillStyle = `rgba(0, 0, 0, ${0.85 * opacity})`;
                                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                                    
                                    // ÌÖåÎëêÎ¶¨
                                    ctx.strokeStyle = `rgba(255, 107, 107, ${opacity})`;
                                    ctx.lineWidth = 3;
                                    ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
                                    
                                    // KILLED ÌÖçÏä§Ìä∏
                                    ctx.fillStyle = `rgba(255, 107, 107, ${opacity})`;
                                    ctx.font = 'bold 32px Arial';
                                    ctx.textAlign = 'center';
                                    ctx.fillText('KILLED', canvas.width / 2, 35);
                                    
                                    // HEADSHOT ÌëúÏãú (Ìó§ÎìúÏÉ∑Ïù∏ Í≤ΩÏö∞)
                                    if (event.headshot) {
                                        ctx.fillStyle = `rgba(255, 215, 0, ${opacity})`;
                                        ctx.font = 'bold 24px Arial';
                                        ctx.fillText('HEADSHOT', canvas.width / 2, 60);
                                    }
                                    
                                    const tex = new THREE.CanvasTexture(canvas);
                                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                                        map: tex, 
                                        transparent: true,
                                        opacity: opacity
                                    }));
                                    sprite.position.set(
                                        event.victim.position[0],
                                        event.victim.position[2] + 50,
                                        event.victim.position[1]
                                    );
                                    sprite.scale.set(160, 40, 1);
                                    this.scene.add(sprite);
                                    this.eventMarkers.push(sprite);
                                }
                            }
                        }
                    }
                });
            }

            togglePlay() {
                this.isPlaying = !this.isPlaying;
                document.getElementById('play-btn').textContent = this.isPlaying ? '‚è∏' : '‚ñ∂';
            }

            seekTo(percent) {
                if (!this.data) return;
                const maxTick = this.data.positions.length - 1;
                this.currentTick = Math.floor(percent * maxTick);
                this.renderTick(this.currentTick);
                this.updateTimeDisplay();
            }

            updateTimeDisplay() {
                if (!this.data) return;
                
                const tickData = this.data.positions[this.currentTick];
                if (tickData) {
                    const m = this.data.metadata;
                    const currentTime = tickData.game_time - m.time_range.min;
                    const totalTime = m.time_range.max - m.time_range.min;
                    
                    document.getElementById('time-display').textContent = 
                        `${this.formatTime(currentTime)} / ${this.formatTime(totalTime)}`;
                    
                    const progress = (this.currentTick / (this.data.positions.length - 1)) * 100;
                    document.getElementById('timeline-progress').style.width = `${progress}%`;
                }
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                const ms = Math.floor((seconds % 1) * 1000);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                if (this.updateCamera) {
                    this.updateCamera();
                }

                if (this.isPlaying && this.data) {
                    const now = Date.now();
                    if (!this.lastUpdateTime) {
                        this.lastUpdateTime = now;
                    }
                    
                    // Ìã± Í∞Ñ ÏãúÍ∞Ñ Í≥ÑÏÇ∞ (Ïã§Ï†ú Í≤åÏûÑ Ìã± ÏÜçÎèÑ Í∏∞Î∞ò)
                    const tickData = this.data.positions[this.currentTick];
                    const nextTickData = this.data.positions[this.currentTick + 1];
                    
                    let shouldAdvance = false;
                    let delta = now - this.lastUpdateTime;
                    
                    if (tickData && nextTickData) {
                        const tickInterval = (nextTickData.game_time - tickData.game_time) * 1000; // ms
                        if (tickInterval > 0 && !Number.isNaN(tickInterval)) {
                            // playSpeed Ï†ÅÏö©: 1xÎ©¥ ÏõêÎûò ÏÜçÎèÑ, 0.5xÎ©¥ 2Î∞∞ ÎäêÎ¶¨Í≤å, 2xÎ©¥ 2Î∞∞ Îπ†Î•¥Í≤å
                            const targetInterval = tickInterval / this.playSpeed;
                            
                            // playSpeedÏóê Îî∞Îùº Ìã± ÏßÑÌñâ ÏÜçÎèÑ Ï°∞Ï†à
                            shouldAdvance = delta >= targetInterval;
                            
                            // Îπ†Î•∏ ÏÜçÎèÑÏùº Îïå Ïó¨Îü¨ Ìã±ÏùÑ Ìïú Î≤àÏóê Í±¥ÎÑàÎõ∞Í∏∞
                            if (shouldAdvance && this.playSpeed > 1) {
                                const ticksToSkip = Math.floor(delta / targetInterval);
                                if (ticksToSkip > 1) {
                                    // Ïó¨Îü¨ Ìã± Í±¥ÎÑàÎõ∞Í∏∞ (ÏµúÎåÄ 10Ìã±)
                                    const skipCount = Math.min(ticksToSkip - 1, 10);
                                    this.currentTick += skipCount;
                                    shouldAdvance = false; // Ïù¥ÎØ∏ Ï¶ùÍ∞ÄÌñàÏúºÎØÄÎ°ú Ï∂îÍ∞Ä Ï¶ùÍ∞Ä Î∞©ÏßÄ
                                }
                            }
                            
                            // ÎîîÎ≤ÑÍπÖ (Í∞ÄÎÅîÎßå Ï∂úÎ†•)
                            if (this.currentTick % 100 === 0) {
                                console.log('Ïû¨ÏÉù ÏÜçÎèÑ:', this.playSpeed + 'x', 'Ìã± Í∞ÑÍ≤©:', tickInterval.toFixed(2) + 'ms', 'Î™©Ìëú Í∞ÑÍ≤©:', targetInterval.toFixed(2) + 'ms', 'Ïã§Ï†ú delta:', delta.toFixed(2) + 'ms');
                            }
                        } else {
                            // Ìã± Í∞ÑÍ≤©Ïù¥ ÏóÜÍ±∞ÎÇò ÏûòÎ™ªÎêú Í≤ΩÏö∞ Í∏∞Î≥∏ Í∞ÑÍ≤© ÏÇ¨Ïö©
                            const baseInterval = 16.67 / this.playSpeed; // Í∏∞Î≥∏ 60fps Í∏∞Ï§Ä (16.67ms)
                            shouldAdvance = delta >= baseInterval;
                        }
                    } else {
                        // Îã§Ïùå Ìã± Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ Í∏∞Î≥∏ Í∞ÑÍ≤© ÏÇ¨Ïö©
                        const baseInterval = 16.67 / this.playSpeed; // Í∏∞Î≥∏ 60fps Í∏∞Ï§Ä (16.67ms)
                        shouldAdvance = delta >= baseInterval;
                    }
                    
                    if (shouldAdvance) {
                        this.currentTick += 1;
                        
                        // Ìè¨Ïª§Ïä§ Î™®ÎìúÏù∏ Í≤ΩÏö∞ Î≤îÏúÑ Ï≤¥ÌÅ¨ (Ìã± Í∏∞Î∞ò)
                        if (this.focusMode && this.focusTickRange) {
                            if (this.currentTick > this.focusTickRange.endIdx) {
                                this.currentTick = this.focusTickRange.startIdx;
                                this.isPlaying = false;
                                document.getElementById('play-btn').textContent = '‚ñ∂';
                            }
                        }
                        
                        if (this.currentTick >= this.data.positions.length) {
                            this.currentTick = this.data.positions.length - 1;
                            this.isPlaying = false;
                            document.getElementById('play-btn').textContent = '‚ñ∂';
                        } else {
                            // Follow selected player if enabled
                            if (this.followPlayer && this.selectedPlayer && this.playerIndex.has(this.selectedPlayer)) {
                                const arr = this.playerIndex.get(this.selectedPlayer);
                                const tick = this.data.positions[this.currentTick].tick;
                                const entry = arr.find(e => e.tick === tick);
                                if (entry) {
                                    this.cameraTarget = { x: entry.position[0], y: entry.position[2], z: entry.position[1] };
                                }
                            }
                            this.renderTick(this.currentTick);
                            this.updateTimeDisplay();
                            // Aim trace Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ (ÌÉ≠Ïù¥ Ïó¥Î†§ÏûàÏùÑ Îïå)
                            const activeTabEl3 = document.querySelector('.tab-btn.active');
                            const activeTab3 = activeTabEl3 ? activeTabEl3.getAttribute('data-tab') : null;
                            if (activeTab3 === 'aim') this.renderAimTrace();
                        }
                        this.lastUpdateTime = now;
                    }
                }

                this.renderer.render(this.scene, this.camera);
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            new CombatSimulation();
        });
    </script>
</body>
</html>

