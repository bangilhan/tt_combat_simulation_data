<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRUMB â€” Combat Replay Unified Monitoring & Behavior-analysis</title>
    <link rel="icon" type="image/png" href="crumb_logo.png" onerror="this.href='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ</text></svg>'">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0f1419;
            color: #fff;
            overflow: hidden;
        }

        #top-nav {
            height: 50px;
            background: #1a1f2e;
            border-bottom: 1px solid #2a2f3e;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 30px;
            position: relative;
            z-index: 1000;
            width: 100%;
        }

        #brand-logo {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-right: 30px;
            padding-right: 30px;
            border-right: 1px solid #2a2f3e;
        }

        #brand-logo img {
            height: 32px;
            width: auto;
            object-fit: contain;
        }

        #brand-text {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        #brand-name {
            font-size: 13px;
            font-weight: 600;
            color: #fff;
            letter-spacing: 0.5px;
        }

        #brand-tagline {
            font-size: 10px;
            color: #8a8fa5;
            font-style: italic;
        }

        .nav-item {
            padding: 8px 16px;
            cursor: pointer;
            color: #8a8fa5;
            font-size: 14px;
            transition: color 0.2s;
        }

        .nav-item:hover {
            color: #fff;
        }

        .nav-item.active {
            color: #4a90e2;
            border-bottom: 2px solid #4a90e2;
        }

        #container {
            display: flex;
            height: calc(100vh - 50px);
            visibility: visible;
        }

        #sidebar {
            width: 350px;
            background: #1a1f2e;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #2a2f3e;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            background: #0a0e15;
            display: block;
            visibility: visible;
        }


        #dashboard-view {
            flex: 1;
            padding: 20px 40px 40px 40px;
            overflow-y: auto;
            overflow-x: hidden;
            background: #0f1419;
            display: block;
            height: calc(100vh - 50px);
        }

        #dashboard-view.hidden {
            display: none;
        }

        #dashboard-content {
            max-width: 1000px;
            margin: 0 auto;
            color: #fff;
            padding-right: 20px;
        }

        #dashboard-content h1 {
            font-size: 32px;
            margin-bottom: 20px;
            color: #fff;
        }

        #dashboard-content h2 {
            font-size: 24px;
            margin-top: 30px;
            margin-bottom: 15px;
            color: #4a90e2;
            border-bottom: 2px solid #2a2f3e;
            padding-bottom: 10px;
        }

        #dashboard-content h3 {
            font-size: 18px;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #8a8fa5;
        }

        #dashboard-content h4 {
            font-size: 16px;
            margin-top: 15px;
            margin-bottom: 8px;
            color: #6a6f85;
            font-weight: 600;
        }

        #dashboard-content p {
            line-height: 1.6;
            color: #c0c5d0;
            margin-bottom: 10px;
        }

        #dashboard-content strong {
            color: #fff;
            font-weight: 600;
        }

        #dashboard-content ul, #dashboard-content ol {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        #dashboard-content li {
            line-height: 1.6;
            color: #c0c5d0;
            margin-bottom: 2px;
        }

        #dashboard-content code {
            background: #1a1f2e;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #4a90e2;
        }

        #dashboard-content pre {
            background: #1a1f2e;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
        }

        #dashboard-content pre code {
            background: none;
            padding: 0;
            color: #c0c5d0;
        }

        #dashboard-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }

        #dashboard-content table th,
        #dashboard-content table td {
            border: 1px solid #2a2f3e;
            padding: 10px;
            text-align: left;
        }

        #dashboard-content table th {
            background: #1a1f2e;
            color: #4a90e2;
        }

        #canvas {
            width: 100%;
            height: 100%;
        }

        /* GitHub CSV ì„ íƒ íŒì—… */
        #csv-popup {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        #csv-popup.active {
            display: flex;
        }

        #csv-popup-content {
            background: #1a1f2e;
            border: 1px solid #2a2f3e;
            border-radius: 8px;
            padding: 20px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        #csv-popup-content h3 {
            margin-top: 0;
            color: #fff;
            margin-bottom: 15px;
        }

        #csv-file-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #csv-file-list li {
            padding: 12px;
            margin-bottom: 8px;
            background: #2a2f3e;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            color: #fff;
        }

        #csv-file-list li:hover {
            background: #3a3f4e;
        }

        #csv-popup-close {
            margin-top: 15px;
            padding: 10px 20px;
            background: #4a90e2;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        #csv-popup-close:hover {
            background: #5aa0f2;
        }

        #bottom-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 300px;
            background: rgba(26, 31, 46, 0.98);
            border-top: 1px solid #2a2f3e;
            display: flex;
            flex-direction: column;
        }

        /* drag handle to resize bottom panel */
        #resize-handle {
            height: 6px;
            cursor: ns-resize;
            background: linear-gradient(180deg, #2a2f3e, #1a1f2e);
        }
        #resize-handle:hover {
            background: linear-gradient(180deg, #3a3f4e, #1f2738);
        }

        #controls {
            padding: 15px 20px;
            border-bottom: 1px solid #2a2f3e;
        }

        #event-tabs {
            display: flex;
            gap: 10px;
            padding: 10px 20px;
            border-bottom: 1px solid #2a2f3e;
            background: #1a1f2e;
        }

        .tab-btn {
            padding: 8px 16px;
            background: transparent;
            border: none;
            color: #8a8fa5;
            cursor: pointer;
            font-size: 13px;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab-btn:hover {
            color: #fff;
        }

        .tab-btn.active {
            color: #4a90e2;
            border-bottom-color: #4a90e2;
        }

        #event-log {
            flex: 1;
            overflow-y: auto;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }

        .event-item {
            padding: 6px 8px;
            margin-bottom: 4px;
            background: #2a2f3e;
            border-radius: 3px;
            color: #8a8fa5;
            border-left: 3px solid transparent;
            cursor: pointer;
            transition: background 0.2s;
        }

        .event-item:hover {
            background: #3a3f4e;
        }

        .event-item.selected {
            background: #4a4f5e;
            border-left-color: #4a90e2;
        }

        .event-item.kill {
            border-left-color: #ff6b6b;
        }

        .event-item.attack {
            border-left-color: #ffa500;
        }

        .event-item.hit {
            border-left-color: #4a90e2;
        }

        .event-time {
            color: #6b9bd5;
            font-weight: 600;
        }

        .event-player {
            color: #4a90e2;
            font-weight: 500;
        }

        .event-victim {
            color: #ff6b6b;
            font-weight: 500;
        }

        .event-action {
            color: #8a8fa5;
        }

        .event-weapon {
            color: #ffa500;
            font-style: italic;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .play-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #4a90e2;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .play-btn:hover {
            background: #5aa0f2;
        }

        .timeline {
            flex: 1;
            height: 6px;
            background: #2a2f3e;
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }

        .timeline-progress {
            height: 100%;
            background: #4a90e2;
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s;
        }

        .time-display {
            min-width: 100px;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .speed-btn {
            padding: 5px 10px;
            background: #2a2f3e;
            border: 1px solid #3a3f4e;
            color: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
        }

        .speed-btn.active {
            background: #4a90e2;
            border-color: #4a90e2;
        }

        .sidebar-section {
            margin-bottom: 25px;
        }

        .sidebar-section h3 {
            font-size: 12px;
            color: #8a8fa5;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #2a2f3e;
            font-size: 12px;
        }

        .stat-label {
            color: #8a8fa5;
        }

        .stat-value {
            color: #fff;
            font-weight: 500;
        }

        .stat-group {
            margin-bottom: 15px;
        }

        .stat-group-title {
            font-size: 11px;
            color: #6a6f85;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #file-input {
            margin-bottom: 20px;
            padding: 12px;
            background: #2a2f3e;
            border-radius: 6px;
            border: 1px solid #3a3f4e;
        }

        #file-input input[type="file"] {
            color: white;
            font-size: 12px;
        }

        #loading {
            text-align: center;
            padding: 20px;
            color: #8a8fa5;
            font-size: 14px;
        }

        .player-item {
            padding: 8px;
            margin-bottom: 5px;
            background: #2a2f3e;
            border-radius: 4px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-item.ct {
            border-left: 3px solid #5b9bd5;
        }

        .player-item.terrorist {
            border-left: 3px solid #ff6b6b;
        }

        .player-kd {
            font-size: 11px;
            color: #8a8fa5;
        }

        #map-info {
            background: #2a2f3e;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
        }

        #map-info-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        #map-bounds {
            font-size: 11px;
            color: #8a8fa5;
            font-family: 'Courier New', monospace;
        }

        #focus-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(26, 31, 46, 0.95);
            padding: 15px;
            border-radius: 8px;
            display: none;
            z-index: 100;
        }

        #focus-controls.show {
            display: block;
        }

        #focus-controls button {
            padding: 8px 16px;
            background: #4a90e2;
            border: none;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 10px;
        }

        #focus-controls button:hover {
            background: #5aa0f2;
        }

        #focus-info {
            font-size: 12px;
            color: #8a8fa5;
            margin-bottom: 10px;
        }

        /* Kill event picker (top-left of canvas) */
        #event-picker {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(26, 31, 46, 0.95);
            border: 1px solid #2a2f3e;
            border-radius: 8px;
            padding: 10px;
            display: flex;
            gap: 8px;
            align-items: center;
            z-index: 120;
        }

        #event-picker select, #event-picker button {
            background: #2a2f3e;
            border: 1px solid #3a3f4e;
            color: #fff;
            border-radius: 4px;
            padding: 6px 8px;
            font-size: 12px;
        }

        #event-picker button.primary {
            background: #4a90e2;
            border-color: #4a90e2;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="top-nav">
        <div id="brand-logo">
            <img id="brand-image" src="crumb_logo.png" alt="CRUMB Logo" onerror="this.style.display='none'">
            <div id="brand-text">
                <div id="brand-name">CRUMB â€” Combat Replay Unified Monitoring & Behavior-analysis</div>
                <div id="brand-tagline">"Follow every trace." ğŸ</div>
            </div>
        </div>
        <div class="nav-item active">Info</div>
        <div class="nav-item">3D ì‹œë®¬ë ˆì´ì…˜ ë¶„ì„</div>
        <div class="nav-item" id="report-tab">ë¶„ì„ ë³´ê³ ì„œ</div>
        <div class="nav-item" id="lang-toggle" style="margin-left: auto; cursor: pointer; padding: 8px 12px; background: #2a2f3e; border-radius: 4px;">ğŸŒ EN</div>
    </div>

    <div id="container" style="display: none;">
        <div id="sidebar">
            <div class="sidebar-section">
                <h3>File Load</h3>
                <div id="file-input">
                    <button id="select-csv-btn" style="width: 100%; padding: 10px; background: #4a90e2; color: #fff; border: none; border-radius: 4px; cursor: pointer; margin-bottom: 10px;">íŒŒì¼ ì„ íƒ</button>
                    <div id="selected-file" style="font-size: 12px; color: #8a8fa5; margin-bottom: 10px;">ì„ íƒëœ íŒŒì¼ ì—†ìŒ</div>
                    <input type="file" id="csv-file" accept=".csv" style="display: none;" />
                    <div id="loading" style="display: none;">CSV íŒŒì¼ ì²˜ë¦¬ ì¤‘...</div>
                </div>
            </div>


            

            <div class="sidebar-section">
                <h3>Statistics</h3>
                
                <div class="stat-group">
                    <div class="stat-group-title">Title</div>
                    <div class="stat-item">
                        <span class="stat-label">Name:</span>
                        <span class="stat-value" id="game-name">CS2</span>
                    </div>
                </div>

                <div class="stat-group">
                    <div class="stat-group-title">Game</div>
                    <div class="stat-item">
                        <span class="stat-label">Match ID:</span>
                        <span class="stat-value" id="match-id">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Start time:</span>
                        <span class="stat-value" id="start-time">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Length:</span>
                        <span class="stat-value" id="game-length">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Players:</span>
                        <span class="stat-value" id="total-players">-</span>
                    </div>
                    <div class="stat-item" style="display: none;">
                        <span class="stat-label">Server:</span>
                        <span class="stat-value" id="server-info">-</span>
                    </div>
                    <div class="stat-item" style="display: none;">
                        <span class="stat-label">Game Mode:</span>
                        <span class="stat-value" id="game-mode">-</span>
                    </div>
                </div>

                <div class="stat-group">
                    <div class="stat-group-title">Match</div>
                    <div class="stat-item">
                        <span class="stat-label">Match Start Time:</span>
                        <span class="stat-value" id="match-start-time">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Match Length:</span>
                        <span class="stat-value" id="match-length">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Map Name:</span>
                        <span class="stat-value" id="map-name">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Total Events:</span>
                        <span class="stat-value" id="total-events">-</span>
                    </div>
                    <div class="stat-item" style="display: none;">
                        <span class="stat-label">Match Mode:</span>
                        <span class="stat-value" id="match-mode">-</span>
                    </div>
                </div>

                <div id="map-info">
                    <div id="map-info-title">Map Bounds</div>
                    <div id="map-bounds">Calculating...</div>
                    <div id="map-info-text" style="margin-top: 10px; padding: 10px; background: #1a1f2e; border-radius: 4px; font-size: 11px; color: #8a8fa5;">
                        <div style="margin-bottom: 5px;"><strong id="map-rendering-label">ë§µ ë Œë”ë§ ì •ë³´:</strong></div>
                        <div id="current-map-text">í˜„ì¬ ë§µ: <span id="detected-map-name">-</span></div>
                        <div id="map-geometry-text" style="margin-top: 5px;">ë§µ ì§€ì˜¤ë©”íŠ¸ë¦¬ ë°ì´í„°ëŠ” CS2 ê²Œì„ íŒŒì¼(.bsp)ì—ì„œ ì¶”ì¶œí•˜ê±°ë‚˜</div>
                        <div id="map-api-text">ì™¸ë¶€ ë§µ ë°ì´í„° APIë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.</div>
                        <div id="map-note-text" style="margin-top: 5px; color: #4a90e2;">ì°¸ê³ : í˜„ì¬ëŠ” í”Œë ˆì´ì–´ ìœ„ì¹˜ ê¸°ë°˜ ê²½ê³„ë§Œ í‘œì‹œë©ë‹ˆë‹¤.</div>
                    </div>
                </div>

                <div class="stat-group">
                    <div class="stat-group-title">Players (K/D Ratio)</div>
                    <div style="font-size: 10px; color: #6a6f85; margin-bottom: 8px; font-style: italic;">
                        K/D: Kills / Deaths - Click to filter
                    </div>
                    <div id="player-list"></div>
                </div>
            </div>
        </div>

        <div id="canvas-container">
            <canvas id="canvas"></canvas>
            <div id="event-picker">
                <select id="kill-select">
                    <option value="">Kill events will appear here</option>
                </select>
                <button id="go-kill" class="primary">Go</button>
                <button id="reset-view">Reset View</button>

                <span style="width:12px"></span>
                <select id="player-select">
                    <option value="">Players</option>
                </select>
                <button id="prev-player-tick">Prev</button>
                <button id="next-player-tick">Next</button>
                <button id="follow-toggle">Follow</button>
            </div>
            <div id="focus-controls">
                <div id="focus-info">Focus Mode: Event selected</div>
                <button id="exit-focus-btn">Exit Focus Mode</button>
            </div>
        </div>
    </div>

    

    <div id="bottom-panel">
        <div id="resize-handle" title="Drag to resize"></div>
        <div id="controls">
            <div class="control-group">
                <button class="play-btn" id="play-btn">â–¶</button>
                <div class="timeline" id="timeline">
                    <div class="timeline-progress" id="timeline-progress"></div>
                </div>
                <div class="time-display" id="time-display">00:00 / 00:00</div>
                <div class="speed-control">
                    <button class="speed-btn" data-speed="0.5">0.5x</button>
                    <button class="speed-btn active" data-speed="1">1x</button>
                    <button class="speed-btn" data-speed="2">2x</button>
                    <button class="speed-btn" data-speed="3">3x</button>
                </div>
            </div>
        </div>

        <div id="event-tabs">
            <button class="tab-btn active" data-tab="actions">Action Stream</button>
            <button class="tab-btn" data-tab="chat">Match Chat</button>
            <button class="tab-btn" data-tab="aim">Aim Trace</button>
        </div>

        <div id="event-log"></div>
    </div>

    <!-- Dashboard View -->
    <div id="dashboard-view" style="display: block;">
        <div id="dashboard-content"></div>
    </div>
    
    <script>
        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì¦‰ì‹œ Dashboard í‘œì‹œ ë³´ì¥ (ìµœìš°ì„  ì‹¤í–‰)
        (function() {
            function initDashboard() {
                const dashboardView = document.getElementById('dashboard-view');
                const container = document.getElementById('container');
                const bottomPanel = document.getElementById('bottom-panel');
                const topNav = document.getElementById('top-nav');
                
                // ìƒë‹¨ ë„¤ë¹„ê²Œì´ì…˜ í•­ìƒ í‘œì‹œ
                if (topNav) {
                    topNav.style.display = 'flex';
                    topNav.style.visibility = 'visible';
                }
                
                // Dashboard í‘œì‹œ
                if (dashboardView) {
                    dashboardView.style.display = 'block';
                    dashboardView.style.visibility = 'visible';
                    dashboardView.classList.remove('hidden');
                }
                
                // Container ìˆ¨ê¸°ê¸°
                if (container) {
                    container.style.display = 'none';
                    container.style.visibility = 'hidden';
                }
                
                // í•˜ë‹¨ íŒ¨ë„ ìˆ¨ê¸°ê¸°
                if (bottomPanel) {
                    bottomPanel.style.display = 'none';
                    bottomPanel.style.visibility = 'hidden';
                }
            }
            
            // ì¦‰ì‹œ ì‹¤í–‰
            initDashboard();
            
            // DOM ë¡œë“œ í›„ì—ë„ ì‹¤í–‰
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initDashboard);
            }
            
            // ì¶”ê°€ ë³´ì¥ì„ ìœ„í•´ ì•½ê°„ì˜ ì§€ì—° í›„ ì‹¤í–‰
            setTimeout(initDashboard, 100);
            
            // CombatSimulation ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ëœ í›„ Dashboard ë Œë”ë§ ë³´ì¥
            let renderAttempts = 0;
            const maxAttempts = 10;
            const checkAndRender = setInterval(() => {
                if (window.simulation && typeof window.simulation.renderDashboard === 'function') {
                    window.simulation.renderDashboard();
                    clearInterval(checkAndRender);
                } else {
                    renderAttempts++;
                    if (renderAttempts >= maxAttempts) {
                        clearInterval(checkAndRender);
                        // ìµœì†Œí•œ ê¸°ë³¸ ë‚´ìš©ì´ë¼ë„ í‘œì‹œ
                        const content = document.getElementById('dashboard-content');
                        if (content && !content.innerHTML.trim()) {
                            content.innerHTML = `
                                <h1>CRUMB â€” Combat Replay Unified Monitoring & Behavior-analysis</h1>
                                <p>"Follow every trace." ğŸ</p>
                                <h2>ğŸš€ ë¹ ë¥¸ ì‹œì‘</h2>
                                <ol>
                                    <li><strong>3D ì‹œë®¬ë ˆì´ì…˜ ë¶„ì„</strong> íƒ­ í´ë¦­</li>
                                    <li>ì¢Œì¸¡ ì‚¬ì´ë“œë°” <strong>"íŒŒì¼ ì„ íƒ"</strong> ë²„íŠ¼ í´ë¦­</li>
                                    <li>GitHub CSV íŒŒì¼ ì„ íƒ</li>
                                    <li>3D ì‹œë®¬ë ˆì´ì…˜ ìë™ ì‹œì‘</li>
                                </ol>
                            `;
                        }
                    }
                }
            }, 200);
        })();
    </script>

    <!-- GitHub CSV ì„ íƒ íŒì—… -->
    <div id="csv-popup">
        <div id="csv-popup-content">
            <h3>í˜„ì¬ ê²½ë¡œì—ì„œ í™•ì¸ë˜ëŠ” csv íŒŒì¼</h3>
            
            <div id="csv-loading" style="color: #8a8fa5;">íŒŒì¼ ëª©ë¡ ë¡œë”© ì¤‘...</div>
            <ul id="csv-file-list"></ul>
            <div style="margin-top: 15px; display: flex; gap: 10px; align-items: center;">
                <button id="csv-load-selected" style="flex: 1; padding: 12px 20px; background: #4a90e2; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; height: 44px; line-height: 1; box-sizing: border-box; display: flex; align-items: center; justify-content: center; margin: 0;">ì„ íƒí•œ íŒŒì¼ ë¡œë“œ</button>
                <button id="csv-popup-close" style="flex: 1; padding: 12px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; height: 44px; line-height: 1; box-sizing: border-box; display: flex; align-items: center; justify-content: center; margin: 0;">ë‹«ê¸°</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script>
        class CombatSimulation {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                
                this.data = null;
                this.currentTick = 0;
                this.isPlaying = false;
                this.playSpeed = 1;
                this.initialRenderDone = false;
                
                this.playerObjects = new Map();
                this.playerLabels = new Map();
                this.playerTrails = new Map();
                this.playerPathLines = new Map();
                this.eventMarkers = [];
                this.mapBounds = null;
                this.selectedEvent = null;
                this.focusMode = false;
                this.focusTimeRange = null;
                this.focusTickRange = null;
                this.baseCameraDistance = 1500;
                this.language = 'ko'; // 'ko' or 'en'
                this.currentReportWindow = null; // í˜„ì¬ ì—´ë ¤ìˆëŠ” ë³´ê³ ì„œ ì°½
                this.detectedMapName = null; // ì¶”ë¡ ëœ ë§µ ì´ë¦„
                this.mapData = null; // ë§µ ë°ì´í„° (ì™¸ë¶€ì—ì„œ ë¡œë“œ)
                this.pathLines = null; // ì£¼ìš” ê²½ë¡œ ë¼ì¸
                this.cameraRotationX = 0.3;
                this.cameraRotationY = 0;
                this.cameraDistance = 1500;
                this.killLabels = new Map(); // í‚¬ ë¼ë²¨ ì¶”ì  (í˜ì´ë“œì•„ì›ƒìš©)
                this.playerIndex = new Map(); // name -> [{tick, pos}]
                this.selectedPlayer = null;
                this.mapImagePlane = null; // 2D ë§µ ì´ë¯¸ì§€ í‰ë©´
                this.mapImageTexture = null; // ë§µ ì´ë¯¸ì§€ í…ìŠ¤ì²˜
                this.mapImageSettings = {
                    imagePath: 'anubis-pro-vs-matchmaking-callouts-v0-k3ix37861a1a1.webp',
                    repeatX: 1,
                    repeatY: 1,
                    offsetX: 0,
                    offsetY: 0,
                    textureRotation: 0,
                    scaleX: 1,
                    scaleZ: 1,
                    worldOffsetX: 0,
                    worldOffsetZ: 0,
                    worldOffsetY: 0,
                    worldRotation: 0
                };
                this.followPlayer = false;
                
                // window.simulationì— ì¸ìŠ¤í„´ìŠ¤ í• ë‹¹ (ë””ë²„ê¹…ìš©)
                window.simulation = this;
                
                this.init();
            }

            init() {
                this.setupScene();
                this.setupControls();
                this.setupFileInput();
                this.setupTabs();
                this.setupResizableBottom();
                this.setupNavigation();
                // ì´ˆê¸° ë¡œë“œ ì‹œ Dashboard í‘œì‹œ
                this.showDashboard();
                
                // ë§µ ë°ì´í„° ë¡œë“œ (ë¹„ë™ê¸°)
                this.loadMapData();
                this.animate();
            }

            setupFileInput() {
                const selectBtn = document.getElementById('select-csv-btn');
                const inputEl = document.getElementById('csv-file');
                
                if (selectBtn) {
                    selectBtn.addEventListener('click', () => {
                        this.showCSVPopup();
                    });
                }
                
                if (!inputEl) {
                    console.error('íŒŒì¼ ì…ë ¥ ìš”ì†Œ(#csv-file)ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }
                // ê°™ì€ íŒŒì¼ì„ ì—°ì† ì„ íƒí•  ë•Œ change ì´ë²¤íŠ¸ê°€ ì•ˆ ëœ¨ëŠ” ë¬¸ì œ ë°©ì§€
                inputEl.addEventListener('click', () => {
                    inputEl.value = '';
                });
                inputEl.addEventListener('change', (e) => {
                    const file = e.target.files && e.target.files[0];
                    const loading = document.getElementById('loading');
                    if (loading) {
                        loading.style.display = 'block';
                        loading.innerHTML = 'Parsing CSV file...';
                    }
                    if (file) {
                        console.log('CSV íŒŒì¼ ì„ íƒë¨:', file.name, file.size, 'bytes');
                        document.getElementById('selected-file').textContent = file.name;
                        this.loadCSV(file);
                    } else {
                        console.warn('ì„ íƒëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.');
                        if (loading) loading.style.display = 'none';
                    }
                });

                // ë§µ ì´ë¯¸ì§€ ìë™ ë¡œë“œ (POC: anubis í”„ë¡œë§µ)
                // setupMapImageInputì€ ì œê±°ë¨ (POCì—ì„œëŠ” ìë™ ë¡œë“œ)

                // íŒì—… ë‹«ê¸° ë²„íŠ¼
                const closeBtn = document.getElementById('csv-popup-close');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => {
                        document.getElementById('csv-popup').classList.remove('active');
                    });
                }
                
                // GitHub Token ê´€ë¦¬
            }
            

            setupNavigation() {
                const navItems = document.querySelectorAll('.nav-item');
                navItems.forEach(item => {
                    item.addEventListener('click', () => {
                        const text = item.textContent.trim();
                        if (text === 'Info') {
                            this.showDashboard();
                        } else if (text === '3D ì‹œë®¬ë ˆì´ì…˜ ë¶„ì„') {
                            this.showInvestigate();
                        } else {
                            // ë‹¤ë¥¸ íƒ­ë“¤ì€ ë‚˜ì¤‘ì— êµ¬í˜„
                            navItems.forEach(n => n.classList.remove('active'));
                            item.classList.add('active');
                        }
                    });
                });
            }

            showDashboard() {
                document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                document.querySelectorAll('.nav-item').forEach(n => {
                    if (n.textContent.trim() === 'Info') n.classList.add('active');
                });
                
                const dashboardView = document.getElementById('dashboard-view');
                const container = document.getElementById('container');
                const bottomPanel = document.getElementById('bottom-panel');
                
                if (dashboardView && container) {
                    container.style.display = 'none';
                    dashboardView.style.display = 'block';
                    dashboardView.style.visibility = 'visible';
                    dashboardView.classList.remove('hidden');
                    // í•˜ë‹¨ íŒ¨ë„ ìˆ¨ê¸°ê¸°
                    if (bottomPanel) {
                        bottomPanel.style.display = 'none';
                    }
                    // Dashboard ë Œë”ë§
                    this.renderDashboard();
                } else {
                    console.error('Dashboard view ë˜ëŠ” containerë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                }
            }

            showInvestigate() {
                document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                document.querySelectorAll('.nav-item').forEach(n => {
                    if (n.textContent.trim() === '3D ì‹œë®¬ë ˆì´ì…˜ ë¶„ì„') n.classList.add('active');
                });
                
                const dashboardView = document.getElementById('dashboard-view');
                const container = document.getElementById('container');
                const bottomPanel = document.getElementById('bottom-panel');
                
                // Dashboard ìˆ¨ê¸°ê¸°
                if (dashboardView) {
                    dashboardView.style.display = 'none';
                    dashboardView.style.visibility = 'hidden';
                    dashboardView.classList.add('hidden');
                }
                
                // Container í‘œì‹œ
                if (container) {
                    container.style.display = 'flex';
                    container.style.visibility = 'visible';
                    
                    // í•˜ë‹¨ íŒ¨ë„ ë‹¤ì‹œ í‘œì‹œ
                    if (bottomPanel) {
                        bottomPanel.style.display = 'flex';
                        bottomPanel.style.visibility = 'visible';
                    }
                    
                    // Canvas ì»¨í…Œì´ë„ˆê°€ ë³´ì´ë„ë¡ ë³´ì¥
                    const canvasContainer = document.getElementById('canvas-container');
                    if (canvasContainer) {
                        canvasContainer.style.display = 'block';
                        canvasContainer.style.visibility = 'visible';
                    }
                    
                    // ë°ì´í„°ê°€ ì—†ì„ ë•Œ ì•ˆë‚´ ë©”ì‹œì§€ í‘œì‹œ
                    if (!this.data || !this.data.positions || this.data.positions.length === 0) {
                        // ì•ˆë‚´ ë©”ì‹œì§€ë¥¼ ìœ„í•œ ì˜¤ë²„ë ˆì´ ì¶”ê°€
                        let messageOverlay = document.getElementById('no-data-message');
                        if (!messageOverlay) {
                            messageOverlay = document.createElement('div');
                            messageOverlay.id = 'no-data-message';
                            messageOverlay.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #8a8fa5; z-index: 1000; pointer-events: none;';
                            if (canvasContainer) {
                                canvasContainer.appendChild(messageOverlay);
                            }
                        }
                        messageOverlay.innerHTML = `
                            <div style="font-size: 24px; margin-bottom: 10px;">CSV íŒŒì¼ì„ ë¨¼ì € ë¡œë“œí•´ì£¼ì„¸ìš”</div>
                            <div style="font-size: 16px;">ì¢Œì¸¡ ì‚¬ì´ë“œë°”ì˜ "íŒŒì¼ ì„ íƒ" ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”</div>
                        `;
                        messageOverlay.style.display = 'block';
                    } else {
                        // ë°ì´í„°ê°€ ìˆìœ¼ë©´ ë©”ì‹œì§€ ìˆ¨ê¹€
                        const messageOverlay = document.getElementById('no-data-message');
                        if (messageOverlay) {
                            messageOverlay.style.display = 'none';
                        }
                    }
                    
                    // Renderer í¬ê¸° ì¬ì¡°ì •
                    if (this.renderer) {
                        setTimeout(() => {
                            const width = canvasContainer ? canvasContainer.clientWidth : 800;
                            const height = canvasContainer ? canvasContainer.clientHeight : 600;
                            if (width > 0 && height > 0) {
                                this.camera.aspect = width / height;
                                this.camera.updateProjectionMatrix();
                                this.renderer.setSize(width, height);
                            }
                        }, 100);
                    } else if (this.scene) {
                        // Rendererê°€ ì—†ìœ¼ë©´ ì”¬ ì¬ì´ˆê¸°í™”
                        setTimeout(() => {
                            this.setupScene();
                        }, 100);
                    }
                }
            }

            async renderDashboard() {
                const content = document.getElementById('dashboard-content');
                if (!content) return;

                // ë¸Œëœë“œ í—¤ë” ì¶”ê°€
                const brandHeader = `
                    <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 40px; padding-bottom: 20px; border-bottom: 2px solid #2a2f3e;">
                        <img src="crumb_logo.png" alt="CRUMB Logo" onerror="this.style.display='none'" style="height: 64px; width: auto; object-fit: contain;">
                        <div>
                            <h1 style="margin: 0; font-size: 28px; color: #fff; font-weight: 600; letter-spacing: 0.5px;">CRUMB â€” Combat Replay Unified Monitoring & Behavior-analysis</h1>
                            <p style="margin: 8px 0 0 0; font-size: 14px; color: #8a8fa5; font-style: italic;">"Follow every trace." ğŸ</p>
                        </div>
                    </div>
                `;

                // README ë‚´ìš©ì„ HTMLë¡œ ë³€í™˜ (ì–¸ì–´ë³„)
                const readmeContents = {
                    ko: `FPS ì „íˆ¬ êµì „ ìƒí™©ì„ 3Dë¡œ ì‹œë®¬ë ˆì´ì…˜í•˜ê³  ë¶„ì„í•˜ëŠ” ì›¹ í”Œë«í¼ì…ë‹ˆë‹¤.

---

## ğŸš€ ë¹ ë¥¸ ì‹œì‘

1. **3D ì‹œë®¬ë ˆì´ì…˜ ë¶„ì„** íƒ­ í´ë¦­
2. ì¢Œì¸¡ ì‚¬ì´ë“œë°” **"íŒŒì¼ ì„ íƒ"** ë²„íŠ¼ í´ë¦­
3. GitHub CSV íŒŒì¼ ì„ íƒ
4. 3D ì‹œë®¬ë ˆì´ì…˜ ìë™ ì‹œì‘

---

## ğŸ¯ ì£¼ìš” ê¸°ëŠ¥

- **3D ì‹œê°í™”**: í”Œë ˆì´ì–´ ìœ„ì¹˜, í‚¬ ì´ë²¤íŠ¸, ì´ë™ ê²½ë¡œ
- **ì¸í„°ë™í‹°ë¸Œ ì»¨íŠ¸ë¡¤**: ì¹´ë©”ë¼ íšŒì „/ì¤Œ, ì¬ìƒ/ì¼ì‹œì •ì§€, ì†ë„ ì¡°ì ˆ
- **í”Œë ˆì´ì–´ ì¶”ì **: Follow ëª¨ë“œ, K/D Ratio, ì‹œì  ì´ë™
- **Aim Trace**: ì¡°ì¤€ ê¶¤ì  ì‹œê°í™”, ì—ì„ë´‡ íƒì§€

---

## ğŸ® ì»¨íŠ¸ë¡¤

| ì…ë ¥ | ë™ì‘ |
|------|------|
| ë§ˆìš°ìŠ¤ ë“œë˜ê·¸ | ì¹´ë©”ë¼ íšŒì „ |
| ë§ˆìš°ìŠ¤ íœ  | ì¤Œ ì¸/ì•„ì›ƒ |
| ì¬ìƒ ë²„íŠ¼ | ì‹œì‘/ì¼ì‹œì •ì§€ |
| íƒ€ì„ë¼ì¸ í´ë¦­ | ì‹œì  ì´ë™ |
| ì†ë„ ë²„íŠ¼ | 0.5x ~ 3x |

---

## ğŸ”§ ê¸°ìˆ  ìŠ¤íƒ

Three.js Â· PapaParse Â· ìˆœìˆ˜ JavaScript`,
                    en: `A web platform for 3D simulation and analysis of FPS combat engagement situations.

---

## ğŸš€ Quick Start

1. Click **3D Simulation Analysis** tab
2. Click **"Select File"** button in the left sidebar
3. Select GitHub CSV file
4. 3D simulation starts automatically

---

## ğŸ¯ Key Features

- **3D Visualization**: Player positions, kill events, movement paths
- **Interactive Controls**: Camera rotation/zoom, play/pause, speed adjustment
- **Player Tracking**: Follow mode, K/D Ratio, viewpoint movement
- **Aim Trace**: Aim trajectory visualization, aimbot detection

---

## ğŸ® Controls

| Input | Action |
|------|------|
| Mouse Drag | Camera Rotation |
| Mouse Wheel | Zoom In/Out |
| Play Button | Start/Pause |
| Timeline Click | Seek Position |
| Speed Button | 0.5x ~ 3x |

---

## ğŸ”§ Tech Stack

Three.js Â· PapaParse Â· Pure JavaScript`
                };
                
                const readmeContent = readmeContents[this.language] || readmeContents.ko;

                // ê°„ë‹¨í•œ ë§ˆí¬ë‹¤ìš´ íŒŒì„œ (ê¸°ë³¸ì ì¸ ë³€í™˜)
                content.innerHTML = brandHeader + this.markdownToHTML(readmeContent);
            }

            markdownToHTML(markdown) {
                let html = markdown;
                
                // í—¤ë”ì— ID ì¶”ê°€ë¥¼ ìœ„í•œ í—¬í¼ í•¨ìˆ˜
                const createId = (text) => {
                    return text.toLowerCase()
                        .replace(/[^\w\u3131-\u318E\uAC00-\uD7A3]+/g, '-')
                        .replace(/^-+|-+$/g, '');
                };
                
                // ë§í¬ ë³€í™˜ (í—¤ë” ë³€í™˜ ì „ì— ì²˜ë¦¬)
                html = html.replace(/\[([^\]]+)\]\(#([^\)]+)\)/g, (match, text, anchor) => {
                    return `<a href="#${anchor}" style="color: #4a90e2; text-decoration: none; border-bottom: 1px solid #4a90e2;">${text}</a>`;
                });
                
                // í—¤ë” ë³€í™˜ (ID í¬í•¨) - ìˆœì„œ ì¤‘ìš”: h4 -> h3 -> h2 -> h1
                html = html.replace(/^#### (.*$)/gim, (match, text) => {
                    const id = createId(text);
                    return `<h4 id="${id}">${text}</h4>`;
                });
                html = html.replace(/^### (.*$)/gim, (match, text) => {
                    const id = createId(text);
                    return `<h3 id="${id}">${text}</h3>`;
                });
                html = html.replace(/^## (.*$)/gim, (match, text) => {
                    const id = createId(text);
                    return `<h2 id="${id}">${text}</h2>`;
                });
                html = html.replace(/^# (.*$)/gim, (match, text) => {
                    const id = createId(text);
                    return `<h1 id="${id}">${text}</h1>`;
                });
                
                // ë³¼ë“œì²´ ë³€í™˜ (**í…ìŠ¤íŠ¸**)
                html = html.replace(/\*\*([^\*]+)\*\*/g, '<strong>$1</strong>');
                
                // ì½”ë“œ ë¸”ë¡
                html = html.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>');
                html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
                
                // ë¦¬ìŠ¤íŠ¸
                html = html.replace(/^- (.*$)/gim, '<li>$1</li>');
                html = html.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
                
                // í…Œì´ë¸” (ê°„ë‹¨í•œ ì²˜ë¦¬)
                html = html.replace(/\|(.+)\|/g, (match) => {
                    const cells = match.split('|').filter(c => c.trim());
                    if (cells.length > 0) {
                        return '<tr>' + cells.map(c => '<td>' + c.trim() + '</td>').join('') + '</tr>';
                    }
                    return match;
                });
                
                // ë¦¬ìŠ¤íŠ¸ í•­ëª© ì‚¬ì´ì˜ ì¤„ë°”ê¿ˆ ì œê±° (ë¦¬ìŠ¤íŠ¸ ë‚´ë¶€ <br> ì œê±°)
                html = html.replace(/<\/li>\s*<br>\s*<li>/gi, '</li><li>');
                html = html.replace(/<ul>\s*<br>/gi, '<ul>');
                html = html.replace(/<br>\s*<\/ul>/gi, '</ul>');
                
                // ë‹¨ë½
                html = html.replace(/\n\n/g, '</p><p>');
                html = '<p>' + html + '</p>';
                
                // ì¤„ë°”ê¿ˆ (ë¦¬ìŠ¤íŠ¸ ë‚´ë¶€ëŠ” ì´ë¯¸ ì²˜ë¦¬ë¨)
                html = html.replace(/\n/g, '<br>');
                
                // ì•µì»¤ ë§í¬ í´ë¦­ ì‹œ Dashboardë¡œ ì´ë™í•˜ê³  ë¶€ë“œëŸ¬ìš´ ìŠ¤í¬ë¡¤
                setTimeout(() => {
                    document.querySelectorAll('#dashboard-content a[href^="#"]').forEach(link => {
                        link.addEventListener('click', (e) => {
                            e.preventDefault();
                            
                            // Dashboardê°€ ì—´ë ¤ìˆì§€ ì•Šìœ¼ë©´ Dashboardë¡œ ì´ë™
                            const dashboardView = document.getElementById('dashboard-view');
                            const container = document.getElementById('container');
                            if (dashboardView && !dashboardView.classList.contains('active')) {
                                // Info íƒ­ í™œì„±í™”
                                document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                                document.querySelectorAll('.nav-item').forEach(n => {
                                    if (n.textContent.trim() === 'Info') n.classList.add('active');
                                });
                                
                                // Dashboard ë·° í‘œì‹œ
                                if (container) {
                                    container.style.display = 'none';
                                }
                                dashboardView.classList.add('active');
                                
                                // í•˜ë‹¨ íŒ¨ë„ ìˆ¨ê¸°ê¸°
                                const bottomPanel = document.getElementById('bottom-panel');
                                if (bottomPanel) {
                                    bottomPanel.style.display = 'none';
                                }
                            }
                            
                            // í•´ë‹¹ ì„¹ì…˜ìœ¼ë¡œ ìŠ¤í¬ë¡¤
                            const targetId = link.getAttribute('href').substring(1);
                            setTimeout(() => {
                                const targetElement = document.getElementById(targetId);
                                if (targetElement) {
                                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                }
                            }, dashboardView && !dashboardView.classList.contains('active') ? 200 : 0);
                        });
                    });
                }, 100);
                
                return html;
            }

            async showCSVPopup() {
                const popup = document.getElementById('csv-popup');
                const fileList = document.getElementById('csv-file-list');
                const loading = document.getElementById('csv-loading');
                
                if (!popup || !fileList) return;
                
                popup.classList.add('active');
                fileList.innerHTML = '';
                loading.style.display = 'block';
                
                try {
                    // GitHub APIë¡œ CSV íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                    const repo = 'bangilhan/tt_combat_simulation_data';
                    const apiUrl = `https://api.github.com/repos/${repo}/contents`;
                    console.log('GitHub API í˜¸ì¶œ:', apiUrl);
                    
                    const response = await fetch(apiUrl);
                    
                    // ì‘ë‹µ ìƒíƒœ í™•ì¸
                    if (!response.ok) {
                        if (response.status === 404) {
                            loading.style.display = 'none';
                            fileList.innerHTML = `
                                <li style="color: #ff6b6b; padding: 10px;">
                                    <strong>Repositoryë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</strong><br>
                                    <small style="color: #8a8fa5;">
                                        Repository ì´ë¦„: ${repo}<br>
                                        í™•ì¸ ì‚¬í•­:<br>
                                        1. Repositoryê°€ ìƒì„±ë˜ì—ˆëŠ”ì§€ í™•ì¸<br>
                                        2. Repository ì´ë¦„ì´ ì •í™•í•œì§€ í™•ì¸<br>
                                        3. Repositoryê°€ Publicì¸ì§€ í™•ì¸ (Privateì€ ì¸ì¦ í•„ìš”)
                                    </small>
                                </li>
                            `;
                            console.error('Repositoryë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ:', response.status, response.statusText);
                            return;
                        } else if (response.status === 403) {
                            loading.style.display = 'none';
                            fileList.innerHTML = `
                                <li style="color: #ff6b6b; padding: 10px;">
                                    <strong>ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.</strong><br>
                                    <small style="color: #8a8fa5;">
                                        Repositoryê°€ Privateì´ê±°ë‚˜ API rate limitì— ë„ë‹¬í–ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                                    </small>
                                </li>
                            `;
                            console.error('ì ‘ê·¼ ê¶Œí•œ ì—†ìŒ:', response.status, response.statusText);
                            return;
                        } else {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                    }
                    
                    const files = await response.json();
                    console.log('GitHub API ì‘ë‹µ:', files);
                    
                    // ì‘ë‹µì´ ë°°ì—´ì´ ì•„ë‹Œ ê²½ìš° (ì—ëŸ¬ ë©”ì‹œì§€ ë“±)
                    if (!Array.isArray(files)) {
                        loading.style.display = 'none';
                        fileList.innerHTML = `
                            <li style="color: #ff6b6b; padding: 10px;">
                                <strong>ì˜ˆìƒì¹˜ ëª»í•œ ì‘ë‹µ:</strong><br>
                                <small style="color: #8a8fa5;">${JSON.stringify(files)}</small>
                            </li>
                        `;
                        console.error('ì˜ˆìƒì¹˜ ëª»í•œ ì‘ë‹µ í˜•ì‹:', files);
                        return;
                    }
                    
                    // CSV íŒŒì¼ë§Œ í•„í„°ë§
                    let csvFiles = files.filter(file => 
                        file.type === 'file' && file.name.endsWith('.csv')
                    );
                    
                    // tt_aimbot_detection_data.csvë¥¼ ìš°ì„ ìˆœìœ„ë¡œ ì •ë ¬
                    csvFiles.sort((a, b) => {
                        const aIsMain = a.name.includes('tt_aimbot_detection_data');
                        const bIsMain = b.name.includes('tt_aimbot_detection_data');
                        if (aIsMain && !bIsMain) return -1;
                        if (!aIsMain && bIsMain) return 1;
                        // sample íŒŒì¼ì€ ë’¤ë¡œ
                        const aIsSample = a.name.includes('sample');
                        const bIsSample = b.name.includes('sample');
                        if (aIsSample && !bIsSample) return 1;
                        if (!aIsSample && bIsSample) return -1;
                        return a.name.localeCompare(b.name);
                    });
                    
                    console.log('CSV íŒŒì¼ ìˆ˜:', csvFiles.length);
                    console.log('ì •ë ¬ëœ íŒŒì¼ ëª©ë¡:', csvFiles.map(f => f.name));
                    
                    loading.style.display = 'none';
                    
                    if (csvFiles.length === 0) {
                        if (files.length === 0) {
                            fileList.innerHTML = `
                                <li style="color: #8a8fa5; padding: 10px;">
                                    Repositoryê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.<br>
                                    <small>CSV íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.</small>
                                </li>
                            `;
                        } else {
                            fileList.innerHTML = `
                                <li style="color: #8a8fa5; padding: 10px;">
                                    CSV íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.<br>
                                    <small>Repositoryì— ${files.length}ê°œì˜ íŒŒì¼ì´ ìˆì§€ë§Œ CSV íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.</small>
                                </li>
                            `;
                        }
                        return;
                    }
                    
                    // ë‹¨ì¼ íŒŒì¼ ì„ íƒ (ë¼ë””ì˜¤ ë²„íŠ¼ ì‚¬ìš©)
                    this.selectedCSVFile = null;
                    
                    csvFiles.forEach(file => {
                        const li = document.createElement('li');
                        li.style.display = 'flex';
                        li.style.alignItems = 'center';
                        li.style.gap = '10px';
                        li.style.padding = '8px';
                        li.style.cursor = 'pointer';
                        li.style.borderRadius = '4px';
                        li.addEventListener('mouseenter', () => {
                            li.style.background = '#2a2f3e';
                        });
                        li.addEventListener('mouseleave', () => {
                            li.style.background = 'transparent';
                        });
                        
                        const radio = document.createElement('input');
                        radio.type = 'radio';
                        radio.name = 'csv-file-select';
                        radio.value = file.download_url;
                        radio.dataset.filename = file.name;
                        radio.style.cursor = 'pointer';
                        radio.addEventListener('change', (e) => {
                            if (e.target.checked) {
                                this.selectedCSVFile = file.download_url;
                            }
                        });
                        
                        const label = document.createElement('label');
                        label.textContent = file.name;
                        label.style.cursor = 'pointer';
                        label.style.flex = '1';
                        label.addEventListener('click', (e) => {
                            e.preventDefault();
                            radio.checked = true;
                            radio.dispatchEvent(new Event('change'));
                        });
                        
                        li.appendChild(radio);
                        li.appendChild(label);
                        fileList.appendChild(li);
                    });
                    
                    // ì„ íƒí•œ íŒŒì¼ ë¡œë“œ ë²„íŠ¼ ì´ë²¤íŠ¸
                    const loadBtn = document.getElementById('csv-load-selected');
                    if (loadBtn) {
                        loadBtn.onclick = () => {
                            if (!this.selectedCSVFile) {
                                alert('íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                                return;
                            }
                            this.loadSingleCSVFile(this.selectedCSVFile);
                            popup.classList.remove('active');
                        };
                    }
                } catch (error) {
                    console.error('GitHub íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨:', error);
                    loading.style.display = 'none';
                    fileList.innerHTML = `
                        <li style="color: #ff6b6b; padding: 10px;">
                            <strong>ì˜¤ë¥˜ ë°œìƒ:</strong><br>
                            <small style="color: #8a8fa5;">${error.message || error}</small><br>
                            <small style="color: #8a8fa5; margin-top: 5px; display: block;">
                                ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ í™•ì¸í•˜ê±°ë‚˜ ë¸Œë¼ìš°ì € ì½˜ì†”ì„ í™•ì¸í•´ì£¼ì„¸ìš”.
                            </small>
                        </li>
                    `;
                }
            }
            
            async loadSingleCSVFile(fileUrl) {
                const loading = document.getElementById('loading');
                const selectedFile = document.getElementById('selected-file');
                
                if (!fileUrl) {
                    alert('íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                    return;
                }
                
                if (loading) {
                    loading.style.display = 'block';
                    loading.innerHTML = 'GitHubì—ì„œ CSV íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì¤‘...';
                }
                
                try {
                    const response = await fetch(fileUrl);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const text = await response.text();
                    const filename = fileUrl.split('/').pop() || 'unknown.csv';
                    const blob = new Blob([text], { type: 'text/csv' });
                    const file = new File([blob], filename, { type: 'text/csv' });
                    
                    if (selectedFile) {
                        selectedFile.textContent = filename;
                    }
                    
                    await this.loadCSV(file);
                } catch (error) {
                    console.error('CSV íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨:', error);
                    if (loading) {
                        loading.innerHTML = 'ì˜¤ë¥˜: ' + error.message;
                    }
                    alert('CSV íŒŒì¼ì„ ë‹¤ìš´ë¡œë“œí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                }
            }
            
            async loadMultipleCSVFiles() {
                const loading = document.getElementById('loading');
                const selectedFile = document.getElementById('selected-file');
                
                if (!this.selectedCSVFiles || this.selectedCSVFiles.size === 0) {
                    alert('íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                    return;
                }
                
                const fileUrls = Array.from(this.selectedCSVFiles);
                const fileCount = fileUrls.length;
                
                if (loading) {
                    loading.style.display = 'block';
                    loading.innerHTML = `GitHubì—ì„œ ${fileCount}ê°œ CSV íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì¤‘...`;
                }
                
                if (selectedFile) {
                    selectedFile.textContent = `${fileCount}ê°œ íŒŒì¼ ì„ íƒë¨`;
                }
                
                try {
                    // ë‹¨ì¼ íŒŒì¼ì¸ ê²½ìš° ë³‘í•© ì—†ì´ ì§ì ‘ ë¡œë“œ
                    if (fileCount === 1) {
                        const url = fileUrls[0];
                        const response = await fetch(url);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const text = await response.text();
                        const filename = url.split('/').pop() || 'unknown.csv';
                        const blob = new Blob([text], { type: 'text/csv' });
                        const file = new File([blob], filename, { type: 'text/csv' });
                        
                        await this.loadCSV(file);
                        return;
                    }
                    
                    // ì—¬ëŸ¬ íŒŒì¼ì¸ ê²½ìš°ì—ë§Œ ë³‘í•©
                    // ëª¨ë“  íŒŒì¼ì„ ë³‘ë ¬ë¡œ ë‹¤ìš´ë¡œë“œ
                    const filePromises = fileUrls.map(async (url) => {
                        const response = await fetch(url);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const text = await response.text();
                        const filename = url.split('/').pop() || 'unknown.csv';
                        const blob = new Blob([text], { type: 'text/csv' });
                        return new File([blob], filename, { type: 'text/csv' });
                    });
                    
                    const files = await Promise.all(filePromises);
                    
                    // ëª¨ë“  íŒŒì¼ì˜ ë°ì´í„°ë¥¼ ë³‘í•©
                    await this.loadAndMergeMultipleCSV(files);
                } catch (error) {
                    console.error('CSV íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨:', error);
                    if (loading) {
                        loading.innerHTML = 'ì˜¤ë¥˜: ' + error.message;
                    }
                    alert('CSV íŒŒì¼ì„ ë‹¤ìš´ë¡œë“œí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                }
            }
            
            async loadAndMergeMultipleCSV(files) {
                const loading = document.getElementById('loading');
                const allRows = [];
                
                try {
                    // ëª¨ë“  íŒŒì¼ì„ ìˆœì°¨ì ìœ¼ë¡œ íŒŒì‹±
                    for (let i = 0; i < files.length; i++) {
                        if (loading) {
                            loading.innerHTML = `íŒŒì¼ íŒŒì‹± ì¤‘... (${i + 1}/${files.length})`;
                        }
                        
                        const file = files[i];
                        const rows = await new Promise((resolve, reject) => {
                            Papa.parse(file, {
                                header: true,
                                skipEmptyLines: true,
                                complete: (results) => {
                                    resolve(results.data);
                                },
                                error: (error) => {
                                    reject(error);
                                }
                            });
                        });
                        
                        // ìŠ¤í”„ë ˆë“œ ì—°ì‚°ì ëŒ€ì‹  ì§ì ‘ ë£¨í”„ë¡œ ì¶”ê°€ (ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš° ë°©ì§€)
                        for (let j = 0; j < rows.length; j++) {
                            allRows.push(rows[j]);
                        }
                    }
                    
                    if (loading) {
                        loading.innerHTML = 'ë°ì´í„° ë³‘í•© ë° ì²˜ë¦¬ ì¤‘...';
                    }
                    
                    // ëª¨ë“  ë°ì´í„°ë¥¼ ë³‘í•©í•˜ì—¬ ì²˜ë¦¬
                    await this.processData(allRows);
                } catch (error) {
                    console.error('CSV íŒŒì¼ ë³‘í•© ì‹¤íŒ¨:', error);
                    if (loading) {
                        loading.innerHTML = 'ì˜¤ë¥˜: ' + error.message;
                    }
                    alert('CSV íŒŒì¼ì„ ì²˜ë¦¬í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                }
            }

            async loadCSVFromGitHub(url, filename) {
                const loading = document.getElementById('loading');
                const selectedFile = document.getElementById('selected-file');
                
                if (loading) {
                    loading.style.display = 'block';
                    loading.innerHTML = 'GitHubì—ì„œ CSV íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì¤‘...';
                }
                
                if (selectedFile) {
                    selectedFile.textContent = filename;
                }
                
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const text = await response.text();
                    
                    // í…ìŠ¤íŠ¸ë¥¼ Blobìœ¼ë¡œ ë³€í™˜í•˜ì—¬ File ê°ì²´ì²˜ëŸ¼ ì‚¬ìš©
                    const blob = new Blob([text], { type: 'text/csv' });
                    const file = new File([blob], filename, { type: 'text/csv' });
                    
                    await this.loadCSV(file);
                } catch (error) {
                    console.error('CSV íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨:', error);
                    if (loading) {
                        loading.innerHTML = 'ì˜¤ë¥˜: ' + error.message;
                    }
                    alert('CSV íŒŒì¼ì„ ë‹¤ìš´ë¡œë“œí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                }
            }

            setupTabs() {
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        // íƒ­ ì „í™˜
                        const tab = btn.getAttribute('data-tab');
                        if (tab === 'aim') {
                            this.renderAimTrace();
                        } else if (tab === 'actions') {
                            this.updateEventLog();
                        } else {
                            // chat placeholder
                            const eventLog = document.getElementById('event-log');
                            eventLog.innerHTML = '<div style="padding:10px;color:#8a8fa5;">Chat view TBD</div>';
                        }
                    });
                });

                // í¬ì»¤ìŠ¤ ëª¨ë“œ ì¢…ë£Œ ë²„íŠ¼
                document.getElementById('exit-focus-btn').addEventListener('click', () => {
                    this.exitFocusMode();
                });
                
                // ë³´ê³ ì„œ ìƒì„± íƒ­
                document.getElementById('report-tab').addEventListener('click', () => {
                    const playerName = this.selectedPlayer || (this.selectedEvent && this.selectedEvent.attacker && this.selectedEvent.attacker.name) || 
                                    ((this.data && this.data.metadata && this.data.metadata.players && this.data.metadata.players[0]) || null);
                    if (playerName) {
                        this.generateReport(playerName);
                    } else {
                        alert(this.language === 'ko' ? 'ë¨¼ì € í”Œë ˆì´ì–´ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”' : 'Please select a player first');
                    }
                });
                
                // ì–¸ì–´ ì „í™˜ ë²„íŠ¼
                document.getElementById('lang-toggle').addEventListener('click', () => {
                    this.language = this.language === 'ko' ? 'en' : 'ko';
                    this.updateLanguage();
                });
                
                // ì–¸ì–´ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
                this.updateLanguage = () => {
                    const langToggle = document.getElementById('lang-toggle');
                    langToggle.textContent = this.language === 'ko' ? 'ğŸŒ EN' : 'ğŸŒ KO';
                    
                    // UI í…ìŠ¤íŠ¸ ì •ì˜
                    const uiTexts = {
                        ko: {
                            navInfo: 'Info',
                            navSimulation: '3D ì‹œë®¬ë ˆì´ì…˜ ë¶„ì„',
                            navReport: 'ë¶„ì„ ë³´ê³ ì„œ',
                            fileLoad: 'íŒŒì¼ ë¡œë“œ',
                            selectFile: 'íŒŒì¼ ì„ íƒ',
                            noFileSelected: 'ì„ íƒëœ íŒŒì¼ ì—†ìŒ',
                            processing: 'CSV íŒŒì¼ ì²˜ë¦¬ ì¤‘...',
                            statistics: 'í†µê³„',
                            title: 'ì œëª©',
                            name: 'ì´ë¦„',
                            game: 'ê²Œì„',
                            server: 'ì„œë²„',
                            gameMode: 'ê²Œì„ ëª¨ë“œ',
                            startTime: 'ì‹œì‘ ì‹œê°„',
                            length: 'ê¸¸ì´',
                            players: 'í”Œë ˆì´ì–´',
                            match: 'ë§¤ì¹˜',
                            matchStartTime: 'ë§¤ì¹˜ ì‹œì‘ ì‹œê°„',
                            matchLength: 'ë§¤ì¹˜ ê¸¸ì´',
                            matchMode: 'ë§¤ì¹˜ ëª¨ë“œ',
                            mapName: 'ë§µ ì´ë¦„',
                            totalEvents: 'ì´ ì´ë²¤íŠ¸',
                            mapBounds: 'ë§µ ê²½ê³„',
                            calculating: 'ê³„ì‚° ì¤‘...',
                            mapRendering: 'ë§µ ë Œë”ë§ ì •ë³´',
                            currentMap: 'í˜„ì¬ ë§µ',
                            note: 'ì°¸ê³ ',
                            mapGeometry: 'ë§µ ì§€ì˜¤ë©”íŠ¸ë¦¬',
                            mapApi: 'ì™¸ë¶€ ë§µ ë°ì´í„°',
                            kdRatio: 'K/D ë¹„ìœ¨',
                            kdDesc: 'K/D: í‚¬ / ë°ìŠ¤ - í´ë¦­í•˜ì—¬ í•„í„°ë§',
                            killEvents: 'í‚¬ ì´ë²¤íŠ¸ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤',
                            go: 'ì´ë™',
                            resetView: 'ë·° ì´ˆê¸°í™”',
                            prev: 'ì´ì „',
                            next: 'ë‹¤ìŒ',
                            follow: 'ë”°ë¼ê°€ê¸°',
                            focusMode: 'í¬ì»¤ìŠ¤ ëª¨ë“œ: ì´ë²¤íŠ¸ ì„ íƒë¨',
                            exitFocus: 'í¬ì»¤ìŠ¤ ëª¨ë“œ ì¢…ë£Œ',
                            actionStream: 'ì•¡ì…˜ ìŠ¤íŠ¸ë¦¼',
                            matchChat: 'ë§¤ì¹˜ ì±„íŒ…',
                            aimTrace: 'ì—ì„ íŠ¸ë ˆì´ìŠ¤'
                        },
                        en: {
                            navInfo: 'Info',
                            navSimulation: '3D Simulation Analysis',
                            navReport: 'Analysis Report',
                            fileLoad: 'File Load',
                            selectFile: 'Select File',
                            noFileSelected: 'No file selected',
                            processing: 'Processing CSV file...',
                            statistics: 'Statistics',
                            title: 'Title',
                            name: 'Name',
                            game: 'Game',
                            server: 'Server',
                            gameMode: 'Game Mode',
                            startTime: 'Start Time',
                            length: 'Length',
                            players: 'Players',
                            match: 'Match',
                            matchStartTime: 'Match Start Time',
                            matchLength: 'Match Length',
                            matchMode: 'Match Mode',
                            mapName: 'Map Name',
                            totalEvents: 'Total Events',
                            mapBounds: 'Map Bounds',
                            calculating: 'Calculating...',
                            mapRendering: 'Map Rendering Info',
                            currentMap: 'Current Map',
                            note: 'Note',
                            mapGeometry: 'Map Geometry',
                            mapApi: 'External Map Data',
                            kdRatio: 'K/D Ratio',
                            kdDesc: 'K/D: Kills / Deaths - Click to filter',
                            killEvents: 'Kill events will appear here',
                            go: 'Go',
                            resetView: 'Reset View',
                            prev: 'Prev',
                            next: 'Next',
                            follow: 'Follow',
                            focusMode: 'Focus Mode: Event selected',
                            exitFocus: 'Exit Focus Mode',
                            actionStream: 'Action Stream',
                            matchChat: 'Match Chat',
                            aimTrace: 'Aim Trace'
                        }
                    };
                    
                    const t = uiTexts[this.language];
                    
                    // ë„¤ë¹„ê²Œì´ì…˜ ë©”ë‰´ ì—…ë°ì´íŠ¸
                    const navItems = document.querySelectorAll('.nav-item');
                    navItems.forEach(item => {
                        const text = item.textContent.trim();
                        if (text.includes('Info') || item.classList.contains('active') && item.previousElementSibling && item.previousElementSibling.id === 'brand-logo') {
                            // InfoëŠ” ê·¸ëŒ€ë¡œ
                        } else if (text.includes('3D') || text.includes('ì‹œë®¬ë ˆì´ì…˜')) {
                            item.textContent = t.navSimulation;
                        } else if (text.includes('ë¶„ì„ ë³´ê³ ì„œ') || text.includes('Analysis Report')) {
                            item.textContent = t.navReport;
                        }
                    });
                    
                    // ì‚¬ì´ë“œë°” ì—…ë°ì´íŠ¸
                    const sidebarSections = document.querySelectorAll('.sidebar-section h3');
                    sidebarSections.forEach(h3 => {
                        if (h3.textContent.includes('File Load') || h3.textContent.includes('íŒŒì¼ ë¡œë“œ')) {
                            h3.textContent = t.fileLoad;
                        } else if (h3.textContent.includes('Statistics') || h3.textContent.includes('í†µê³„')) {
                            h3.textContent = t.statistics;
                        }
                    });
                    
                    // íŒŒì¼ ì„ íƒ ë²„íŠ¼
                    const selectBtn = document.getElementById('select-csv-btn');
                    if (selectBtn) selectBtn.textContent = t.selectFile;
                    
                    // ì„ íƒëœ íŒŒì¼ ì—†ìŒ
                    const selectedFile = document.getElementById('selected-file');
                    if (selectedFile && selectedFile.textContent.includes('ì„ íƒëœ íŒŒì¼ ì—†ìŒ') || selectedFile.textContent.includes('No file selected')) {
                        if (selectedFile.textContent === 'ì„ íƒëœ íŒŒì¼ ì—†ìŒ' || selectedFile.textContent === 'No file selected') {
                            selectedFile.textContent = t.noFileSelected;
                        }
                    }
                    
                    // ì²˜ë¦¬ ì¤‘
                    const loading = document.getElementById('loading');
                    if (loading) loading.textContent = t.processing;
                    
                    // Statistics ì„¹ì…˜ ì—…ë°ì´íŠ¸
                    const statLabels = document.querySelectorAll('.stat-label');
                    statLabels.forEach(label => {
                        const text = label.textContent.trim();
                        if (text.includes('Name:')) label.textContent = t.name + ':';
                        else if (text.includes('Server:')) label.textContent = t.server + ':';
                        else if (text.includes('Game Mode:')) label.textContent = t.gameMode + ':';
                        else if (text.includes('Start time:')) label.textContent = t.startTime + ':';
                        else if (text.includes('Length:')) label.textContent = t.length + ':';
                        else if (text.includes('Players:')) label.textContent = t.players + ':';
                        else if (text.includes('Match Start Time:')) label.textContent = t.matchStartTime + ':';
                        else if (text.includes('Match Length:')) label.textContent = t.matchLength + ':';
                        else if (text.includes('Match Mode:')) label.textContent = t.matchMode + ':';
                        else if (text.includes('Map Name:')) label.textContent = t.mapName + ':';
                        else if (text.includes('Total Events:')) label.textContent = t.totalEvents + ':';
                    });
                    
                    const statTitles = document.querySelectorAll('.stat-group-title');
                    statTitles.forEach(title => {
                        const text = title.textContent.trim();
                        if (text.includes('Title')) title.textContent = t.title;
                        else if (text.includes('Game')) title.textContent = t.game;
                        else if (text.includes('Match')) title.textContent = t.match;
                        else if (text.includes('Players') || text.includes('K/D')) title.textContent = t.players + ' (' + t.kdRatio + ')';
                        else if (text.includes('Map Bounds') || text.includes('ë§µ ê²½ê³„')) title.textContent = t.mapBounds;
                    });
                    
                    // K/D ì„¤ëª…
                    const kdDesc = document.querySelector('.stat-group-title')?.nextElementSibling;
                    if (kdDesc && kdDesc.style && (kdDesc.textContent.includes('K/D') || kdDesc.textContent.includes('í‚¬'))) {
                        kdDesc.textContent = t.kdDesc;
                    }
                    
                    // ë§µ ì •ë³´ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
                    const mapRenderingLabel = document.getElementById('map-rendering-label');
                    if (mapRenderingLabel) {
                        mapRenderingLabel.textContent = t.mapRendering + ':';
                    }
                    
                    const currentMapText = document.getElementById('current-map-text');
                    const detectedMapNameElement = document.getElementById('detected-map-name');
                    if (currentMapText && detectedMapNameElement) {
                        const mapName = this.data?.metadata?.mapName || this.detectedMapName || 'Unknown';
                        const source = this.detectedMapName ? (this.language === 'ko' ? '(ìœ„ì¹˜ ê¸°ë°˜ ì¶”ë¡ )' : '(Location-based inference)') : 
                                      (this.language === 'ko' ? '(ë°ì´í„° ê¸°ë°˜)' : '(Data-based)');
                        currentMapText.innerHTML = t.currentMap + ': <span id="detected-map-name">' + mapName + ' ' + source + '</span>';
                    } else if (currentMapText) {
                        // fallback
                        const mapName = this.data?.metadata?.mapName || this.detectedMapName || 'Unknown';
                        currentMapText.textContent = t.currentMap + ': ' + mapName;
                    }
                    
                    const mapGeometryText = document.getElementById('map-geometry-text');
                    if (mapGeometryText) {
                        if (this.language === 'ko') {
                            mapGeometryText.textContent = 'ë§µ ì§€ì˜¤ë©”íŠ¸ë¦¬ ë°ì´í„°ëŠ” CS2 ê²Œì„ íŒŒì¼(.bsp)ì—ì„œ ì¶”ì¶œí•˜ê±°ë‚˜';
                        } else {
                            mapGeometryText.textContent = 'Map geometry data must be extracted from CS2 game files (.bsp) or';
                        }
                    }
                    
                    const mapApiText = document.getElementById('map-api-text');
                    if (mapApiText) {
                        if (this.language === 'ko') {
                            mapApiText.textContent = 'ì™¸ë¶€ ë§µ ë°ì´í„° APIë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.';
                        } else {
                            mapApiText.textContent = 'use an external map data API.';
                        }
                    }
                    
                    const mapNoteText = document.getElementById('map-note-text');
                    if (mapNoteText) {
                        if (this.language === 'ko') {
                            mapNoteText.textContent = 'ì°¸ê³ : í˜„ì¬ëŠ” í”Œë ˆì´ì–´ ìœ„ì¹˜ ê¸°ë°˜ ê²½ê³„ë§Œ í‘œì‹œë©ë‹ˆë‹¤.';
                        } else {
                            mapNoteText.textContent = 'Note: Currently only player position-based boundaries are displayed.';
                        }
                    }
                    
                    // Map Bounds í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
                    const mapBoundsTitle = document.getElementById('map-info-title');
                    if (mapBoundsTitle) {
                        mapBoundsTitle.textContent = t.mapBounds;
                    }
                    
                    const mapBoundsText = document.getElementById('map-bounds');
                    if (mapBoundsText && mapBoundsText.textContent.includes('ê³„ì‚° ì¤‘')) {
                        mapBoundsText.textContent = t.calculating;
                    }
                    
                    // ì´ë²¤íŠ¸ í”¼ì»¤ ì—…ë°ì´íŠ¸
                    const killSelect = document.getElementById('kill-select');
                    if (killSelect && killSelect.options[0]) {
                        killSelect.options[0].text = t.killEvents;
                    }
                    
                    const playerSelect = document.getElementById('player-select');
                    if (playerSelect && playerSelect.options[0]) {
                        playerSelect.options[0].text = t.players;
                    }
                    
                    // ë²„íŠ¼ ì—…ë°ì´íŠ¸
                    const goBtn = document.getElementById('go-kill');
                    if (goBtn) goBtn.textContent = t.go;
                    
                    const resetBtn = document.getElementById('reset-view');
                    if (resetBtn) resetBtn.textContent = t.resetView;
                    
                    const prevBtn = document.getElementById('prev-player-tick');
                    if (prevBtn) prevBtn.textContent = t.prev;
                    
                    const nextBtn = document.getElementById('next-player-tick');
                    if (nextBtn) nextBtn.textContent = t.next;
                    
                    const followBtn = document.getElementById('follow-toggle');
                    if (followBtn) followBtn.textContent = t.follow;
                    
                    const exitFocusBtn = document.getElementById('exit-focus-btn');
                    if (exitFocusBtn) exitFocusBtn.textContent = t.exitFocus;
                    
                    const focusInfo = document.getElementById('focus-info');
                    if (focusInfo) focusInfo.textContent = t.focusMode;
                    
                    // í•˜ë‹¨ íŒ¨ë„ íƒ­ ì—…ë°ì´íŠ¸
                    const tabBtns = document.querySelectorAll('.tab-btn');
                    tabBtns.forEach(btn => {
                        const text = btn.textContent.trim();
                        if (text.includes('Action Stream') || text.includes('ì•¡ì…˜ ìŠ¤íŠ¸ë¦¼')) {
                            btn.textContent = t.actionStream;
                        } else if (text.includes('Match Chat') || text.includes('ë§¤ì¹˜ ì±„íŒ…')) {
                            btn.textContent = t.matchChat;
                        } else if (text.includes('Aim Trace') || text.includes('ì—ì„ íŠ¸ë ˆì´ìŠ¤')) {
                            btn.textContent = t.aimTrace;
                        }
                    });
                    
                    // Dashboard/Info íƒ­ ë‚´ìš© ì—…ë°ì´íŠ¸
                    if (document.getElementById('dashboard-view') && !document.getElementById('dashboard-view').classList.contains('hidden')) {
                        this.renderDashboard();
                    }
                    
                    // ë³´ê³ ì„œê°€ ì—´ë ¤ìˆìœ¼ë©´ ì–¸ì–´ ë³€ê²½ í›„ ì¬ìƒì„±
                    if (this.currentReportWindow && !this.currentReportWindow.closed) {
                        const playerName = this.selectedPlayer || (this.selectedEvent && this.selectedEvent.attacker && this.selectedEvent.attacker.name) || 
                                        ((this.data && this.data.metadata && this.data.metadata.players && this.data.metadata.players[0]) || null);
                        if (playerName) {
                            this.currentReportWindow.close();
                            this.generateReport(playerName);
                        }
                    }
                };
            }

            async loadCSV(file) {
                const loading = document.getElementById('loading');
                if (loading) {
                    loading.style.display = 'block';
                    loading.innerHTML = 'Parsing CSV file...';
                }
                
                return new Promise((resolve) => {
                    try {
                        // PapaParse ë¡œë“œ í™•ì¸
                        if (typeof Papa === 'undefined' || !Papa || !Papa.parse) {
                            console.error('PapaParseê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                            if (loading) loading.innerHTML = 'Error: CSV parser not loaded. ë„¤íŠ¸ì›Œí¬ë¥¼ í™•ì¸í•˜ê³  ìƒˆë¡œê³ ì¹¨(Ctrl+F5) í•´ì£¼ì„¸ìš”.';
                            resolve();
                            return;
                        }
                        Papa.parse(file, {
                            header: true,
                            skipEmptyLines: true,
                            complete: async (results) => {
                                console.log('CSV íŒŒì‹± ì™„ë£Œ:', results.data.length, 'ì¤„');
                                console.log('ì²« ë²ˆì§¸ í–‰ ìƒ˜í”Œ:', results.data[0]);
                                
                                if (!results || !results.data || results.data.length === 0) {
                                    console.error('CSV íŒŒì‹± ê²°ê³¼ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤');
                                    alert('CSV íŒŒì¼ì— ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                                    if (loading) loading.style.display = 'none';
                                    resolve();
                                    return;
                                }
                                
                                if (loading) loading.innerHTML = 'Processing data... 0%';
                                try {
                                    await this.processData(results.data);
                                } catch (procError) {
                                    console.error('processData ì˜¤ë¥˜:', procError);
                                    alert('ë°ì´í„° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: ' + procError.message);
                                }
                                if (loading) loading.style.display = 'none';
                                resolve();
                            },
                            error: (error) => {
                                console.error('CSV íŒŒì‹± ì˜¤ë¥˜:', error);
                                if (loading) loading.style.display = 'none';
                                alert('CSV íŒŒì¼ì„ ì½ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                                resolve();
                            }
                        });
                    } catch (error) {
                        console.error('loadCSV ì˜¤ë¥˜:', error);
                        if (loading) loading.style.display = 'none';
                        alert('íŒŒì¼ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                        resolve();
                    }
                });
            }

            async processData(rows) {
                try {
                    console.log('processData ì‹œì‘, ì´ í–‰ ìˆ˜:', rows.length);
                    if (!rows || rows.length === 0) {
                        console.error('ë°ì´í„°ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤');
                        alert('CSV íŒŒì¼ì— ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                        return;
                    }
                    
                    const positions = [];
                    const events = [];
                    const aimIndex = new Map(); // name -> [{yaw,pitch,time,type}]
                    
                    // match_id ì¶”ì¶œ (ì²« ë²ˆì§¸ í–‰ì—ì„œ)
                    let matchId = null;
                    if (rows.length > 0 && rows[0].match_id !== undefined) {
                        matchId = rows[0].match_id !== null ? String(rows[0].match_id).trim() : null;
                    }
                    
                    // ë‚˜ì¤‘ì— ì¡°ì¸ë  ë°ì´í„°ë¥¼ ì €ì¥í•  ë§µ (player_id -> metadata)
                    // CSVì— ì§ì ‘ í¬í•¨ë˜ì–´ ìˆì„ ìˆ˜ë„ ìˆê³ , ë‚˜ì¤‘ì— ì¡°ì¸ë  ìˆ˜ë„ ìˆìŒ
                    const playerJoinData = new Map(); // player_id -> {team, map, os, input_device, character}
                    
                    // ë§µ ê²½ê³„ ì¶”ì ìš© (ë³„ë„ ë°°ì—´ ì—†ì´ ì§ì ‘ ê³„ì‚°)
                    let minX = Infinity, maxX = -Infinity;
                    let minY = Infinity, maxY = -Infinity;
                    let minZ = Infinity, maxZ = -Infinity;
                    
                    let tickData = {};
                    let currentTick = null;
                    
                    const totalRows = rows.length;
                    const chunkSize = 1000; // ì²­í¬ ë‹¨ìœ„ë¡œ ì²˜ë¦¬í•˜ì—¬ UI ì°¨ë‹¨ ë°©ì§€
                    
                    // ì§„í–‰ ìƒí™© í‘œì‹œ
                    const loading = document.getElementById('loading');
                    const updateProgress = (progress) => {
                        if (loading) {
                            loading.style.display = 'block';
                            loading.innerHTML = 'Processing data... ' + Math.round(progress) + '%';
                        }
                    };
                    
                    // ì²­í¬ ë‹¨ìœ„ ì²˜ë¦¬ (ë¹„ë™ê¸°ë¡œ UI ë¸”ë¡œí‚¹ ë°©ì§€)
                    for (let chunkStart = 0; chunkStart < totalRows; chunkStart += chunkSize) {
                        const chunkEnd = Math.min(chunkStart + chunkSize, totalRows);
                        const chunk = rows.slice(chunkStart, chunkEnd);
                        
                        // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
                        updateProgress((chunkStart / totalRows) * 100);
                        
                        // ê° ì²­í¬ë¥¼ ë™ê¸°ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ë˜, í° ì²­í¬ëŠ” ë‚˜ëˆ ì„œ ì²˜ë¦¬
                        for (let i = 0; i < chunk.length; i++) {
                            const row = chunk[i];
                            const rowIdx = chunkStart + i;
                            
                            // ìƒˆë¡œìš´ ë°ì´í„° ìŠ¤í‚¤ë§ˆ: tick í•„ìˆ˜
                            const tickStr = row.tick && row.tick.trim ? row.tick.trim() : (row.tick !== undefined && row.tick !== null ? String(row.tick) : null);
                            if (!tickStr || tickStr === '') continue;
                            
                            const tick = parseInt(tickStr);
                            if (Number.isNaN(tick)) continue;
                            
                            // timestampë¥¼ ì´ˆ ë‹¨ìœ„ë¡œ ë³€í™˜ (ms -> s)
                            const timestampMs = parseFloat(row.timestamp || 0);
                            const gameTime = timestampMs > 0 ? timestampMs / 1000 : 0;
                            
                            // tickì´ ë³€ê²½ë˜ë©´ ì´ì „ tick ë°ì´í„° ì €ì¥
                            if (currentTick !== null && currentTick !== tick && tickData.players && tickData.players.length > 0) {
                                positions.push({
                                    tick: currentTick,
                                    game_time: tickData.game_time || 0,
                                    players: [...tickData.players] // ë°°ì—´ ë³µì‚¬
                                });
                                tickData = { players: [] };
                            }
                            
                            // í˜„ì¬ tick ì„¤ì •
                            if (currentTick === null || currentTick !== tick) {
                                currentTick = tick;
                                tickData.game_time = gameTime;
                            }
                            
                            // í”Œë ˆì´ì–´ ìœ„ì¹˜ ë°ì´í„° ì²˜ë¦¬ (ìƒˆ ìŠ¤í‚¤ë§ˆ: player_id, X, Y, Z)
                            const x = row.X !== undefined && row.X !== null ? String(row.X).trim() : null;
                            const y = row.Y !== undefined && row.Y !== null ? String(row.Y).trim() : null;
                            const z = row.Z !== undefined && row.Z !== null ? String(row.Z).trim() : null;
                            const playerId = row.player_id !== undefined && row.player_id !== null ? String(row.player_id).trim() : null;
                            
                            if (x && y && z && playerId && playerId !== '') {
                                const posX = parseFloat(x);
                                const posY = parseFloat(y);
                                const posZ = parseFloat(z);
                                
                                if (!Number.isNaN(posX) && !Number.isNaN(posY) && !Number.isNaN(posZ)) {
                                // ë§µ ê²½ê³„ ì§ì ‘ ì—…ë°ì´íŠ¸
                                if (posX < minX) minX = posX;
                                if (posX > maxX) maxX = posX;
                                if (posY < minY) minY = posY;
                                if (posY > maxY) maxY = posY;
                                if (posZ < minZ) minZ = posZ;
                                if (posZ > maxZ) maxZ = posZ;
                                
                                tickData.players = tickData.players || [];
                                
                                // yaw, pitch ì •ë³´ ìˆ˜ì§‘
                                const yawStr = row.yaw !== undefined && row.yaw !== null ? String(row.yaw).trim() : null;
                                const pitchStr = row.pitch !== undefined && row.pitch !== null ? String(row.pitch).trim() : null;
                                const yaw = yawStr && yawStr !== '' ? parseFloat(yawStr) : null;
                                const pitch = pitchStr && pitchStr !== '' ? parseFloat(pitchStr) : null;
                                
                                // health ì •ë³´
                                const health = row.health !== undefined && row.health !== null ? parseInt(String(row.health)) : 100;
                                
                                // weapon ì •ë³´ (equipped_weapon_id ë˜ëŠ” event_src_id)
                                const weaponId = row.equipped_weapon_id !== undefined && row.equipped_weapon_id !== null ? 
                                    parseInt(String(row.equipped_weapon_id)) : 
                                    (row.event_src_id !== undefined && row.event_src_id !== null ? parseInt(String(row.event_src_id)) : null);
                                
                                // ì¡°ì¸ ë°ì´í„° í™•ì¸ (CSVì— ì§ì ‘ í¬í•¨ë˜ì–´ ìˆê±°ë‚˜ ë‚˜ì¤‘ì— ì¡°ì¸ë  ìˆ˜ ìˆìŒ)
                                let joinData = playerJoinData.get(playerId);
                                if (!joinData) {
                                    // CSVì—ì„œ ì§ì ‘ ì½ì„ ìˆ˜ ìˆëŠ” ê²½ìš° (ë‚˜ì¤‘ì— ì»¬ëŸ¼ ì¶”ê°€ ì˜ˆì •)
                                    joinData = {
                                        team: row.team || row.team_name || '',
                                        map: row.map || row.map_name || null,
                                        os: row.os || row.os_type || null,
                                        input_device: row.input_device || row.input_device_type || null,
                                        character: row.character || row.character_name || null
                                    };
                                    playerJoinData.set(playerId, joinData);
                                }
                                
                                tickData.players.push({
                                    name: playerId, // player_idë¥¼ nameìœ¼ë¡œ ì‚¬ìš©
                                    team: joinData.team || '', // ì¡°ì¸ëœ íŒ€ ì •ë³´
                                    position: [posX, posZ, posY], // Three.js ì¢Œí‘œê³„: X, Z, Y
                                    health: !Number.isNaN(health) ? health : 100,
                                    round: 1, // ìƒˆ ë°ì´í„°ì—ëŠ” round ì •ë³´ê°€ ì—†ìŒ
                                    weapon: !Number.isNaN(weaponId) ? weaponId : null,
                                    yaw: !Number.isNaN(yaw) ? yaw : null,
                                    pitch: !Number.isNaN(pitch) ? pitch : null,
                                    // ë‚˜ì¤‘ì— ì¡°ì¸ë  ì •ë³´ë“¤
                                    map: joinData.map || null,
                                    os: joinData.os || null,
                                    input_device: joinData.input_device || null,
                                    character: joinData.character || null
                                });
                            }
                        }
                        
                            // ì´ë²¤íŠ¸ ì²˜ë¦¬ (ìƒˆ ìŠ¤í‚¤ë§ˆ: event_type, event_src_player_id, event_trg_player_id)
                            const eventType = row.event_type !== undefined && row.event_type !== null ? parseInt(String(row.event_type)) : null;
                            if (!Number.isNaN(eventType) && eventType > 0) {
                                // event_type: 1:fire, 2:hit, 3:kill
                                let eventTypeStr = '';
                                if (eventType === 1) eventTypeStr = 'fire';
                                else if (eventType === 2) eventTypeStr = 'hit';
                                else if (eventType === 3) eventTypeStr = 'kill';
                                
                                if (eventTypeStr) {
                                    const attackerId = row.event_src_player_id !== undefined && row.event_src_player_id !== null ? 
                                        String(row.event_src_player_id).trim() : null;
                                    const victimId = row.event_trg_player_id !== undefined && row.event_trg_player_id !== null ? 
                                        String(row.event_trg_player_id).trim() : null;
                                    
                                    // í‚¬ ì´ë²¤íŠ¸ ì¤‘ë³µ ì²´í¬ (ìµœê·¼ ì´ë²¤íŠ¸ë§Œ í™•ì¸í•˜ì—¬ ì„±ëŠ¥ ê°œì„ )
                                    let shouldAddEvent = true;
                                    if (eventType === 3 && attackerId && victimId) {
                                        // ìµœê·¼ 10ê°œ ì´ë²¤íŠ¸ë§Œ í™•ì¸ (ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš° ë°©ì§€)
                                        const recentEvents = events.slice(-10);
                                        const existingKill = recentEvents.find(e => 
                                            e.tick === tick && 
                                            e.event_type_lower === 'kill' &&
                                            e.attacker && e.attacker.name === attackerId &&
                                            e.victim && e.victim.name === victimId
                                        );
                                        if (existingKill) {
                                            shouldAddEvent = false;
                                        }
                                    }
                                    
                                    if (shouldAddEvent) {
                                        // ê³µê²©ì ìœ„ì¹˜ ì°¾ê¸° (ê°™ì€ tickì˜ í”Œë ˆì´ì–´ ë°ì´í„°ì—ì„œ)
                                        let attackerPos = [null, null, null];
                                        if (attackerId) {
                                            const attackerPlayer = tickData.players.find(p => p.name === attackerId);
                                            if (attackerPlayer && attackerPlayer.position) {
                                                attackerPos = attackerPlayer.position;
                                            }
                                        }
                                        
                                        // í”¼ê²©ì ìœ„ì¹˜ ì°¾ê¸°
                                        let victimPos = [null, null, null];
                                        if (victimId) {
                                            const victimPlayer = tickData.players.find(p => p.name === victimId);
                                            if (victimPlayer && victimPlayer.position) {
                                                victimPos = victimPlayer.position;
                                            }
                                        }
                                        
                                        // weapon ì •ë³´
                                        const eventWeaponId = row.event_src_id !== undefined && row.event_src_id !== null ? 
                                            parseInt(String(row.event_src_id)) : null;
                                        
                                        // headshot ì •ë³´
                                        const headshot = row.head_shot_yn !== undefined && row.head_shot_yn !== null ? 
                                            (parseInt(String(row.head_shot_yn)) === 1) : false;
                                        
                                        events.push({
                                            tick: tick,
                                            game_time: gameTime,
                                            event_type: eventTypeStr,
                                            event_type_lower: eventTypeStr.toLowerCase(),
                                            attacker: {
                                                name: attackerId,
                                                team: '',
                                                position: attackerPos,
                                                weapon: !Number.isNaN(eventWeaponId) ? eventWeaponId : null
                                            },
                                            victim: {
                                                name: victimId,
                                                team: '',
                                                position: victimPos
                                            },
                                            weapon: !Number.isNaN(eventWeaponId) ? eventWeaponId : null,
                                            headshot: headshot
                                        });
                                        
                                        // í‚¬ ì´ë²¤íŠ¸ì˜ ê³µê²©ì Aim ë°ì´í„° ìˆ˜ì§‘
                                        if (eventType === 3 && attackerId) {
                                            const attackerPlayer = tickData.players.find(p => p.name === attackerId);
                                            if (attackerPlayer && attackerPlayer.yaw !== null && attackerPlayer.pitch !== null) {
                                                if (!aimIndex.has(attackerId)) aimIndex.set(attackerId, []);
                                                const aimArray = aimIndex.get(attackerId);
                                                // ìµœê·¼ 10ê°œë§Œ í™•ì¸í•˜ì—¬ ì„±ëŠ¥ ê°œì„ 
                                                const recentAims = aimArray.slice(-10);
                                                const existingKill = recentAims.find(a => 
                                                    a.type === 'kill' && a.tick === tick && Math.abs(a.time - gameTime) < 0.01
                                                );
                                                if (!existingKill) {
                                                    aimArray.push({ 
                                                        yaw: attackerPlayer.yaw, 
                                                        pitch: attackerPlayer.pitch, 
                                                        time: gameTime, 
                                                        tick: tick, 
                                                        type: 'kill',
                                                        _temp: true
                                                    });
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        // ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸ ë° UI ì°¨ë‹¨ ë°©ì§€
                        updateProgress((chunkEnd / totalRows) * 100);
                        await new Promise(resolve => setTimeout(resolve, 0)); // ë‹¤ìŒ ì´ë²¤íŠ¸ ë£¨í”„ë¡œ
                    }
                    
                    // ë§ˆì§€ë§‰ tick ë°ì´í„° ì €ì¥
                    if (currentTick !== null && tickData.players && tickData.players.length) {
                        positions.push({
                            tick: currentTick,
                            game_time: tickData.game_time || 0,
                            players: tickData.players || []
                        });
                    }
                    
                    console.log('ë°ì´í„° ì²˜ë¦¬ ì™„ë£Œ - Positions:', positions.length, 'ê°œ í‹±');
                    if (positions.length > 0) {
                        console.log('ì²« ë²ˆì§¸ í‹± ìƒ˜í”Œ:', {
                            tick: positions[0].tick,
                            game_time: positions[0].game_time,
                            players_count: positions[0].players.length,
                            first_player: positions[0].players[0] ? {
                                name: positions[0].players[0].name,
                                position: positions[0].players[0].position
                            } : null
                        });
                    }
                    
                    // ë§µ ê²½ê³„ ê³„ì‚° (ì´ë¯¸ ê³„ì‚°ë¨)
                    let detectedMapName = null;
                    if (minX !== Infinity && maxX !== -Infinity) {
                        this.mapBounds = {
                            minX: minX,
                            maxX: maxX,
                            minY: minY,
                            maxY: maxY,
                            minZ: minZ,
                            maxZ: maxZ,
                            centerX: (minX + maxX) / 2,
                            centerY: (minY + maxY) / 2,
                            centerZ: (minZ + maxZ) / 2,
                            width: maxX - minX,
                            height: maxY - minY,
                            depth: maxZ - minZ
                        };
                        
                        // í”Œë ˆì´ì–´ ìœ„ì¹˜ ë²”ìœ„ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë§µ ì¶”ë¡ 
                        detectedMapName = this.detectMapFromBounds(this.mapBounds);
                    }
                    
                    // CSV íŒŒì¼ëª…ì—ì„œ ë§µ ì´ë¦„ ì¶”ì¶œ ì‹œë„
                    const fileName = document.getElementById('selected-file')?.textContent || '';
                    let mapNameFromFile = null;
                    if (fileName && fileName !== 'ì„ íƒëœ íŒŒì¼ ì—†ìŒ' && fileName !== 'No file selected') {
                        // íŒŒì¼ëª…ì—ì„œ ë§µ ì´ë¦„ íŒ¨í„´ ì°¾ê¸° (ì˜ˆ: anubis, dust2, inferno ë“±)
                        const mapPatterns = [
                            'anubis', 'dust2', 'dust_2', 'inferno', 'mirage', 'overpass', 
                            'nuke', 'vertigo', 'ancient', 'cache', 'train', 'cobblestone'
                        ];
                        const fileNameLower = fileName.toLowerCase();
                        for (const map of mapPatterns) {
                            if (fileNameLower.includes(map)) {
                                mapNameFromFile = map.charAt(0).toUpperCase() + map.slice(1).replace('_', '');
                                break;
                            }
                        }
                    }
                    
                    // ìµœì¢… ë§µ ì´ë¦„ ê²°ì • (íŒŒì¼ëª… ìš°ì„ , ì—†ìœ¼ë©´ ìœ„ì¹˜ ê¸°ë°˜ ì¶”ë¡ )
                    const finalMapName = mapNameFromFile || detectedMapName || 'Unknown';
                    this.detectedMapName = finalMapName;
                    
                    const gameTimes = positions.map(p => p.game_time).filter(t => t);
                    const ticks = positions.map(p => p.tick).filter(t => t);
                    const players = new Set();
                    const playerStats = new Map();
                    const playerIndex = new Map();
                    
                    // í”Œë ˆì´ì–´ ì¸ë±ìŠ¤ ë° Aim ë°ì´í„° ìˆ˜ì§‘ (ìµœì í™” - forEach ëŒ€ì‹  for ë£¨í”„)
                    for (let i = 0; i < positions.length; i++) {
                        const p = positions[i];
                        for (let j = 0; j < p.players.length; j++) {
                            const pl = p.players[j];
                            if (pl.name) {
                                players.add(pl.name);
                                if (!playerStats.has(pl.name)) {
                                    // í”Œë ˆì´ì–´ í†µê³„ ì´ˆê¸°í™” (ë‚˜ì¤‘ì— ì¡°ì¸ë  ì •ë³´ë“¤ í¬í•¨)
                                    playerStats.set(pl.name, { 
                                        kills: 0, 
                                        deaths: 0, 
                                        team: pl.team || '',
                                        map: pl.map || null,
                                        os: pl.os || null,
                                        input_device: pl.input_device || null,
                                        character: pl.character || null
                                    });
                                } else {
                                    // ì´ë¯¸ ìˆëŠ” ê²½ìš°ì—ë„ ì¶”ê°€ ì •ë³´ ì—…ë°ì´íŠ¸ (ì²« ë²ˆì§¸ë¡œ ë°œê²¬ëœ ê°’ ì‚¬ìš©)
                                    const stats = playerStats.get(pl.name);
                                    if (!stats.map && pl.map) stats.map = pl.map;
                                    if (!stats.os && pl.os) stats.os = pl.os;
                                    if (!stats.input_device && pl.input_device) stats.input_device = pl.input_device;
                                    if (!stats.character && pl.character) stats.character = pl.character;
                                }
                                if (!playerIndex.has(pl.name)) playerIndex.set(pl.name, []);
                                playerIndex.get(pl.name).push({ tick: p.tick, time: p.game_time, position: pl.position });
                                
                                // Aim ë°ì´í„° ìˆ˜ì§‘ (ëª¨ë“  í‹±ì—ì„œ yaw/pitch)
                                if (pl.yaw !== null && pl.yaw !== undefined && 
                                    pl.pitch !== null && pl.pitch !== undefined) {
                                    if (!aimIndex.has(pl.name)) aimIndex.set(pl.name, []);
                                    aimIndex.get(pl.name).push({ 
                                        yaw: pl.yaw, 
                                        pitch: pl.pitch, 
                                        time: p.game_time, 
                                        tick: p.tick,
                                        type: 'move' 
                                    });
                                }
                            }
                        }
                    }
                    
                    // Kill ì´ë²¤íŠ¸ì˜ aim ë°ì´í„°ë¥¼ move ë°ì´í„°ì™€ ë³‘í•© (ì¼ê´„ ì²˜ë¦¬ - forEach ëŒ€ì‹  for ë£¨í”„)
                    for (const [name, arr] of aimIndex.entries()) {
                        const kills = [];
                        const moves = [];
                        // filter ëŒ€ì‹  ì§ì ‘ ë£¨í”„ë¡œ ë¶„ë¥˜
                        for (let i = 0; i < arr.length; i++) {
                            const a = arr[i];
                            if (a.type === 'kill' && a._temp) {
                                kills.push(a);
                            } else if (a.type === 'move') {
                                moves.push(a);
                            }
                        }
                        
                        // kill íƒ€ì…ì„ ê°™ì€ ì‹œê°„/í‹±ì˜ moveì— ë³‘í•©
                        for (let i = 0; i < kills.length; i++) {
                            const kill = kills[i];
                            let existing = null;
                            for (let j = 0; j < moves.length; j++) {
                                const m = moves[j];
                                if (Math.abs(m.time - kill.time) < 0.01 && m.tick === kill.tick) {
                                    existing = m;
                                    break;
                                }
                            }
                            if (existing) {
                                existing.type = 'kill';
                            }
                        }
                        
                        // ì„ì‹œ kill í•­ëª© ì œê±° (ë³‘í•©ëœ ê²ƒë§Œ ë‚¨ê¹€) - ìŠ¤í”„ë ˆë“œ ì—°ì‚°ì ì œê±°
                        const unmergedKills = [];
                        for (let i = 0; i < kills.length; i++) {
                            const k = kills[i];
                            let exists = false;
                            for (let j = 0; j < moves.length; j++) {
                                const m = moves[j];
                                if (Math.abs(m.time - k.time) < 0.01 && m.tick === k.tick) {
                                    exists = true;
                                    break;
                                }
                            }
                            if (!exists) {
                                unmergedKills.push(k);
                            }
                        }
                        // ìŠ¤í”„ë ˆë“œ ì—°ì‚°ì ëŒ€ì‹  ì§ì ‘ í• ë‹¹
                        arr.length = 0;
                        for (let i = 0; i < moves.length; i++) {
                            arr.push(moves[i]);
                        }
                        for (let i = 0; i < unmergedKills.length; i++) {
                            arr.push(unmergedKills[i]);
                        }
                    }
                    
                    // events ë°°ì—´ ìˆœíšŒ (forEach ëŒ€ì‹  for ë£¨í”„)
                    for (let i = 0; i < events.length; i++) {
                        const e = events[i];
                        if (e.event_type_lower && (e.event_type_lower.includes('kill') || e.event_type_lower.includes('died'))) {
                            if (e.attacker && e.attacker.name) {
                                const stats = playerStats.get(e.attacker.name);
                                if (stats) stats.kills++;
                            }
                            if (e.victim && e.victim.name) {
                                const stats = playerStats.get(e.victim.name);
                                if (stats) stats.deaths++;
                            }
                        }
                    }
                    
                    // í”Œë ˆì´ì–´ë³„ ì¶”ê°€ ë©”íƒ€ë°ì´í„° ìˆ˜ì§‘ (OS, ì…ë ¥ ë””ë°”ì´ìŠ¤, ìºë¦­í„° ë“±)
                    const playerMetadata = new Map();
                    positions.forEach(p => {
                        p.players.forEach(pl => {
                            if (pl.name && !playerMetadata.has(pl.name)) {
                                playerMetadata.set(pl.name, {
                                    team: pl.team || '',
                                    map: pl.map || null,
                                    os: pl.os || null,
                                    input_device: pl.input_device || null,
                                    character: pl.character || null
                                });
                            }
                        });
                    });
                    
                    // ê³ ìœ í•œ íŒ€ ëª©ë¡ ìˆ˜ì§‘
                    const uniqueTeams = new Set();
                    playerStats.forEach(stats => {
                        if (stats.team) uniqueTeams.add(stats.team);
                    });
                    
                    // ê³ ìœ í•œ ë§µ ëª©ë¡ ìˆ˜ì§‘
                    const uniqueMaps = new Set();
                    playerMetadata.forEach(meta => {
                        if (meta.map) uniqueMaps.add(meta.map);
                    });
                    if (this.detectedMapName) uniqueMaps.add(this.detectedMapName);
                    
                    this.data = {
                        metadata: {
                            total_ticks: positions.length,
                            total_events: events.length,
                            time_range: {
                                min: gameTimes.length ? Math.min(...gameTimes) : 0,
                                max: gameTimes.length ? Math.max(...gameTimes) : 0
                            },
                            tick_range: {
                                min: ticks.length ? Math.min(...ticks) : 0,
                                max: ticks.length ? Math.max(...ticks) : 0
                            },
                            players: Array.from(players).sort(),
                            playerStats: Object.fromEntries(playerStats),
                            playerMetadata: Object.fromEntries(playerMetadata), // ì¶”ê°€ ë©”íƒ€ë°ì´í„°
                            teams: Array.from(uniqueTeams).length > 0 ? Array.from(uniqueTeams) : ['CT', 'TERRORIST'], // ë™ì  íŒ€ ëª©ë¡
                            maps: Array.from(uniqueMaps), // ë§µ ëª©ë¡
                            mapName: this.detectedMapName || 'Unknown',
                            // ë‚˜ì¤‘ì— ì¡°ì¸ë  ì •ë³´ë“¤ì„ ìœ„í•œ êµ¬ì¡°
                            matchInfo: {
                                match_id: matchId, // CSVì—ì„œ ì¶”ì¶œí•œ match_id
                                os_distribution: {}, // OSë³„ ë¶„í¬
                                input_device_distribution: {}, // ì…ë ¥ ë””ë°”ì´ìŠ¤ë³„ ë¶„í¬
                                character_distribution: {} // ìºë¦­í„°ë³„ ë¶„í¬
                            }
                        },
                        positions: positions,
                        events: events
                    };
                    
                    // OS, ì…ë ¥ ë””ë°”ì´ìŠ¤, ìºë¦­í„° ë¶„í¬ ê³„ì‚°
                    playerMetadata.forEach(meta => {
                        if (meta.os) {
                            this.data.metadata.matchInfo.os_distribution[meta.os] = 
                                (this.data.metadata.matchInfo.os_distribution[meta.os] || 0) + 1;
                        }
                        if (meta.input_device) {
                            this.data.metadata.matchInfo.input_device_distribution[meta.input_device] = 
                                (this.data.metadata.matchInfo.input_device_distribution[meta.input_device] || 0) + 1;
                        }
                        if (meta.character) {
                            this.data.metadata.matchInfo.character_distribution[meta.character] = 
                                (this.data.metadata.matchInfo.character_distribution[meta.character] || 0) + 1;
                        }
                    });
                    this.playerIndex = playerIndex;
                    // aimIndex ì •ë ¬ (ì‹œê°„ìˆœ)
                    aimIndex.forEach((arr, name) => {
                        arr.sort((a, b) => a.time - b.time);
                    });
                    this.aimIndex = aimIndex;
                    
                    // window.simulationì— ì¸ìŠ¤í„´ìŠ¤ í• ë‹¹ (ë””ë²„ê¹…ìš©)
                    window.simulation = this;
                    
                    console.log('ë°ì´í„° ì²˜ë¦¬ ì™„ë£Œ:', this.data.metadata);
                    console.log('ë§µ ê²½ê³„:', this.mapBounds);
                    console.log('Positions ìˆ˜:', positions.length);
                    console.log('Events ìˆ˜:', events.length);
                    console.log('ë¡œë“œëœ ë°ì´í„°:', window.simulation?.data?.metadata);
                    console.log('Match ID:', matchId);
                    console.log('ì¡°ì¸ ë°ì´í„° ì¤€ë¹„ ì™„ë£Œ (íŒ€, ë§µ, OS, ì…ë ¥ë””ë°”ì´ìŠ¤, ìºë¦­í„°)');
                    
                    if (positions.length === 0) {
                        console.error('Positionsê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤. ë°ì´í„° í¬ë§·ì„ í™•ì¸í•˜ì„¸ìš”.');
                        alert('ë°ì´í„°ë¥¼ ì²˜ë¦¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. CSV íŒŒì¼ í¬ë§·ì„ í™•ì¸í•˜ì„¸ìš”.');
                        return;
                    }
                    
                    this.updateUI();
                    this.setupMapBounds();
                    // setupMapBounds() ì´í›„ì— ê²½ë¡œ ë Œë”ë§ (baseCameraDistance ì„¤ì • í›„)
                    this.analyzeAndRenderPaths();
                    this.populateKillPicker();
                    this.populatePlayerPicker();
                    
                    // íŒŒì¼ ë¡œë“œ í›„ 3D ì‹œë®¬ë ˆì´ì…˜ ë¶„ì„ íƒ­ìœ¼ë¡œ ìë™ ì „í™˜
                    this.showInvestigate();
                    
                    // ì‹œë®¬ë ˆì´ì…˜ ë Œë”ë§ ì´ˆê¸°í™”
                    setTimeout(() => {
                        console.log('=== ì´ˆê¸° ë Œë”ë§ ì‹œì‘ ===');
                        console.log('Positions ìˆ˜:', this.data.positions.length);
                        console.log('ì²« ë²ˆì§¸ í‹± ë°ì´í„°:', this.data.positions[0]);
                        console.log('ì²« ë²ˆì§¸ í‹± í”Œë ˆì´ì–´ ìˆ˜:', this.data.positions[0]?.players?.length || 0);
                        console.log('ë§µ ê²½ê³„:', this.mapBounds);
                        console.log('ì¹´ë©”ë¼ ìœ„ì¹˜:', { x: this.camera.position.x, y: this.camera.position.y, z: this.camera.position.z });
                        console.log('ì”¬ ì˜¤ë¸Œì íŠ¸ ìˆ˜:', this.scene.children.length);
                        
                        // í…ŒìŠ¤íŠ¸: ì›ì ì— ë¹¨ê°„ êµ¬ì²´ ì¶”ê°€ (ë Œë”ë§ì´ ì‘ë™í•˜ëŠ”ì§€ í™•ì¸)
                        const testGeometry = new THREE.SphereGeometry(50, 16, 16);
                        const testMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 1.0 });
                        const testSphere = new THREE.Mesh(testGeometry, testMaterial);
                        testSphere.position.set(0, 0, 0);
                        this.scene.add(testSphere);
                        console.log('í…ŒìŠ¤íŠ¸ êµ¬ì²´ ì¶”ê°€ë¨ (ì›ì , ë¹¨ê°„ìƒ‰)');
                        
                        // ë§µ ê²½ê³„ ì¤‘ì‹¬ì— ë…¸ë€ êµ¬ì²´ ì¶”ê°€
                        if (this.mapBounds) {
                            const centerGeometry = new THREE.SphereGeometry(100, 16, 16);
                            const centerMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1.0 });
                            const centerSphere = new THREE.Mesh(centerGeometry, centerMaterial);
                            centerSphere.position.set(this.mapBounds.centerX, this.mapBounds.centerZ, this.mapBounds.centerY);
                            this.scene.add(centerSphere);
                            console.log('ë§µ ì¤‘ì‹¬ êµ¬ì²´ ì¶”ê°€ë¨ (ë…¸ë€ìƒ‰):', {
                                x: this.mapBounds.centerX,
                                y: this.mapBounds.centerZ,
                                z: this.mapBounds.centerY
                            });
                        }
                        
                        // ë¨¼ì € ëª¨ë“  í”Œë ˆì´ì–´ì˜ ê²½ë¡œë¥¼ ë¼ì¸ìœ¼ë¡œ ê·¸ë ¤ì„œ ì‹œê°í™”
                        this.renderAllPlayerPaths();
                        
                        // ê·¸ ë‹¤ìŒ ìºë¦­í„° ë Œë”ë§
                        this.renderTick(0);
                        
                        console.log('ë Œë”ë§ í›„ ì”¬ ì˜¤ë¸Œì íŠ¸ ìˆ˜:', this.scene.children.length);
                        console.log('í”Œë ˆì´ì–´ ì˜¤ë¸Œì íŠ¸ ìˆ˜:', this.playerObjects.size);
                        
                        // renderer í¬ê¸° ì¬ì¡°ì • (containerê°€ ìˆ¨ê²¨ì ¸ ìˆì„ ìˆ˜ ìˆìŒ)
                        const container = document.getElementById('canvas-container');
                        if (container && this.renderer) {
                            const width = container.clientWidth;
                            const height = container.clientHeight;
                            if (width > 0 && height > 0) {
                                this.camera.aspect = width / height;
                                this.camera.updateProjectionMatrix();
                                this.renderer.setSize(width, height);
                                console.log('Renderer í¬ê¸° ì„¤ì •:', width, 'x', height);
                            }
                        }
                    }, 100);
                } catch (error) {
                    console.error('processData ì˜¤ë¥˜:', error);
                    alert('ë°ì´í„° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                    const loading = document.getElementById('loading');
                    if (loading) loading.style.display = 'none';
                }
            }
            
            /**
             * ë‚˜ì¤‘ì— ì¡°ì¸ë  ë°ì´í„°ë¥¼ ì¶”ê°€í•˜ëŠ” í•¨ìˆ˜
             * @param {Object} joinData - player_idë¥¼ í‚¤ë¡œ í•˜ëŠ” ì¡°ì¸ ë°ì´í„° ê°ì²´
             * @example
             * enrichPlayerData({
             *   "-479": { team: "Team A", os: "Windows", input_device: "keyboard_mouse", character: "Character1" },
             *   "-481": { team: "Team B", os: "Mac", input_device: "console", character: "Character2" }
             * })
             */
            enrichPlayerData(joinData) {
                if (!this.data || !joinData) return;
                
                console.log('í”Œë ˆì´ì–´ ë°ì´í„° ì¡°ì¸ ì‹œì‘:', joinData);
                
                // ê° í‹±ì˜ í”Œë ˆì´ì–´ ë°ì´í„° ì—…ë°ì´íŠ¸
                this.data.positions.forEach(tickData => {
                    tickData.players.forEach(player => {
                        const joinInfo = joinData[player.name];
                        if (joinInfo) {
                            if (joinInfo.team !== undefined) player.team = joinInfo.team;
                            if (joinInfo.map !== undefined) player.map = joinInfo.map;
                            if (joinInfo.os !== undefined) player.os = joinInfo.os;
                            if (joinInfo.input_device !== undefined) player.input_device = joinInfo.input_device;
                            if (joinInfo.character !== undefined) player.character = joinInfo.character;
                        }
                    });
                });
                
                // ë©”íƒ€ë°ì´í„° ì—…ë°ì´íŠ¸
                Object.keys(joinData).forEach(playerId => {
                    if (this.data.metadata.playerMetadata[playerId]) {
                        Object.assign(this.data.metadata.playerMetadata[playerId], joinData[playerId]);
                    } else {
                        this.data.metadata.playerMetadata[playerId] = joinData[playerId];
                    }
                    
                    // playerStatsë„ ì—…ë°ì´íŠ¸
                    if (this.data.metadata.playerStats[playerId]) {
                        if (joinData[playerId].team !== undefined) {
                            this.data.metadata.playerStats[playerId].team = joinData[playerId].team;
                        }
                    }
                });
                
                // íŒ€ ëª©ë¡ ì¬ìˆ˜ì§‘
                const uniqueTeams = new Set();
                Object.values(this.data.metadata.playerStats).forEach(stats => {
                    if (stats.team) uniqueTeams.add(stats.team);
                });
                this.data.metadata.teams = Array.from(uniqueTeams).length > 0 ? Array.from(uniqueTeams) : ['CT', 'TERRORIST'];
                
                // ë§µ ëª©ë¡ ì¬ìˆ˜ì§‘
                const uniqueMaps = new Set();
                Object.values(this.data.metadata.playerMetadata).forEach(meta => {
                    if (meta.map) uniqueMaps.add(meta.map);
                });
                if (this.detectedMapName) uniqueMaps.add(this.detectedMapName);
                this.data.metadata.maps = Array.from(uniqueMaps);
                
                // ë¶„í¬ ì¬ê³„ì‚°
                this.recalculateDistributions();
                
                // UI ì—…ë°ì´íŠ¸
                this.updateUI();
                this.populatePlayerPicker();
                
                console.log('í”Œë ˆì´ì–´ ë°ì´í„° ì¡°ì¸ ì™„ë£Œ');
            }
            
            /**
             * OS, ì…ë ¥ ë””ë°”ì´ìŠ¤, ìºë¦­í„° ë¶„í¬ë¥¼ ì¬ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜
             */
            recalculateDistributions() {
                if (!this.data) return;
                
                const osDist = {};
                const inputDeviceDist = {};
                const characterDist = {};
                
                Object.values(this.data.metadata.playerMetadata).forEach(meta => {
                    if (meta.os) {
                        osDist[meta.os] = (osDist[meta.os] || 0) + 1;
                    }
                    if (meta.input_device) {
                        inputDeviceDist[meta.input_device] = (inputDeviceDist[meta.input_device] || 0) + 1;
                    }
                    if (meta.character) {
                        characterDist[meta.character] = (characterDist[meta.character] || 0) + 1;
                    }
                });
                
                this.data.metadata.matchInfo.os_distribution = osDist;
                this.data.metadata.matchInfo.input_device_distribution = inputDeviceDist;
                this.data.metadata.matchInfo.character_distribution = characterDist;
                
                console.log('ë¶„í¬ ì¬ê³„ì‚° ì™„ë£Œ:', {
                    os: osDist,
                    input_device: inputDeviceDist,
                    character: characterDist
                });
            }

            renderAimTrace() {
                const container = document.getElementById('event-log');
                container.innerHTML = '';
                const canvas = document.createElement('canvas');
                canvas.width = container.clientWidth - 20;
                canvas.height = container.clientHeight - 20;
                canvas.style.background = '#0a0e15';
                canvas.style.border = '1px solid #2a2f3e';
                container.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                const W = canvas.width;
                const H = canvas.height;

                // Focus ëª¨ë“œê°€ ì•„ë‹ˆë©´ ë©”ì‹œì§€ í‘œì‹œ
                if (!this.focusMode || !this.focusTickRange) {
                    ctx.fillStyle = '#8a8fa5';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Aim TraceëŠ” Focus ëª¨ë“œì—ì„œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.', W/2, H/2);
                    ctx.fillText('í‚¬ ì´ë²¤íŠ¸ë¥¼ ì„ íƒí•˜ì—¬ Focus ëª¨ë“œë¥¼ í™œì„±í™”í•˜ì„¸ìš”.', W/2, H/2 + 30);
                    return;
                }

                // ì„ íƒëœ í”Œë ˆì´ì–´ ìš°ì„ ìˆœìœ„: í¬ì»¤ìŠ¤ ëª¨ë“œì¼ ë•ŒëŠ” ë°˜ë“œì‹œ ê³µê²©ì -> ì„ íƒëœ í”Œë ˆì´ì–´ -> ì²« ë²ˆì§¸
                let name = null;
                if (this.focusMode && this.selectedEvent && this.selectedEvent.attacker && this.selectedEvent.attacker.name) {
                    // í¬ì»¤ìŠ¤ ëª¨ë“œì¼ ë•ŒëŠ” ë¬´ì¡°ê±´ ê³µê²©ìë¥¼ í‘œì‹œ
                    name = this.selectedEvent.attacker.name;
                    console.log('Aim Trace - í¬ì»¤ìŠ¤ ëª¨ë“œ: ê³µê²©ì', name, 'ì˜ aim trace í‘œì‹œ');
                } else if (this.selectedEvent && this.selectedEvent.attacker && this.selectedEvent.attacker.name) {
                    name = this.selectedEvent.attacker.name;
                } else {
                    name = this.selectedPlayer || ((this.data && this.data.metadata && this.data.metadata.players && this.data.metadata.players[0]) || null);
                }
                
                // ì‹¤ì œ ë°ì´í„°ì—ì„œ Aim ì •ë³´ ìˆ˜ì§‘
                let samples = [];
                if (name && this.data) {
                    console.log('Aim Trace - í”Œë ˆì´ì–´:', name);
                    
                    // í¬ì»¤ìŠ¤ ëª¨ë“œì¼ ë•ŒëŠ” í‹± ì¸ë±ìŠ¤ ë²”ìœ„ë¡œ ì§ì ‘ ìˆ˜ì§‘ (ëª¨ë“  í‹±, ëˆ„ì )
                    if (this.focusMode && this.focusTickRange) {
                        console.log('Aim Trace - í¬ì»¤ìŠ¤ ëª¨ë“œ: í‹± ë²”ìœ„', this.focusTickRange.startIdx, '-', this.focusTickRange.endIdx, 'ì´', (this.focusTickRange.endIdx - this.focusTickRange.startIdx + 1), 'í‹±');
                        let foundCount = 0;
                        let missingCount = 0;
                        let lastYaw = null;
                        let lastPitch = null;
                        
                        // ì²« ë²ˆì§¸ ìœ íš¨í•œ ê°’ì„ ì°¾ê¸° ìœ„í•´ ì—­ë°©í–¥ìœ¼ë¡œë„ ê²€ìƒ‰
                        for (let idx = this.focusTickRange.startIdx - 1; idx >= 0 && idx >= this.focusTickRange.startIdx - 10; idx--) {
                            const pos = this.data.positions[idx];
                            if (pos) {
                                const player = pos.players.find(p => p.name === name);
                                if (player && player.yaw !== null && player.yaw !== undefined && !Number.isNaN(player.yaw) &&
                                    player.pitch !== null && player.pitch !== undefined && !Number.isNaN(player.pitch)) {
                                    lastYaw = player.yaw;
                                    lastPitch = player.pitch;
                                    break;
                                }
                            }
                        }
                        
                        // ëª¨ë“  í‹±ì„ ìˆœíšŒí•˜ë©´ì„œ ì‹¤ì œ ë°ì´í„°ê°€ ìˆëŠ” í‹±ë§Œ ìˆ˜ì§‘ (ì¤‘ë³µ ì œê±°)
                        for (let idx = this.focusTickRange.startIdx; idx <= this.focusTickRange.endIdx; idx++) {
                            const pos = this.data.positions[idx];
                            if (pos) {
                                const player = pos.players.find(p => p.name === name);
                                if (player) {
                                    const yaw = player.yaw;
                                    const pitch = player.pitch;
                                    
                                    // ì‹¤ì œ ë°ì´í„°ê°€ ìˆëŠ” ê²½ìš°ë§Œ ì¶”ê°€ (ë³´ê°„ ì—†ì´)
                                    if (yaw !== null && yaw !== undefined && !Number.isNaN(yaw) &&
                                        pitch !== null && pitch !== undefined && !Number.isNaN(pitch)) {
                                        // ì´ì „ ìƒ˜í”Œê³¼ ê°’ì´ ë‹¤ë¥¼ ë•Œë§Œ ì¶”ê°€ (ì¤‘ë³µ ì œê±°)
                                        if (lastYaw === null || lastPitch === null || 
                                            Math.abs(yaw - lastYaw) > 0.01 || Math.abs(pitch - lastPitch) > 0.01) {
                                            samples.push({
                                                yaw: yaw,
                                                pitch: pitch,
                                                time: pos.game_time,
                                                tick: pos.tick,
                                                tickIdx: idx, // í‹± ì¸ë±ìŠ¤ ëª…ì‹œì  ì €ì¥
                                                type: 'move'
                                            });
                                            lastYaw = yaw;
                                            lastPitch = pitch;
                                            foundCount++;
                                        } else {
                                            // ê°™ì€ ê°’ì´ë©´ ìŠ¤í‚µ (ì¤‘ë³µ ì œê±°)
                                            missingCount++;
                                        }
                                    } else {
                                        missingCount++;
                                    }
                                } else {
                                    missingCount++;
                                }
                            }
                        }
                        console.log('Aim Trace - í¬ì»¤ìŠ¤ ëª¨ë“œ ìˆ˜ì§‘:', foundCount, 'ê³ ìœ  ìƒ˜í”Œ, ì¤‘ë³µ/ì—†ìŒ:', missingCount, '/ ì „ì²´ í‹±:', (this.focusTickRange.endIdx - this.focusTickRange.startIdx + 1));
                        console.log('Aim Trace - í¬ì»¤ìŠ¤ ëª¨ë“œ ë²”ìœ„:', this.focusTickRange.startIdx, '~', this.focusTickRange.endIdx, 'í‹±');
                    } else {
                        // ì¼ë°˜ ëª¨ë“œ: ì „ì²´ positionsì—ì„œ ìˆ˜ì§‘ (ì¤‘ë³µ ì œê±° í¬í•¨)
                        let foundCount = 0;
                        let missingCount = 0;
                        let lastYaw = null;
                        let lastPitch = null;
                        this.data.positions.forEach(pos => {
                            const player = pos.players.find(p => p.name === name);
                            if (player) {
                                // yaw/pitch í™•ì¸ (null ì²´í¬ ë° ìœ íš¨ì„± ê²€ì‚¬)
                                const yaw = player.yaw;
                                const pitch = player.pitch;
                                if (yaw !== null && yaw !== undefined && !Number.isNaN(yaw) &&
                                    pitch !== null && pitch !== undefined && !Number.isNaN(pitch)) {
                                    // ì´ì „ ìƒ˜í”Œê³¼ ê°’ì´ ë‹¤ë¥¼ ë•Œë§Œ ì¶”ê°€ (ì¤‘ë³µ ì œê±°)
                                    if (lastYaw === null || lastPitch === null || 
                                        Math.abs(yaw - lastYaw) > 0.01 || Math.abs(pitch - lastPitch) > 0.01) {
                                        samples.push({
                                            yaw: yaw,
                                            pitch: pitch,
                                            time: pos.game_time,
                                            tick: pos.tick,
                                            type: 'move'
                                        });
                                        lastYaw = yaw;
                                        lastPitch = pitch;
                                        foundCount++;
                                    } else {
                                        missingCount++;
                                    }
                                } else {
                                    missingCount++;
                                }
                            } else {
                                missingCount++;
                            }
                        });
                        console.log('Aim Trace - ì¼ë°˜ ëª¨ë“œ ìˆ˜ì§‘:', foundCount, 'ê³ ìœ  ìƒ˜í”Œ, ì¤‘ë³µ/ì—†ìŒ:', missingCount, '/ ì „ì²´:', this.data.positions.length);
                    }
                    
                    // í‚¬ ì´ë²¤íŠ¸ì—ì„œ kill íƒ€ì… ë§ˆí‚¹ (ì¤‘ë³µ ì œê±° ê°•í™”)
                    if (this.aimIndex && this.aimIndex.has(name)) {
                        let killPoints = this.aimIndex.get(name).filter(a => a.type === 'kill');

                        // í¬ì»¤ìŠ¤ ëª¨ë“œì—ì„œëŠ” ì„ íƒëœ ì´ë²¤íŠ¸ì˜ í‚¬ë§Œ í‘œì‹œ (ì¤‘ë³µ ë¶‰ì€ ì  ë°©ì§€)
                        if (this.focusMode && this.selectedEvent && this.selectedEvent.tick !== undefined) {
                            const focusTick = this.selectedEvent.tick;
                            const focusVictim = this.selectedEvent.victim ? this.selectedEvent.victim.name : null;
                            killPoints = killPoints.filter(kp => {
                                if (kp.tick !== focusTick) return false;
                                // victim ì •ë³´ê°€ ìˆìœ¼ë©´ ì¼ì¹˜í•˜ëŠ” ê²½ìš°ë§Œ í‘œì‹œ
                                return focusVictim ? true : true;
                            });
                        }
                        console.log('Aim Trace - Kill í¬ì¸íŠ¸ ìˆ˜ (ì¤‘ë³µ ì œê±° ì „):', killPoints.length);
                        
                        // ì¤‘ë³µ ì œê±°: ê°™ì€ tickì˜ í‚¬ì€ í•˜ë‚˜ë§Œ ë‚¨ê¹€
                        const uniqueKillPoints = [];
                        const seenTicks = new Set();
                        killPoints.forEach(kp => {
                            if (!seenTicks.has(kp.tick)) {
                                seenTicks.add(kp.tick);
                                uniqueKillPoints.push(kp);
                            }
                        });
                        
                        console.log('Aim Trace - Kill í¬ì¸íŠ¸ ìˆ˜ (ì¤‘ë³µ ì œê±° í›„):', uniqueKillPoints.length);
                        
                        uniqueKillPoints.forEach(kp => {
                            const existing = samples.find(s => 
                                Math.abs(s.time - kp.time) < 0.01 && s.tick === kp.tick
                            );
                            if (existing) {
                                existing.type = 'kill';
                            } else {
                                samples.push(kp);
                            }
                        });
                    }
                    
                    samples.sort((a, b) => a.time - b.time);
                    console.log('Aim Trace - ìµœì¢… ìƒ˜í”Œ ìˆ˜:', samples.length);
                    
                    // ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ê²½ê³ 
                    if (samples.length === 0) {
                        console.warn('Aim Trace - ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. í”Œë ˆì´ì–´:', name);
                    }
                } else {
                    console.warn('Aim Trace - í”Œë ˆì´ì–´ ì´ë¦„ ë˜ëŠ” ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                }

                // í˜„ì¬ ì¬ìƒ êµ¬ê°„ - í¬ì»¤ìŠ¤ ëª¨ë“œì¼ ë•ŒëŠ” í¬ì»¤ìŠ¤ ë²”ìœ„ ì‚¬ìš©
                let tStart, tEnd;
                if (this.focusMode && this.focusTickRange) {
                    // í¬ì»¤ìŠ¤ ëª¨ë“œ: ì„ íƒëœ ì´ë²¤íŠ¸ ì „í›„ Â±30í‹± ë²”ìœ„
                    tStart = this.data.positions[this.focusTickRange.startIdx].game_time;
                    tEnd = this.data.positions[this.focusTickRange.endIdx].game_time;
                    console.log('Aim Trace - í¬ì»¤ìŠ¤ ëª¨ë“œ ë²”ìœ„:', tStart.toFixed(2), '-', tEnd.toFixed(2), 'ë²”ìœ„:', (tEnd - tStart).toFixed(2), 'ì´ˆ');
                } else {
                    const endIdx = this.currentTick;
                    // ë” ë„“ì€ ë²”ìœ„: ìµœê·¼ 300í‹± ë˜ëŠ” 5ì´ˆ
                    const startIdx = Math.max(0, endIdx - 300);
                    tStart = (this.data.positions[startIdx] && this.data.positions[startIdx].game_time != null) ? this.data.positions[startIdx].game_time : 0;
                    const currentTime = (this.data.positions[endIdx] && this.data.positions[endIdx].game_time != null) ? this.data.positions[endIdx].game_time : tStart;
                    tEnd = currentTime;
                    // ìµœì†Œ 5ì´ˆ ë²”ìœ„ ë³´ì¥
                    if (tEnd - tStart < 5) {
                        tStart = Math.max(0, tEnd - 5);
                    }
                }
                const currentTime = (this.data.positions[this.currentTick] && this.data.positions[this.currentTick].game_time != null) ? this.data.positions[this.currentTick].game_time : tStart;
                
                // í¬ì»¤ìŠ¤ ëª¨ë“œì¼ ë•ŒëŠ” ì¬ìƒ ì¤‘ì´ë©´ í˜„ì¬ í‹±ê¹Œì§€ ëˆ„ì , ì•„ë‹ˆë©´ ì „ì²´ í‘œì‹œ
                // ì¼ë°˜ ëª¨ë“œì¼ ë•Œë§Œ ì‹œê°„ ë²”ìœ„ë¡œ í•„í„°ë§
                let windowSamples;
                if (this.focusMode && this.focusTickRange) {
                    // í¬ì»¤ìŠ¤ ëª¨ë“œ: ì¬ìƒ ì¤‘ì´ë©´ í˜„ì¬ í‹±ê¹Œì§€ ëˆ„ì  í‘œì‹œ (í‹± ì¸ë±ìŠ¤ ê¸°ë°˜)
                    const currentTickIdx = this.currentTick;
                    const startTickIdx = this.focusTickRange.startIdx;
                    
                    // í¬ì»¤ìŠ¤ ëª¨ë“œì—ì„œëŠ” í•­ìƒ ì „ì²´ ìƒ˜í”Œ í‘œì‹œ (ëˆ„ì )
                    // ì¬ìƒ ì¤‘ì´ë©´ í˜„ì¬ í‹±ê¹Œì§€ë§Œ í‘œì‹œí•˜ë„ë¡ ì˜µì…˜ ì œê³µ
                    if (this.isPlaying && currentTickIdx > startTickIdx) {
                        // ì¬ìƒ ì¤‘: í˜„ì¬ í‹±ê¹Œì§€ì˜ ìƒ˜í”Œë§Œ í‘œì‹œ (ìˆœì°¨ì  ëˆ„ì )
                        windowSamples = samples.filter(s => {
                            // tickIdxê°€ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ positionsì—ì„œ ì°¾ê¸°
                            let sampleTickIdx = s.tickIdx;
                            if (sampleTickIdx === undefined) {
                                sampleTickIdx = this.data.positions.findIndex(p => p.tick === s.tick);
                            }
                            return sampleTickIdx !== -1 && sampleTickIdx <= currentTickIdx && sampleTickIdx >= startTickIdx;
                        });
                        console.log('Aim Trace - í¬ì»¤ìŠ¤ ëª¨ë“œ (ì¬ìƒ ì¤‘): í‹±', startTickIdx, '~', currentTickIdx, 'ê¹Œì§€', windowSamples.length, 'ìƒ˜í”Œ ëˆ„ì  (ì „ì²´ samples:', samples.length, ')');
                    } else {
                        // ì •ì§€ ìƒíƒœë©´ ì „ì²´ í‘œì‹œ (ëª¨ë“  ìƒ˜í”Œ)
                        windowSamples = samples;
                        console.log('Aim Trace - í¬ì»¤ìŠ¤ ëª¨ë“œ (ì •ì§€): ì „ì²´', windowSamples.length, 'ìƒ˜í”Œ í‘œì‹œ');
                    }
                } else {
                    // ì¼ë°˜ ëª¨ë“œ: ì‹œê°„ ë²”ìœ„ë¡œ í•„í„°ë§
                    windowSamples = samples.filter(s => s.time >= tStart && s.time <= tEnd);
                }
                
                console.log('Aim Trace - ìœˆë„ìš° ìƒ˜í”Œ ìˆ˜:', windowSamples.length, 'ì‹œê°„ ë²”ìœ„:', tStart.toFixed(2), '-', tEnd.toFixed(2), 'ë²”ìœ„:', (tEnd - tStart).toFixed(2), 'ì´ˆ');
                console.log('Aim Trace - ìƒ˜í”Œ yaw ë²”ìœ„:', windowSamples.length > 0 ? [Math.min(...windowSamples.map(s => s.yaw)).toFixed(2), Math.max(...windowSamples.map(s => s.yaw)).toFixed(2)] : 'ì—†ìŒ');
                console.log('Aim Trace - ìƒ˜í”Œ pitch ë²”ìœ„:', windowSamples.length > 0 ? [Math.min(...windowSamples.map(s => s.pitch)).toFixed(2), Math.max(...windowSamples.map(s => s.pitch)).toFixed(2)] : 'ì—†ìŒ');
                
                // ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ë©”ì‹œì§€ í‘œì‹œ
                if (samples.length === 0) {
                    ctx.fillStyle = '#8a8fa5';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('No aim data available for ' + (name || 'selected player'), W/2, H/2);
                    ctx.textAlign = 'left';
                    return;
                }
                
                if (windowSamples.length === 0) {
                    ctx.fillStyle = '#8a8fa5';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('No data in current time window', W/2, H/2);
                    ctx.textAlign = 'left';
                    return;
                }

                // ì‹¤ì œ ë°ì´í„° ë²”ìœ„ ê³„ì‚° (ë™ì  ìŠ¤ì¼€ì¼ë§)
                const yaws = windowSamples.map(s => s.yaw).filter(v => !Number.isNaN(v));
                const pitches = windowSamples.map(s => s.pitch).filter(v => !Number.isNaN(v));
                
                let xMin, xMax, yMin, yMax;
                if (yaws.length > 0 && pitches.length > 0) {
                    const yawMin = Math.min(...yaws);
                    const yawMax = Math.max(...yaws);
                    const pitchMin = Math.min(...pitches);
                    const pitchMax = Math.max(...pitches);
                    
                    const yawRange = yawMax - yawMin;
                    const pitchRange = pitchMax - pitchMin;
                    
                    // ë²”ìœ„ê°€ ë§¤ìš° ì¢ìœ¼ë©´ (10ë„ ì´í•˜) í™•ëŒ€, ì•„ë‹ˆë©´ ì „ì²´ ë²”ìœ„ ì‚¬ìš©
                    if (yawRange < 10 && pitchRange < 10) {
                        // í™•ëŒ€: ì¤‘ì•™ ê¸°ì¤€ìœ¼ë¡œ Â±20ë„ ë²”ìœ„
                        const yawCenter = (yawMin + yawMax) / 2;
                        const pitchCenter = (pitchMin + pitchMax) / 2;
                        xMin = yawCenter - 20;
                        xMax = yawCenter + 20;
                        yMin = pitchCenter - 20;
                        yMax = pitchCenter + 20;
                        console.log('Aim Trace - í™•ëŒ€ ëª¨ë“œ:', {yawCenter, pitchCenter, range: 'Â±20Â°'});
                    } else {
                        // ì—¬ë°± ì¶”ê°€ (10% padding)
                        const yawPadding = Math.max(yawRange * 0.1, 5);
                        const pitchPadding = Math.max(pitchRange * 0.1, 5);
                        xMin = yawMin - yawPadding;
                        xMax = yawMax + yawPadding;
                        yMin = pitchMin - pitchPadding;
                        yMax = pitchMax + pitchPadding;
                        console.log('Aim Trace - ë™ì  ë²”ìœ„:', {yaw: [xMin, xMax], pitch: [yMin, yMax]});
                    }
                } else {
                    // ê¸°ë³¸ ë²”ìœ„
                    xMin = -180; xMax = 180; yMin = -90; yMax = 90;
                }
                
                console.log('Aim Trace - ì¢Œí‘œ ë²”ìœ„:', {yaw: [xMin.toFixed(1), xMax.toFixed(1)], pitch: [yMin.toFixed(1), yMax.toFixed(1)]});
                
                const pad = 40;
                
                function xScale(v){ return pad + (v - xMin) / (xMax - xMin) * (W - 2*pad); }
                function yScale(v){ return H - (pad + (v - yMin) / (yMax - yMin) * (H - 2*pad)); }

                // ë°°ê²½ ê·¸ë¦¬ë“œ (ë™ì  ë²”ìœ„ì— ë§ì¶°)
                ctx.strokeStyle = '#2a2f3e'; ctx.lineWidth = 1;
                const gridStepX = Math.max(1, Math.ceil((xMax - xMin) / 20)); // ì•½ 20ê°œ ê·¸ë¦¬ë“œ
                const gridStepY = Math.max(1, Math.ceil((yMax - yMin) / 15)); // ì•½ 15ê°œ ê·¸ë¦¬ë“œ
                
                for (let x = Math.floor(xMin / gridStepX) * gridStepX; x <= xMax; x += gridStepX) {
                    const sx = xScale(x);
                    if (sx >= pad && sx <= W - pad) {
                        ctx.beginPath(); ctx.moveTo(sx, pad); ctx.lineTo(sx, H - pad); ctx.stroke();
                    }
                }
                for (let y = Math.floor(yMin / gridStepY) * gridStepY; y <= yMax; y += gridStepY) {
                    const sy = yScale(y);
                    if (sy >= pad && sy <= H - pad) {
                        ctx.beginPath(); ctx.moveTo(pad, sy); ctx.lineTo(W - pad, sy); ctx.stroke();
                    }
                }
                
                // ì¶• ë¼ë²¨ (ë²”ìœ„ í‘œì‹œ)
                ctx.fillStyle = '#8a8fa5'; ctx.font = '12px Arial';
                ctx.fillText(`Yaw (Â°) [${xMin.toFixed(1)} ~ ${xMax.toFixed(1)}]`, W/2 - 80, H-10);
                ctx.save(); ctx.translate(10, H/2); ctx.rotate(-Math.PI/2); 
                ctx.fillText(`Pitch (Â°) [${yMin.toFixed(1)} ~ ${yMax.toFixed(1)}]`, 0, 0); ctx.restore();

                // ëª¨ë“  í¬ì¸íŠ¸ í‘œì‹œ (ëˆ„ì  ì´ë™ ê²½ë¡œ) - ê³ ìœ í•œ ê°’ë§Œ í‘œì‹œ
                console.log('Aim Trace - ë Œë”ë§í•  í¬ì¸íŠ¸ ìˆ˜:', windowSamples.length);
                
                // ì¤‘ë³µ ì œê±°: ì—°ì†ëœ ê°™ì€ ê°’ ì œê±° (ë¨¼ì € ìƒì„±)
                const uniqueSamples = [];
                let lastRenderedYaw = null;
                let lastRenderedPitch = null;
                
                windowSamples.forEach((s, idx) => {
                    // ê°’ì´ ë³€ê²½ë˜ì—ˆê±°ë‚˜ ì²« ë²ˆì§¸ ìƒ˜í”Œì´ë©´ ì¶”ê°€
                    if (lastRenderedYaw === null || lastRenderedPitch === null ||
                        Math.abs(s.yaw - lastRenderedYaw) > 0.01 || Math.abs(s.pitch - lastRenderedPitch) > 0.01) {
                        uniqueSamples.push(s);
                        lastRenderedYaw = s.yaw;
                        lastRenderedPitch = s.pitch;
                    }
                });
                
                console.log('Aim Trace - ì¤‘ë³µ ì œê±° í›„ ê³ ìœ  í¬ì¸íŠ¸ ìˆ˜:', uniqueSamples.length, '/', windowSamples.length);

                // ê²½ë¡œ ì—°ê²°ì„  (ê¸°ë³¸ íšŒìƒ‰) - ê³ ìœ  í¬ì¸íŠ¸ë§Œ ì—°ê²°
                if (uniqueSamples.length > 1){
                    ctx.beginPath();
                    ctx.strokeStyle = '#5a637a'; ctx.lineWidth = 1.5;
                    let firstPoint = true;
                    for (let i = 0; i < uniqueSamples.length; i++) {
                        const s = uniqueSamples[i];
                        const x = xScale(s.yaw);
                        const y = yScale(s.pitch);
                        if (firstPoint) {
                            ctx.moveTo(x, y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                }
                
                // í¬ì¸íŠ¸ ë Œë”ë§
                if (uniqueSamples.length === 0) {
                    console.warn('Aim Trace - ë Œë”ë§í•  ê³ ìœ  í¬ì¸íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. windowSamples:', windowSamples.length);
                } else {
                    console.log('Aim Trace - ë Œë”ë§ ì‹œì‘: ê³ ìœ  í¬ì¸íŠ¸', uniqueSamples.length, 'ê°œ');
                }
                
                uniqueSamples.forEach((s, idx) => {
                    const x = xScale(s.yaw);
                    const y = yScale(s.pitch);
                    
                    // ìº”ë²„ìŠ¤ ë²”ìœ„ ì²´í¬
                    if (x < 0 || x > W || y < 0 || y > H) {
                        if (idx < 3) {
                            console.warn(`í¬ì¸íŠ¸ ${idx}ê°€ ìº”ë²„ìŠ¤ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¨: canvas(${x.toFixed(1)}, ${y.toFixed(1)})`);
                        }
                        return; // ë²”ìœ„ë¥¼ ë²—ì–´ë‚œ í¬ì¸íŠ¸ëŠ” ìŠ¤í‚µ
                    }
                    
                    // ë””ë²„ê¹…: ì²˜ìŒ 3ê°œì™€ ë§ˆì§€ë§‰ 3ê°œ í¬ì¸íŠ¸ë§Œ ë¡œê·¸
                    if (idx < 3 || idx >= uniqueSamples.length - 3) {
                        console.log(`ê³ ìœ  í¬ì¸íŠ¸ ${idx}/${uniqueSamples.length}: yaw=${s.yaw.toFixed(2)}, pitch=${s.pitch.toFixed(2)}, canvas(${x.toFixed(1)}, ${y.toFixed(1)})`);
                    }
                    
                    if (s.type === 'kill') {
                        // Kill ì‹œì : ì§„ë¹¨ê°• í° ì› + í…Œë‘ë¦¬
                        ctx.fillStyle = '#cc0000';
                        ctx.beginPath(); ctx.arc(x, y, 5, 0, Math.PI*2); ctx.fill();
                        ctx.strokeStyle = '#ff3333'; ctx.lineWidth = 2; ctx.stroke();
                    } else {
                        // ì¼ë°˜ ì´ë™ í¬ì¸íŠ¸: ì‘ì€ íšŒìƒ‰ ì  (ëª¨ë‘ í‘œì‹œ)
                        ctx.fillStyle = '#8a8fa5';
                        ctx.beginPath(); ctx.arc(x, y, 2, 0, Math.PI*2); ctx.fill();
                    }
                });

                // í˜„ì¬ í‹±ì˜ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ í•˜ì´ë¼ì´íŠ¸ (íŒŒë‘ í° ì ) - ê³ ìœ  ìƒ˜í”Œì—ì„œ ì°¾ê¸°
                const curr = uniqueSamples.reduce((prev, s) => {
                    const prevDiff = prev ? Math.abs(s.time - currentTime) : Infinity;
                    const currDiff = Math.abs(s.time - currentTime);
                    return currDiff < prevDiff ? s : prev;
                }, null);
                if (curr) {
                    const cx = xScale(curr.yaw), cy = yScale(curr.pitch);
                    ctx.fillStyle = '#4a90e2';
                    ctx.beginPath(); ctx.arc(cx, cy, 6, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 2; ctx.stroke();
                }

                // ë²”ë¡€
                const legend = [
                    {label:'Current', color:'#4a90e2'},
                    {label:'Kill', color:'#cc0000'}
                ];
                let lx = pad, ly = pad-12;
                legend.forEach(l =>{
                    ctx.fillStyle = l.color; ctx.beginPath(); ctx.arc(lx,ly,4,0,Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#8a8fa5'; ctx.fillText(l.label, lx+10, ly+4);
                    lx += 80;
                });

                // ì œëª© ë° ê±°ë¦¬ ì •ë³´
                ctx.fillStyle = '#ffffff'; ctx.font = '14px Arial';
                let titleText = `Aim Trace - ${name || 'N/A'}`;
                
                // í‚¬ ì´ë²¤íŠ¸ê°€ ìˆìœ¼ë©´ ë¬´ê¸° ì •ë³´ ë° êµì „ ê±°ë¦¬ ì¶”ê°€
                let engagementDistance = null;
                if (this.selectedEvent && this.selectedEvent.attacker && this.selectedEvent.victim) {
                    // ë¬´ê¸° ì •ë³´ ì¶”ê°€
                    if (this.selectedEvent.weapon) {
                        titleText += ` | ë¬´ê¸°: ${this.selectedEvent.weapon}`;
                    }
                    
                    // êµì „ ê±°ë¦¬ ì •ë³´ ì¶”ê°€
                    const attackerPos = this.selectedEvent.attacker.position;
                    const victimPos = this.selectedEvent.victim.position;
                    if (attackerPos && victimPos && attackerPos[0] !== null && victimPos[0] !== null) {
                        // 3D ìœ í´ë¦¬ë“œ ê±°ë¦¬ ê³„ì‚° (Source ì—”ì§„ ì¢Œí‘œê³„)
                        // position ë°°ì—´: [X, Z, Y] (X: ì¢Œìš°, Y: ì „í›„, Z: ë†’ì´)
                        const dx = attackerPos[0] - victimPos[0]; // X ì°¨ì´
                        const dy = attackerPos[1] - victimPos[1]; // Z ì°¨ì´ (ë†’ì´)
                        const dz = attackerPos[2] - victimPos[2]; // Y ì°¨ì´ (ì „í›„)
                        const distanceUnits = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        
                        // Source ì—”ì§„ ë‹¨ìœ„ ë³€í™˜: 1 unit = 0.75 ì¸ì¹˜ = ì•½ 1.905 cm
                        // ë˜ëŠ” 1 unit = 1 ì¸ì¹˜ = 2.54 cm (ì¼ë¶€ ê²Œì„)
                        // CS:GO/CS2 ê¸°ì¤€: 1 unit = 0.75 ì¸ì¹˜ = 1.905 cm
                        const distanceMeters = distanceUnits * 0.75 * 2.54 / 100; // ë¯¸í„°ë¡œ ë³€í™˜
                        const distanceFeet = distanceUnits * 0.75 / 12; // í”¼íŠ¸ë¡œ ë³€í™˜
                        
                        engagementDistance = distanceUnits;
                        titleText += ` | êµì „ ê±°ë¦¬: ${distanceUnits.toFixed(1)} units (${distanceMeters.toFixed(2)}m / ${distanceFeet.toFixed(1)}ft)`;
                    }
                }
                
                ctx.fillText(titleText, pad, 20);
                
                // ì¶”ê°€ ë¶„ì„ ì •ë³´ í‘œì‹œ (ì„ì˜ ê°’)
                if (this.selectedEvent && this.selectedEvent.weapon) {
                    let yOffset = 45;
                    ctx.font = '12px Arial';
                    ctx.fillStyle = '#8a8fa5';
                    
                    // ë¬´ê¸° ìœ íš¨ ì‚¬ê±°ë¦¬ ë° KILL ìœ íš¨ì„±
                    const weaponEffectiveRange = 500; // ì„ì˜ ê°’ (units)
                    const killValidity = engagementDistance ? (engagementDistance <= weaponEffectiveRange ? 'ìœ íš¨' : 'ë¹„ìœ íš¨') : 'N/A';
                    const validityColor = killValidity === 'ìœ íš¨' ? '#4caf50' : '#ff6b6b';
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(`ë¬´ê¸° ìœ íš¨ ì‚¬ê±°ë¦¬: ${weaponEffectiveRange} units`, pad, yOffset);
                    yOffset += 18;
                    
                    ctx.fillStyle = validityColor;
                    ctx.fillText(`êµì „ ê±°ë¦¬ ë° KILL ìœ íš¨ì„±: ${killValidity}`, pad, yOffset);
                    yOffset += 18;
                    
                    // ì›”í•µ íƒì§€
                    const wallhackDetected = Math.random() > 0.7 ? 'ì˜ì‹¬' : 'ì •ìƒ'; // ì„ì˜ ê°’
                    const wallhackColor = wallhackDetected === 'ì˜ì‹¬' ? '#ff6b6b' : '#4caf50';
                    ctx.fillStyle = wallhackColor;
                    ctx.fillText(`ë²½ ê´€í†µ íƒì§€ (ì›”í•µ): ${wallhackDetected}`, pad, yOffset);
                    yOffset += 18;
                    
                    // AIM ì´ë™ íŒ¨í„´ ì´ìƒ ì ìˆ˜
                    const aimAnomalyScore = (Math.random() * 100).toFixed(1); // ì„ì˜ ê°’ (0-100)
                    const anomalyColor = parseFloat(aimAnomalyScore) > 70 ? '#ff6b6b' : (parseFloat(aimAnomalyScore) > 40 ? '#ffa500' : '#4caf50');
                    ctx.fillStyle = anomalyColor;
                    ctx.fillText(`AIM ì´ë™ íŒ¨í„´ ì´ìƒ ì ìˆ˜: ${aimAnomalyScore}`, pad, yOffset);
                }
            }

            generateReport(playerName) {
                if (!this.data || !playerName) return;
                
                const stats = this.data.metadata.playerStats[playerName] || { kills: 0, deaths: 0, team: '' };
                // í”Œë ˆì´ì–´ê°€ í‚¬í•œ ì´ë²¤íŠ¸ë§Œ í•„í„°ë§ (ì¤‘ë³µ ì œê±°)
                let playerKills = this.data.events.filter(e => 
                    e.attacker && e.attacker.name === playerName &&
                    e.event_type_lower && e.event_type_lower.includes('kill')
                );
                
                // ê°™ì€ tickì˜ ì¤‘ë³µ í‚¬ ì œê±°
                const seenTicks = new Set();
                playerKills = playerKills.filter(e => {
                    if (seenTicks.has(e.tick)) {
                        return false;
                    }
                    seenTicks.add(e.tick);
                    return true;
                });
                
                console.log('Generate Report - í”Œë ˆì´ì–´ í‚¬ ìˆ˜ (ì¤‘ë³µ ì œê±° í›„):', playerKills.length);
                
                // ê° í‚¬ ì´ë²¤íŠ¸ë³„ë¡œ Aim Trace ìƒì„± (Â±30í‹± ë²”ìœ„)
                const killTraceImages = [];
                
                playerKills.forEach((killEvent, killIdx) => {
                    // í‚¬ ì´ë²¤íŠ¸ì˜ í‹± ì¸ë±ìŠ¤ ì°¾ê¸°
                    const killTickIdx = this.data.positions.findIndex(p => p.tick === killEvent.tick);
                    if (killTickIdx === -1) return;
                    
                    // Â±30í‹± ë²”ìœ„ ê³„ì‚°
                    const startIdx = Math.max(0, killTickIdx - 30);
                    const endIdx = Math.min(this.data.positions.length - 1, killTickIdx + 30);
                    
                    // í•´ë‹¹ ë²”ìœ„ì˜ Aim ë°ì´í„° ìˆ˜ì§‘
                    const killAimData = [];
                    for (let idx = startIdx; idx <= endIdx; idx++) {
                        const pos = this.data.positions[idx];
                        if (pos) {
                            const player = pos.players.find(p => p.name === playerName);
                            if (player && player.yaw !== null && player.yaw !== undefined && !Number.isNaN(player.yaw) &&
                                player.pitch !== null && player.pitch !== undefined && !Number.isNaN(player.pitch)) {
                                killAimData.push({
                                    yaw: player.yaw,
                                    pitch: player.pitch,
                                    time: pos.game_time,
                                    tick: pos.tick,
                                    tickIdx: idx,
                                    type: idx === killTickIdx ? 'kill' : 'move'
                                });
                            }
                        }
                    }
                    
                    if (killAimData.length === 0) return;
                    
                    // ì¤‘ë³µ ì œê±° (ì—°ì†ëœ ê°™ì€ ê°’)
                    const uniqueKillAimData = [];
                    let lastYaw = null;
                    let lastPitch = null;
                    killAimData.forEach(s => {
                        if (lastYaw === null || lastPitch === null ||
                            Math.abs(s.yaw - lastYaw) > 0.01 || Math.abs(s.pitch - lastPitch) > 0.01) {
                            uniqueKillAimData.push(s);
                            lastYaw = s.yaw;
                            lastPitch = s.pitch;
                        }
                    });
                    
                    // Aim Trace ìº”ë²„ìŠ¤ ìƒì„±
                    const killTraceCanvas = document.createElement('canvas');
                    killTraceCanvas.width = 800;
                    killTraceCanvas.height = 600;
                    const killCtx = killTraceCanvas.getContext('2d');
                    
                    // ë™ì  ë²”ìœ„ ê³„ì‚°
                    const yaws = uniqueKillAimData.map(s => s.yaw);
                    const pitches = uniqueKillAimData.map(s => s.pitch);
                    let xMin = Math.min(...yaws);
                    let xMax = Math.max(...yaws);
                    let yMin = Math.min(...pitches);
                    let yMax = Math.max(...pitches);
                    
                    // ë²”ìœ„ê°€ ë„ˆë¬´ ì¢ìœ¼ë©´ í™•ëŒ€
                    const xRange = xMax - xMin;
                    const yRange = yMax - yMin;
                    if (xRange < 10) {
                        const center = (xMin + xMax) / 2;
                        xMin = center - 10;
                        xMax = center + 10;
                    }
                    if (yRange < 10) {
                        const center = (yMin + yMax) / 2;
                        yMin = center - 10;
                        yMax = center + 10;
                    }
                    
                    // íŒ¨ë”© ì¶”ê°€
                    const xPadding = (xMax - xMin) * 0.1;
                    const yPadding = (yMax - yMin) * 0.1;
                    xMin -= xPadding;
                    xMax += xPadding;
                    yMin -= yPadding;
                    yMax += yPadding;
                    
                    const pad = 40;
                    const W = killTraceCanvas.width, H = killTraceCanvas.height;
                    
                    function xScale(v){ return pad + (v - xMin) / (xMax - xMin) * (W - 2*pad); }
                    function yScale(v){ return H - (pad + (v - yMin) / (yMax - yMin) * (H - 2*pad)); }
                    
                    // ë°°ê²½
                    killCtx.fillStyle = '#0a0e15';
                    killCtx.fillRect(0, 0, W, H);
                    
                    // ê·¸ë¦¬ë“œ
                    killCtx.strokeStyle = '#2a2f3e';
                    killCtx.lineWidth = 1;
                    const xStep = Math.max(10, Math.ceil((xMax - xMin) / 10));
                    const yStep = Math.max(5, Math.ceil((yMax - yMin) / 10));
                    for (let x = Math.floor(xMin / xStep) * xStep; x <= xMax; x += xStep) {
                        const sx = xScale(x);
                        if (sx >= pad && sx <= W - pad) {
                            killCtx.beginPath();
                            killCtx.moveTo(sx, pad);
                            killCtx.lineTo(sx, H - pad);
                            killCtx.stroke();
                        }
                    }
                    for (let y = Math.floor(yMin / yStep) * yStep; y <= yMax; y += yStep) {
                        const sy = yScale(y);
                        if (sy >= pad && sy <= H - pad) {
                            killCtx.beginPath();
                            killCtx.moveTo(pad, sy);
                            killCtx.lineTo(W - pad, sy);
                            killCtx.stroke();
                        }
                    }
                    
                    // ê²½ë¡œ ì—°ê²°ì„ 
                    if (uniqueKillAimData.length > 1) {
                        killCtx.beginPath();
                        killCtx.strokeStyle = '#5a637a';
                        killCtx.lineWidth = 1.5;
                        killCtx.moveTo(xScale(uniqueKillAimData[0].yaw), yScale(uniqueKillAimData[0].pitch));
                        for (let i = 1; i < uniqueKillAimData.length; i++) {
                            killCtx.lineTo(xScale(uniqueKillAimData[i].yaw), yScale(uniqueKillAimData[i].pitch));
                        }
                        killCtx.stroke();
                    }
                    
                    // í¬ì¸íŠ¸
                    uniqueKillAimData.forEach(s => {
                        const x = xScale(s.yaw), y = yScale(s.pitch);
                        if (s.type === 'kill') {
                            // Kill ì‹œì : ì§„ë¹¨ê°• í° ì› + í…Œë‘ë¦¬
                            killCtx.fillStyle = '#cc0000';
                            killCtx.beginPath();
                            killCtx.arc(x, y, 5, 0, Math.PI*2);
                            killCtx.fill();
                            killCtx.strokeStyle = '#ff3333';
                            killCtx.lineWidth = 2;
                            killCtx.stroke();
                        } else {
                            // ì¼ë°˜ ì´ë™ í¬ì¸íŠ¸: ì‘ì€ íšŒìƒ‰ ì 
                            killCtx.fillStyle = '#8a8fa5';
                            killCtx.beginPath();
                            killCtx.arc(x, y, 2, 0, Math.PI*2);
                            killCtx.fill();
                        }
                    });
                    
                    // ì œëª© ë° ì •ë³´
                    killCtx.fillStyle = '#ffffff';
                    killCtx.font = 'bold 16px Arial';
                    killCtx.fillText(`Kill #${killIdx + 1} - ${killEvent.victim ? killEvent.victim.name : 'Unknown'}`, pad, 25);
                    killCtx.font = '12px Arial';
                    killCtx.fillStyle = '#8a8fa5';
                    const timeStr = killEvent.game_time ? `${Math.floor(killEvent.game_time / 60)}:${(killEvent.game_time % 60).toFixed(2)}` : 'N/A';
                    killCtx.fillText(`Time: ${timeStr} | Tick: ${killEvent.tick}`, pad, 45);
                    killCtx.fillText(`Yaw: [${xMin.toFixed(1)} ~ ${xMax.toFixed(1)}] Pitch: [${yMin.toFixed(1)} ~ ${yMax.toFixed(1)}]`, pad, H - 15);
                    
                    killTraceImages.push({
                        image: killTraceCanvas.toDataURL('image/png'),
                        killNum: killIdx + 1,
                        victim: killEvent.victim ? killEvent.victim.name : 'Unknown',
                        time: timeStr
                    });
                });
                
                // ëª¨ë“  í‚¬ íŠ¸ë ˆì´ìŠ¤ë¥¼ í•˜ë‚˜ì˜ ì´ë¯¸ì§€ë¡œ í•©ì¹˜ê¸° (ì„¸ë¡œë¡œ ë°°ì¹˜) - ë¹„ë™ê¸° ì²˜ë¦¬
                const generateCombinedImage = () => {
                    return new Promise((resolve) => {
                        if (killTraceImages.length === 0) {
                            resolve('');
                            return;
                        }
                        
                        const combinedCanvas = document.createElement('canvas');
                        const traceHeight = 600;
                        const traceSpacing = 20;
                        combinedCanvas.width = 800;
                        combinedCanvas.height = killTraceImages.length * (traceHeight + traceSpacing) - traceSpacing;
                        const combinedCtx = combinedCanvas.getContext('2d');
                        
                        combinedCtx.fillStyle = '#1a1f2e';
                        combinedCtx.fillRect(0, 0, combinedCanvas.width, combinedCanvas.height);
                        
                        let loadedCount = 0;
                        killTraceImages.forEach((trace, idx) => {
                            const img = new Image();
                            img.onload = () => {
                                const y = idx * (traceHeight + traceSpacing);
                                combinedCtx.drawImage(img, 0, y);
                                loadedCount++;
                                if (loadedCount === killTraceImages.length) {
                                    resolve(combinedCanvas.toDataURL('image/png'));
                                }
                            };
                            img.onerror = () => {
                                loadedCount++;
                                if (loadedCount === killTraceImages.length) {
                                    resolve(combinedCanvas.toDataURL('image/png'));
                                }
                            };
                            img.src = trace.image;
                        });
                    });
                };
                
                // ë³´ê³ ì„œ ìƒì„± (ì´ë¯¸ì§€ ë¡œë”© ëŒ€ê¸°)
                generateCombinedImage().then(combinedAimTraceImage => {
                
                    // ì–¸ì–´ë³„ í…ìŠ¤íŠ¸ ì •ì˜
                    const texts = {
                        ko: {
                            title: 'í”Œë ˆì´ì–´ ë³´ê³ ì„œ',
                            generated: 'ìƒì„± ì‹œê°„',
                            userInfo: 'ìœ ì € ê¸°ë³¸ ì •ë³´',
                            deviceType: 'ê¸°ê¸° ì‚¬ìš© íƒ€ì…',
                            kdRatio: 'K/D ë¹„ìœ¨',
                            headshotRate: 'í—¤ë“œìƒ· ë¹„ìœ¨',
                            matchStats: 'ë§¤ì¹˜ í†µê³„',
                            team: 'íŒ€',
                            kills: 'í‚¬',
                            deaths: 'ë°ìŠ¤',
                            totalKills: 'ì´ í‚¬ ìˆ˜',
                            killTraces: 'í‚¬ ê¶¤ì ',
                            killEvents: 'í‚¬ ì´ë²¤íŠ¸',
                            time: 'ì‹œê°„',
                            event: 'ì´ë²¤íŠ¸',
                            victim: 'í”¼í•´ì',
                            weapon: 'ë¬´ê¸°',
                            headshot: 'í—¤ë“œìƒ·',
                            kill: 'í‚¬',
                            death: 'ë°ìŠ¤',
                            yes: 'ì˜ˆ',
                            no: 'ì•„ë‹ˆì˜¤',
                            aimAnalysis: 'ì—ì„ ì´ë™ ë¶„ì„ - í‚¬ ì´ë²¤íŠ¸',
                            totalKillsCount: 'ì´ í‚¬ ìˆ˜',
                            tracesGenerated: 'ìƒì„±ëœ í‚¬ ê¶¤ì ',
                            individualTraces: 'ê°œë³„ í‚¬ ì—ì„ ê¶¤ì  (ê° í‚¬ ì£¼ë³€ Â±30 í‹±)',
                            killNum: 'í‚¬ #',
                            noKillEvents: 'ì—ì„ ë°ì´í„°ê°€ ìˆëŠ” í‚¬ ì´ë²¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤',
                            download: 'ë‹¤ìš´ë¡œë“œ'
                        },
                        en: {
                            title: 'Player Report',
                            generated: 'Generated',
                            userInfo: 'User Basic Information',
                            deviceType: 'Device Type',
                            kdRatio: 'K/D Ratio',
                            headshotRate: 'Headshot Rate',
                            matchStats: 'Match Statistics',
                            team: 'Team',
                            kills: 'Kills',
                            deaths: 'Deaths',
                            totalKills: 'Total Kills',
                            killTraces: 'Kill Traces',
                            killEvents: 'Kill Events',
                            time: 'Time',
                            event: 'Event',
                            victim: 'Victim',
                            weapon: 'Weapon',
                            headshot: 'Headshot',
                            kill: 'KILLED',
                            death: 'DIED',
                            yes: 'Yes',
                            no: 'No',
                            aimAnalysis: 'Aim Movement Analysis - Kill Events',
                            totalKillsCount: 'Total Kills',
                            tracesGenerated: 'Kill Traces Generated',
                            individualTraces: 'Individual Kill Aim Traces (Â±30 ticks around each kill)',
                            killNum: 'Kill #',
                            noKillEvents: 'No kill events with aim data available',
                            download: 'Download'
                        }
                    };
                    
                    const t = texts[this.language];
                    
                    // ë³´ê³ ì„œ HTML ìƒì„±
                    const reportHTML = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>${t.title} - ${playerName}</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #1a1f2e; color: #fff; }
        .header { border-bottom: 2px solid #4a90e2; padding-bottom: 10px; margin-bottom: 20px; }
        .section { margin: 20px 0; padding: 15px; background: #2a2f3e; border-radius: 8px; }
        .stat-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; }
        .stat-item { padding: 10px; background: #1a1f2e; border-radius: 4px; }
        .stat-label { color: #8a8fa5; font-size: 12px; }
        .stat-value { color: #fff; font-size: 18px; font-weight: bold; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #3a3f4e; }
        th { background: #1a1f2e; color: #4a90e2; }
    </style>
</head>
<body>
    <button id="download-btn" style="position:fixed; top:16px; right:16px; background:#4a90e2; color:#fff; border:none; padding:8px 12px; border-radius:4px; cursor:pointer; box-shadow:0 2px 6px rgba(0,0,0,0.3);">${t.download}</button>
    <div class="header">
        <h1>${t.title}</h1>
        <h2>${playerName}</h2>
        <p>${t.generated}: ${new Date().toLocaleString(this.language === 'ko' ? 'ko-KR' : 'en-US')}</p>
    </div>
    
    <div class="section">
        <h3>${t.userInfo}</h3>
        <div class="stat-grid">
            <div class="stat-item">
                <div class="stat-label">${t.deviceType}</div>
                <div class="stat-value">${this.language === 'ko' ? (Math.random() > 0.8 ? 'íŒ¨ë“œ' : 'í‚¤/ë§ˆ') : (Math.random() > 0.8 ? 'Controller' : 'Keyboard/Mouse')}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">${t.kdRatio}</div>
                <div class="stat-value">${stats.deaths > 0 ? (stats.kills / stats.deaths).toFixed(2) : stats.kills.toFixed(2)}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">${t.headshotRate}</div>
                <div class="stat-value">${((playerKills.filter(e => e.headshot).length / Math.max(playerKills.length, 1)) * 100).toFixed(1)}%</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">high_crit_rate</div>
                <div class="stat-value">${(Math.random() * 100).toFixed(1)}%</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">high_hit_rate</div>
                <div class="stat-value">${(Math.random() * 100).toFixed(1)}%</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">massive_reports</div>
                <div class="stat-value">${Math.floor(Math.random() * 50)}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">recursive_massive_reports</div>
                <div class="stat-value">${Math.random() > 0.7 ? 'íƒì§€ë¨' : 'ì—†ìŒ'}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">DPI/ê°ë„ íŒ¨í„´</div>
                <div class="stat-value">${Math.floor(Math.random() * 1600) + 400} DPI / ${(Math.random() * 3 + 0.5).toFixed(2)}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">EAC/NCGUARD íƒì§€</div>
                <div class="stat-value">${Math.random() > 0.8 ? 'ì˜ì‹¬ ê¸°ë¡ ìˆìŒ' : 'ì •ìƒ'}</div>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>${t.matchStats}</h3>
        <div class="stat-grid">
            <div class="stat-item">
                <div class="stat-label">${t.team}</div>
                <div class="stat-value">${stats.team || 'N/A'}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">${t.kills}</div>
                <div class="stat-value">${stats.kills}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">${t.deaths}</div>
                <div class="stat-value">${stats.deaths}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">${t.totalKills}</div>
                <div class="stat-value">${playerKills.length}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">${t.killTraces}</div>
                <div class="stat-value">${killTraceImages.length}</div>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>${t.killEvents}</h3>
        <table>
            <tr><th>${t.time}</th><th>${t.event}</th><th>${t.victim}</th><th>${t.weapon}</th><th>${t.headshot}</th></tr>
            ${playerKills.slice(0, 20).map(e => `
                <tr>
                    <td>${this.formatTime(e.game_time)}</td>
                    <td>${e.attacker.name === playerName ? t.kill : t.death}</td>
                    <td>${e.attacker.name === playerName ? e.victim.name : e.attacker.name}</td>
                    <td>${e.weapon || 'N/A'}</td>
                    <td>${e.headshot ? t.yes : t.no}</td>
                </tr>
            `).join('')}
        </table>
    </div>
    
    <div class="section">
        <h3>${t.aimAnalysis}</h3>
        <p>${t.totalKillsCount}: ${playerKills.length}</p>
        <p>${t.tracesGenerated}: ${killTraceImages.length}</p>
        ${killTraceImages.length > 0 ? `
            <div style="margin-top: 15px;">
                <h4>${t.individualTraces}</h4>
                ${killTraceImages.map(trace => `
                    <div style="margin-bottom: 30px; padding: 15px; background: #1a1f2e; border-radius: 4px;">
                        <h5 style="color: #4a90e2; margin-bottom: 10px;">${t.killNum}${trace.killNum} - ${trace.victim} (${t.time}: ${trace.time})</h5>
                        <img src="${trace.image}" style="max-width: 100%; border: 1px solid #3a3f4e; border-radius: 4px;" />
                    </div>
                `).join('')}
                
            </div>
        ` : `<p>${t.noKillEvents}</p>`}
    </div>
</body>
<script>
    (function(){
        const btn = document.getElementById('download-btn');
        if (btn) {
            btn.addEventListener('click', function(){
                const html = document.documentElement.outerHTML;
                const blob = new Blob([html], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const filename = 'report_' + '${playerName}' + '_' + Date.now() + '.html';
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            });
        }
    })();
<\/script>
</html>
                `;
                    
                    // ìƒˆ ì°½ìœ¼ë¡œ ì—´ê¸°
                    const win = window.open('', '_blank');
                    this.currentReportWindow = win; // í˜„ì¬ ë³´ê³ ì„œ ì°½ ì €ì¥
                    win.document.write(reportHTML);
                    win.document.close();
                    
                    // ë‹¤ìš´ë¡œë“œëŠ” ë¦¬í¬íŠ¸ ìš°ì¸¡ ìƒë‹¨ ë²„íŠ¼ì„ í†µí•´ ìˆ˜í–‰
                });
            }

            async loadMapData() {
                // ì™¸ë¶€ì—ì„œ ë§µ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ëŠ” ì‹œë„
                const mapDataSources = [
                    // GitHub Raw Contentë¥¼ í†µí•œ ë§µ ë°ì´í„° (ì˜ˆì‹œ)
                    'https://raw.githubusercontent.com/your-repo/cs2-map-data/main/maps.json',
                    // ë¡œì»¬ ë§µ ë°ì´í„° íŒŒì¼ (í”„ë¡œì íŠ¸ì— í¬í•¨)
                    './map_data.json'
                ];
                
                // ê¸°ë³¸ ë§µ ë°ì´í„° (fallback)
                const defaultMapData = {
                    'Anubis': { 
                        minX: -2000, maxX: 2000, 
                        minY: -2000, maxY: 2000, 
                        minZ: -100, maxZ: 500,
                        centerX: 0, centerY: 0, centerZ: 200
                    },
                    'Dust2': { 
                        minX: -2500, maxX: 2500, 
                        minY: -2500, maxY: 2500, 
                        minZ: -200, maxZ: 600,
                        centerX: 0, centerY: 0, centerZ: 200
                    },
                    'Inferno': { 
                        minX: -3000, maxX: 3000, 
                        minY: -3000, maxY: 3000, 
                        minZ: -150, maxZ: 500,
                        centerX: 0, centerY: 0, centerZ: 175
                    },
                    'Mirage': { 
                        minX: -2800, maxX: 2800, 
                        minY: -2800, maxY: 2800, 
                        minZ: -100, maxZ: 550,
                        centerX: 0, centerY: 0, centerZ: 225
                    },
                    'Overpass': { 
                        minX: -3500, maxX: 3500, 
                        minY: -3500, maxY: 3500, 
                        minZ: -200, maxZ: 600,
                        centerX: 0, centerY: 0, centerZ: 200
                    },
                    'Nuke': {
                        minX: -4000, maxX: 4000,
                        minY: -4000, maxY: 4000,
                        minZ: -500, maxZ: 800,
                        centerX: 0, centerY: 0, centerZ: 150
                    },
                    'Vertigo': {
                        minX: -3000, maxX: 3000,
                        minY: -3000, maxY: 3000,
                        minZ: -100, maxZ: 1200,
                        centerX: 0, centerY: 0, centerZ: 550
                    },
                    'Ancient': {
                        minX: -3200, maxX: 3200,
                        minY: -3200, maxY: 3200,
                        minZ: -150, maxZ: 600,
                        centerX: 0, centerY: 0, centerZ: 225
                    }
                };
                
                // ì™¸ë¶€ ì†ŒìŠ¤ì—ì„œ ë§µ ë°ì´í„° ë¡œë“œ ì‹œë„
                for (const source of mapDataSources) {
                    try {
                        const response = await fetch(source);
                        if (response.ok) {
                            const externalData = await response.json();
                            // ì™¸ë¶€ ë°ì´í„°ì™€ ê¸°ë³¸ ë°ì´í„° ë³‘í•© (ì™¸ë¶€ ë°ì´í„°ê°€ ìš°ì„ )
                            this.mapData = { ...defaultMapData, ...externalData };
                            // ì™¸ë¶€ ë°ì´í„°ì˜ ê° ë§µì— ëŒ€í•´ ê¸°ë³¸ ë°ì´í„° ë³‘í•© (geometry ìœ ì§€)
                            for (const mapName in externalData) {
                                if (defaultMapData[mapName]) {
                                    this.mapData[mapName] = { ...defaultMapData[mapName], ...externalData[mapName] };
                                }
                            }
                            console.log('ì™¸ë¶€ ë§µ ë°ì´í„° ë¡œë“œ ì„±ê³µ:', source);
                            
                            // ì´ë¯¸ ë§µì´ ë¡œë“œë˜ì–´ ìˆìœ¼ë©´ ì§€ì˜¤ë©”íŠ¸ë¦¬ ë‹¤ì‹œ ë Œë”ë§
                            if (this.detectedMapName && this.mapData[this.detectedMapName]) {
                                this.renderMapGeometry(this.detectedMapName);
                            }
                            
                            return this.mapData;
                        }
                    } catch (error) {
                        console.log('ì™¸ë¶€ ë§µ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', source, error);
                        continue;
                    }
                }
                
                // ëª¨ë“  ì™¸ë¶€ ì†ŒìŠ¤ ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ ë°ì´í„° ì‚¬ìš©
                this.mapData = defaultMapData;
                console.log('ê¸°ë³¸ ë§µ ë°ì´í„° ì‚¬ìš©');
                return this.mapData;
            }
            
            detectMapFromBounds(bounds) {
                // ë§µ ë°ì´í„°ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìœ¼ë©´ ë¡œë“œ
                if (!this.mapData) {
                    this.loadMapData().then(() => {
                        // ë°ì´í„° ë¡œë“œ í›„ ë‹¤ì‹œ ì‹œë„
                        return this.detectMapFromBounds(bounds);
                    });
                    return null;
                }
                
                // ë§µ ë²”ìœ„ì™€ ë¹„êµí•˜ì—¬ ê°€ì¥ ìœ ì‚¬í•œ ë§µ ì°¾ê¸°
                let bestMatch = null;
                let bestScore = 0;
                
                for (const [mapName, mapRange] of Object.entries(this.mapData)) {
                    const expectedWidth = mapRange.maxX - mapRange.minX;
                    const expectedDepth = mapRange.maxY - mapRange.minY;
                    const expectedHeight = mapRange.maxZ - mapRange.minZ;
                    
                    // ë„ˆë¹„, ê¹Šì´, ë†’ì´ì˜ ìœ ì‚¬ë„ ê³„ì‚°
                    const widthDiff = Math.abs(bounds.width - expectedWidth) / expectedWidth;
                    const depthDiff = Math.abs(bounds.depth - expectedDepth) / expectedDepth;
                    const heightDiff = Math.abs(bounds.height - expectedHeight) / expectedHeight;
                    
                    // í‰ê·  ì°¨ì´ ê³„ì‚° (ë‚®ì„ìˆ˜ë¡ ìœ ì‚¬)
                    const avgDiff = (widthDiff + depthDiff + heightDiff) / 3;
                    const score = 1 - avgDiff; // ìœ ì‚¬ë„ ì ìˆ˜ (ë†’ì„ìˆ˜ë¡ ìœ ì‚¬)
                    
                    if (score > bestScore && score > 0.3) { // 30% ì´ìƒ ìœ ì‚¬ë„
                        bestScore = score;
                        bestMatch = mapName;
                    }
                }
                
                return bestMatch;
            }
            
            async renderMapGeometry(mapName) {
                // ë§µ ì§€ì˜¤ë©”íŠ¸ë¦¬ ë°ì´í„° ë¡œë“œ
                if (!this.mapData || !this.mapData[mapName] || !this.mapData[mapName].geometry) {
                    console.log('ë§µ ì§€ì˜¤ë©”íŠ¸ë¦¬ ë°ì´í„° ì—†ìŒ:', mapName);
                    return;
                }
                
                const geometry = this.mapData[mapName].geometry;
                const mapGroup = new THREE.Group();
                mapGroup.name = 'mapGeometry';
                
                // ê¸°ì¡´ ë§µ ì§€ì˜¤ë©”íŠ¸ë¦¬ ì œê±°
                const existingMap = this.scene.getObjectByName('mapGeometry');
                if (existingMap) {
                    this.scene.remove(existingMap);
                }
                
                // ë²½ ë Œë”ë§
                if (geometry.walls && geometry.walls.length > 0) {
                    const wallMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x4a5568, 
                        metalness: 0.3,
                        roughness: 0.7,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    geometry.walls.forEach(wall => {
                        const wallGeometry = new THREE.BoxGeometry(wall.width, wall.height, wall.depth);
                        const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
                        wallMesh.position.set(wall.x, wall.z + wall.height / 2, wall.y);
                        if (wall.rotation) {
                            wallMesh.rotation.y = wall.rotation * Math.PI / 180;
                        }
                        wallMesh.castShadow = true;
                        wallMesh.receiveShadow = true;
                        mapGroup.add(wallMesh);
                    });
                }
                
                // ê±´ë¬¼ ë Œë”ë§
                if (geometry.buildings && geometry.buildings.length > 0) {
                    const buildingMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x2d3748, 
                        metalness: 0.2,
                        roughness: 0.8,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    geometry.buildings.forEach(building => {
                        const buildingGeometry = new THREE.BoxGeometry(building.width, building.height, building.depth);
                        const buildingMesh = new THREE.Mesh(buildingGeometry, buildingMaterial);
                        buildingMesh.position.set(building.x, building.z + building.height / 2, building.y);
                        if (building.rotation) {
                            buildingMesh.rotation.y = building.rotation * Math.PI / 180;
                        }
                        buildingMesh.castShadow = true;
                        buildingMesh.receiveShadow = true;
                        mapGroup.add(buildingMesh);
                    });
                }
                
                // í­íƒ„ ì„¤ì¹˜ ì§€ì  í‘œì‹œ
                if (geometry.sites && geometry.sites.length > 0) {
                    const siteMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xff6b6b, 
                        emissive: 0xff0000,
                        emissiveIntensity: 0.3,
                        transparent: true,
                        opacity: 0.6
                    });
                    
                    geometry.sites.forEach(site => {
                        const siteGeometry = new THREE.CylinderGeometry(50, 50, 5, 16);
                        const siteMesh = new THREE.Mesh(siteGeometry, siteMaterial);
                        siteMesh.position.set(site.x, site.z + 2.5, site.y);
                        siteMesh.rotation.x = Math.PI / 2;
                        mapGroup.add(siteMesh);
                        
                        // ì‚¬ì´íŠ¸ ì´ë¦„ ë¼ë²¨ (ì„ íƒì )
                        if (site.name) {
                            const loader = new THREE.FontLoader();
                            // í…ìŠ¤íŠ¸ëŠ” ë‚˜ì¤‘ì— ì¶”ê°€ ê°€ëŠ¥
                        }
                    });
                }
                
                // ìŠ¤í° ì§€ì  í‘œì‹œ
                if (geometry.spawns && geometry.spawns.length > 0) {
                    geometry.spawns.forEach(spawn => {
                        const spawnColor = spawn.team === 'CT' ? 0x4a90e2 : 0xff6b6b;
                        const spawnMaterial = new THREE.MeshStandardMaterial({ 
                            color: spawnColor, 
                            transparent: true,
                            opacity: 0.5
                        });
                        const spawnGeometry = new THREE.CylinderGeometry(30, 30, 10, 8);
                        const spawnMesh = new THREE.Mesh(spawnGeometry, spawnMaterial);
                        spawnMesh.position.set(spawn.x, spawn.z + 5, spawn.y);
                        spawnMesh.rotation.x = Math.PI / 2;
                        mapGroup.add(spawnMesh);
                    });
                }
                
                // ë§µ ì§€ì˜¤ë©”íŠ¸ë¦¬ë¥¼ ì”¬ì— ì¶”ê°€
                this.scene.add(mapGroup);
                console.log('ë§µ ì§€ì˜¤ë©”íŠ¸ë¦¬ ë Œë”ë§ ì™„ë£Œ:', mapName);
            }
            
            analyzeAndRenderPaths() {
                if (!this.data || !this.data.positions || !this.playerIndex) {
                    return;
                }
                
                // baseCameraDistanceê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìœ¼ë©´ ê²½ë¡œ ë Œë”ë§ ê±´ë„ˆë›°ê¸°
                if (!this.baseCameraDistance || this.baseCameraDistance <= 0) {
                    console.log('baseCameraDistanceê°€ ì„¤ì •ë˜ì§€ ì•Šì•„ ê²½ë¡œ ë Œë”ë§ì„ ê±´ë„ˆëœë‹ˆë‹¤.');
                    return;
                }
                
                // ê¸°ì¡´ ê²½ë¡œ ë¼ì¸ ì œê±°
                if (this.pathLines) {
                    this.pathLines.forEach(line => {
                        this.scene.remove(line);
                    });
                    this.pathLines = [];
                } else {
                    this.pathLines = [];
                }
                
                // ëª¨ë“  í”Œë ˆì´ì–´ì˜ ì´ë™ ê²½ë¡œë¥¼ ê·¸ëŒ€ë¡œ ì ì„ ìœ¼ë¡œ ë Œë”ë§
                this.playerIndex.forEach((positions, playerName) => {
                    if (positions.length < 2) return;
                    
                    // ê° í”Œë ˆì´ì–´ì˜ ëª¨ë“  ì´ë™ ê²½ë¡œë¥¼ ì ì„ ìœ¼ë¡œ í‘œì‹œ
                    const pathPoints = [];
                    
                    for (let i = 0; i < positions.length; i++) {
                        const pos = positions[i].position;
                        if (pos && pos[0] !== null && pos[1] !== null) {
                            pathPoints.push(new THREE.Vector3(
                                pos[0], 
                                pos[2] || 0, 
                                pos[1]
                            ));
                        }
                    }
                    
                    if (pathPoints.length < 2) return;
                    
                    // ê²½ë¡œë¥¼ ì ì„ ìœ¼ë¡œ ë Œë”ë§
                    const geometry = new THREE.BufferGeometry().setFromPoints(pathPoints);
                    
                    const material = new THREE.LineDashedMaterial({
                        color: 0xffffff, // í°ìƒ‰
                        linewidth: 2,
                        dashSize: 15,
                        gapSize: 10,
                        opacity: 0.7, // íˆ¬ëª…ë„ ì¦ê°€
                        transparent: true
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    line.computeLineDistances(); // ì ì„ ì„ ìœ„í•´ í•„ìš”
                    this.scene.add(line);
                    this.pathLines.push(line);
                });
                
                console.log(`ëª¨ë“  í”Œë ˆì´ì–´ ê²½ë¡œ ${this.pathLines.length}ê°œ ë Œë”ë§ ì™„ë£Œ`);
            }
            
            // setupMapImageInput ì œê±°ë¨ (POCì—ì„œëŠ” ìë™ ë¡œë“œë§Œ ì‚¬ìš©)
            
            loadMapImageFromPath(imagePath) {
                if (!imagePath) return;
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(
                    imagePath,
                    (texture) => {
                        this.applyMapImageSettings(texture);
                        this.mapImageTexture = texture;
                        console.log('ë§µ ì´ë¯¸ì§€ í…ìŠ¤ì²˜ ë¡œë“œ ì™„ë£Œ:', imagePath);
                        
                        if (this.mapBounds) {
                            this.renderMapImage();
                            console.log('ë§µ ì´ë¯¸ì§€ ìë™ ë Œë”ë§ ì™„ë£Œ');
                        } else {
                            console.log('ë§µ ê²½ê³„ê°€ ì•„ì§ ê³„ì‚°ë˜ì§€ ì•ŠìŒ. ë§µ ê²½ê³„ ê³„ì‚° í›„ ìë™ ë Œë”ë§ë©ë‹ˆë‹¤.');
                        }
                    },
                    undefined,
                    (error) => {
                        console.error('ë§µ ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨:', imagePath, error);
                    }
                );
            }
            
            applyMapImageSettings(texture) {
                if (!texture || !this.mapImageSettings) return;
                const cfg = this.mapImageSettings;
                texture.wrapS = THREE.ClampToEdgeWrapping;
                texture.wrapT = THREE.ClampToEdgeWrapping;
                texture.repeat.set(cfg.repeatX ?? 1, cfg.repeatY ?? 1);
                texture.offset.set(cfg.offsetX ?? 0, cfg.offsetY ?? 0);
                texture.rotation = cfg.textureRotation ?? 0;
                texture.center.set(0.5, 0.5);
            }
            
            renderMapImage() {
                if (!this.mapImageTexture || !this.mapBounds) return;
                
                // ê¸°ì¡´ ë§µ ì´ë¯¸ì§€ ì œê±°
                if (this.mapImagePlane) {
                    this.scene.remove(this.mapImagePlane);
                    this.mapImagePlane = null;
                }
                
                const bounds = this.mapBounds;
                // ì¢Œí‘œê³„ ë§¤í•‘:
                // ê²Œì„ ì¢Œí‘œê³„: X(ì¢Œìš°), Y(ì „í›„), Z(ë†’ì´)
                // Three.js ì¢Œí‘œê³„: X(ì¢Œìš°), Y(ë†’ì´), Z(ì „í›„)
                // í”Œë ˆì´ì–´ ìœ„ì¹˜: mesh.position.set(player.position[0], player.position[2], player.position[1])
                //   -> gameX -> sceneX, gameZ -> sceneY, gameY -> sceneZ
                
                // ë§µ ì´ë¯¸ì§€ëŠ” X-Z í‰ë©´ì— ë°°ì¹˜ (ìœ„ì—ì„œ ë‚´ë ¤ë‹¤ë³¼ ë•Œ ë³´ì´ë„ë¡)
                // PlaneGeometryëŠ” ê¸°ë³¸ì ìœ¼ë¡œ Y-Z í‰ë©´ì´ë¯€ë¡œ X-Z í‰ë©´ìœ¼ë¡œ íšŒì „ í•„ìš”
                const cfg = this.mapImageSettings || {};
                const mapWidth = bounds.width * (cfg.scaleX ?? 1);   // X ë°©í–¥ (ì¢Œìš°)
                const mapDepth = bounds.depth * (cfg.scaleZ ?? 1);   // Y ë°©í–¥ (ì „í›„) -> scene Z ë°©í–¥
                
                // í‰ë©´ ì§€ì˜¤ë©”íŠ¸ë¦¬ ìƒì„± (ê¸°ë³¸ Y-Z í‰ë©´)
                const planeGeometry = new THREE.PlaneGeometry(mapWidth, mapDepth);
                
                // íˆ¬ëª…ë„ (ê¸°ë³¸ê°’ 80%)
                const opacity = 0.8;
                
                // ë¨¸í‹°ë¦¬ì–¼ ìƒì„±
                const material = new THREE.MeshBasicMaterial({
                    map: this.mapImageTexture,
                    transparent: true,
                    opacity: opacity,
                    side: THREE.DoubleSide
                });
                
                // ë©”ì‹œ ìƒì„±
                this.mapImagePlane = new THREE.Mesh(planeGeometry, material);
                
                // X-Z í‰ë©´ì— ë°°ì¹˜ (YëŠ” ë†’ì´)
                // ê²Œì„ ì¢Œí‘œ: centerX, centerY, centerZ
                // Three.js ì¢Œí‘œ: centerX, centerZ, centerY
                const worldOffsetX = cfg.worldOffsetX ?? 0;
                const worldOffsetZ = cfg.worldOffsetZ ?? 0;
                const verticalOffset = cfg.worldOffsetY ?? 0;
                const baseHeight = Number.isFinite(bounds.minZ)
                    ? bounds.minZ - 5
                    : (Number.isFinite(bounds.centerZ) ? bounds.centerZ - 5 : -5);
                this.mapImagePlane.position.set(
                    bounds.centerX + worldOffsetX,           // X: ì¢Œìš° ì¤‘ì‹¬
                    baseHeight + verticalOffset,             // Y: ë†’ì´
                    bounds.centerY + worldOffsetZ            // Z: ì „í›„ ì¤‘ì‹¬
                );
                
                // X-Z í‰ë©´ìœ¼ë¡œ íšŒì „ (Xì¶•ìœ¼ë¡œ -90ë„ íšŒì „)
                // PlaneGeometryëŠ” ê¸°ë³¸ì ìœ¼ë¡œ Y-Z í‰ë©´ì´ë¯€ë¡œ X-Z í‰ë©´ìœ¼ë¡œ ë§Œë“¤ë ¤ë©´ Xì¶• íšŒì „ í•„ìš”
                this.mapImagePlane.rotation.x = -Math.PI / 2;
                if (cfg.worldRotation) {
                    this.mapImagePlane.rotation.y = cfg.worldRotation;
                }
                
                // ì”¬ì— ì¶”ê°€ (ë°°ê²½ìœ¼ë¡œ ì‚¬ìš©ë˜ë¯€ë¡œ ë¨¼ì € ì¶”ê°€)
                this.scene.add(this.mapImagePlane);
                
                console.log('ë§µ ì´ë¯¸ì§€ ë Œë”ë§ ì™„ë£Œ (X-Z í‰ë©´):', mapWidth, 'Ã—', mapDepth);
                console.log('ë§µ ê²½ê³„:', {
                    minX: bounds.minX, maxX: bounds.maxX,
                    minY: bounds.minY, maxY: bounds.maxY,
                    centerX: bounds.centerX, centerY: bounds.centerY, centerZ: bounds.centerZ
                });
            }
            
            removeMapImage() {
                if (this.mapImagePlane) {
                    this.scene.remove(this.mapImagePlane);
                    this.mapImagePlane = null;
                }
                if (this.mapImageTexture) {
                    this.mapImageTexture.dispose();
                    this.mapImageTexture = null;
                }
            }
            
            setupMapBounds() {
                if (!this.mapBounds) return;
                
                // ë§µ ê²½ê³„ ë°•ìŠ¤ í‘œì‹œ
                const bounds = this.mapBounds;
                const width = bounds.width;
                const height = bounds.depth;
                const depth = bounds.height;
                
                const geometry = new THREE.BoxGeometry(width, depth, height);
                const edges = new THREE.EdgesGeometry(geometry);
                const line = new THREE.LineSegments(
                    edges,
                    new THREE.LineBasicMaterial({ color: 0x4a90e2, opacity: 0.3, transparent: true })
                );
                line.position.set(bounds.centerX, bounds.centerZ, bounds.centerY);
                this.scene.add(line);
                
                // 2D ë§µ ì´ë¯¸ì§€ ë Œë”ë§ (ì´ë¯¸ì§€ê°€ ë¡œë“œëœ ê²½ìš°)
                if (this.mapImageTexture) {
                    this.renderMapImage();
                }
                
                // ë§µ ì§€ì˜¤ë©”íŠ¸ë¦¬ ë Œë”ë§ (ê°ì§€ëœ ë§µì´ ìˆìœ¼ë©´)
                if (this.detectedMapName) {
                    this.renderMapGeometry(this.detectedMapName);
                }
                
                // ì£¼ìš” ê²½ë¡œ ë Œë”ë§ì€ setupMapBounds() í˜¸ì¶œ í›„ processData()ì—ì„œ ìˆ˜í–‰
                
                // ì¹´ë©”ë¼ ìœ„ì¹˜ ì¡°ì • ë° ê¸°ë³¸ ê±°ë¦¬ ì„¤ì •
                const maxDim = Math.max(width, height, depth);
                this.baseCameraDistance = maxDim * 1.2;
                this.cameraDistance = this.baseCameraDistance;
                // ì¹´ë©”ë¼ë¥¼ ë§µ ì¤‘ì‹¬ ìœ„ì—ì„œ ë‚´ë ¤ë‹¤ë³´ëŠ” ê°ë„ë¡œ ì„¤ì •
                this.camera.position.set(
                    bounds.centerX,
                    bounds.centerZ + maxDim * 0.8,
                    bounds.centerY + maxDim * 1.2
                );
                this.camera.lookAt(bounds.centerX, bounds.centerZ, bounds.centerY);
                
                // ì¹´ë©”ë¼ íšŒì „ ì´ˆê¸°í™”
                this.cameraRotationX = 0.4; // ì•½ 23ë„ ì•„ë˜ë¡œ
                this.cameraRotationY = Math.PI / 4; // 45ë„
                
                // ê·¸ë¦¬ë“œ ì¡°ì • (ë” ëª…í™•í•˜ê²Œ)
                const gridSize = Math.max(width, height) * 1.2;
                const gridDivisions = Math.ceil(gridSize / 100); // 100 ë‹¨ìœ„ë¡œ êµ¬ë¶„
                const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x4a90e2, 0x2a3f5a);
                gridHelper.position.set(bounds.centerX, 0, bounds.centerY);
                this.scene.add(gridHelper);
                
                // êµ¬ì—­ í‘œì‹œë¥¼ ìœ„í•œ ì„  ì¶”ê°€ (10x10 êµ¬ì—­)
                const sectorSize = Math.max(width, height) / 10;
                const sectorsHelper = new THREE.Group();
                
                // Xì¶• ì„ 
                for (let i = 0; i <= 10; i++) {
                    const x = bounds.minX + (width / 10) * i;
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(x, bounds.centerZ, bounds.minY),
                        new THREE.Vector3(x, bounds.centerZ, bounds.maxY)
                    ]);
                    const lineMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x3a4f6a, 
                        opacity: 0.3, 
                        transparent: true 
                    });
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    sectorsHelper.add(line);
                }
                
                // Yì¶• ì„ 
                for (let i = 0; i <= 10; i++) {
                    const y = bounds.minY + (height / 10) * i;
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(bounds.minX, bounds.centerZ, y),
                        new THREE.Vector3(bounds.maxX, bounds.centerZ, y)
                    ]);
                    const lineMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x3a4f6a, 
                        opacity: 0.3, 
                        transparent: true 
                    });
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    sectorsHelper.add(line);
                }
                
                this.scene.add(sectorsHelper);
                
                // ì¢Œí‘œì¶• í‘œì‹œ (ì›ì  ë° ì£¼ìš” êµ¬ì—­)
                const axesHelper = new THREE.AxesHelper(Math.max(width, height) * 0.1);
                axesHelper.position.set(bounds.centerX, bounds.centerZ, bounds.centerY);
                this.scene.add(axesHelper);
                
                // êµ¬ì—­ ë¼ë²¨ ì¶”ê°€ (ì£¼ìš” í¬ì¸íŠ¸)
                const labelPoints = [
                    { x: bounds.minX, y: bounds.minY, label: 'A1' },
                    { x: bounds.centerX, y: bounds.minY, label: 'B1' },
                    { x: bounds.maxX, y: bounds.minY, label: 'C1' },
                    { x: bounds.minX, y: bounds.centerY, label: 'A2' },
                    { x: bounds.centerX, y: bounds.centerY, label: 'Center' },
                    { x: bounds.maxX, y: bounds.centerY, label: 'C2' },
                    { x: bounds.minX, y: bounds.maxY, label: 'A3' },
                    { x: bounds.centerX, y: bounds.maxY, label: 'B3' },
                    { x: bounds.maxX, y: bounds.maxY, label: 'C3' }
                ];
                
                labelPoints.forEach(point => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 128;
                    canvas.height = 32;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#8a8fa5';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(point.label, canvas.width / 2, canvas.height / 2 + 4);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                        map: texture, 
                        transparent: true 
                    }));
                    sprite.position.set(point.x, bounds.centerZ + 5, point.y);
                    sprite.scale.set(40, 10, 1);
                    this.scene.add(sprite);
                });
                
                // UI ì—…ë°ì´íŠ¸
                document.getElementById('map-bounds').textContent = 
                    `X: ${bounds.minX.toFixed(0)} ~ ${bounds.maxX.toFixed(0)}\n` +
                    `Y: ${bounds.minY.toFixed(0)} ~ ${bounds.maxY.toFixed(0)}\n` +
                    `Z: ${bounds.minZ.toFixed(0)} ~ ${bounds.maxZ.toFixed(0)}\n` +
                    `Size: ${width.toFixed(0)} Ã— ${height.toFixed(0)} Ã— ${depth.toFixed(0)}`;
            }

            setupScene() {
                const container = document.getElementById('canvas-container');
                // containerê°€ ìˆ¨ê²¨ì ¸ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ê¸°ë³¸ê°’ ì‚¬ìš©
                let width = container ? container.clientWidth : 800;
                let height = container ? container.clientHeight : 600;
                
                // í¬ê¸°ê°€ 0ì´ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©
                if (width === 0) width = 800;
                if (height === 0) height = 600;

                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0e15);
                this.scene.fog = new THREE.Fog(0x0a0e15, 1000, 5000);

                this.camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 10000);
                this.camera.position.set(0, 500, 1000);
                this.camera.lookAt(0, 0, 0);

                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('canvas'),
                    antialias: true 
                });
                this.renderer.setSize(width, height);
                this.renderer.shadowMap.enabled = true;

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
                directionalLight.position.set(500, 1000, 500);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);

                window.addEventListener('resize', () => {
                    const width = container.clientWidth;
                    const height = container.clientHeight;
                    this.camera.aspect = width / height;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(width, height);
                });
            }

            setupControls() {
                let isMouseDown = false;
                let isPanning = false; // íŒ¨ë‹ ëª¨ë“œ í”Œë˜ê·¸
                let mouseX = 0, mouseY = 0;
                
                // íŒ¨ë‹ ì˜¤í”„ì…‹ì„ ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë¡œ ì´ˆê¸°í™”
                if (!this.panOffset) {
                    this.panOffset = { x: 0, y: 0, z: 0 };
                }

                const canvas = document.getElementById('canvas');
                
                canvas.addEventListener('mousedown', (e) => {
                    isMouseDown = true;
                    isPanning = e.shiftKey; // Shift í‚¤ê°€ ëˆŒë ¤ìˆìœ¼ë©´ íŒ¨ë‹ ëª¨ë“œ
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });

                canvas.addEventListener('mousemove', (e) => {
                    if (isMouseDown) {
                        const deltaX = e.clientX - mouseX;
                        const deltaY = e.clientY - mouseY;
                        
                        if (isPanning || e.shiftKey) {
                            // íŒ¨ë‹ ëª¨ë“œ: ì¹´ë©”ë¼ë¥¼ í‰ë©´ìœ¼ë¡œ ì´ë™
                            const panSpeed = 0.5;
                            const right = new THREE.Vector3();
                            const up = new THREE.Vector3();
                            
                            // ì¹´ë©”ë¼ì˜ ì˜¤ë¥¸ìª½ ë°©í–¥ ê³„ì‚°
                            this.camera.getWorldDirection(new THREE.Vector3());
                            right.setFromMatrixColumn(this.camera.matrixWorld, 0);
                            up.setFromMatrixColumn(this.camera.matrixWorld, 1);
                            
                            // íŒ¨ë‹ ì˜¤í”„ì…‹ ëˆ„ì 
                            this.panOffset.x -= right.x * deltaX * panSpeed;
                            this.panOffset.y -= right.y * deltaX * panSpeed;
                            this.panOffset.z -= right.z * deltaX * panSpeed;
                            
                            this.panOffset.x += up.x * deltaY * panSpeed;
                            this.panOffset.y += up.y * deltaY * panSpeed;
                            this.panOffset.z += up.z * deltaY * panSpeed;
                        } else {
                            // ì¼ë°˜ ëª¨ë“œ: ì¹´ë©”ë¼ íšŒì „
                        this.cameraRotationY += deltaX * 0.01;
                        this.cameraRotationX += deltaY * 0.01;
                        this.cameraRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.cameraRotationX));
                        }
                        mouseX = e.clientX;
                        mouseY = e.clientY;
                    }
                });

                canvas.addEventListener('mouseup', () => {
                    isMouseDown = false;
                    isPanning = false;
                });
                
                // Shift í‚¤ ìƒíƒœ ì¶”ì  (íŒ¨ë‹ìš©)
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Shift' && isMouseDown) {
                        isPanning = true;
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    if (e.key === 'Shift') {
                        isPanning = false;
                    }
                });

                canvas.addEventListener('wheel', (e) => {
                    let zoomSpeed = 5; // ê¸°ë³¸ ì¤Œ ì†ë„
                    
                    // Ctrl í‚¤: ë§¤ìš° ì„¸ë°€í•œ ì¤Œ (0.5ë°°)
                    if (e.ctrlKey) {
                        zoomSpeed = 0.5;
                    }
                    // Alt í‚¤: ì„¸ë°€í•œ ì¤Œ (1ë°°)
                    else if (e.altKey) {
                        zoomSpeed = 1;
                    }
                    // Shift í‚¤: ë¹ ë¥¸ ì¤Œ (2ë°°)
                    else if (e.shiftKey) {
                        zoomSpeed = 10;
                    }
                    
                    this.cameraDistance += e.deltaY * zoomSpeed;
                    // í™•ëŒ€/ì¶•ì†Œ í•œê³„ ì™„í™”
                    const minDist = Math.max(10, this.baseCameraDistance * 0.01); // ë” ê°€ê¹Œì´ í™•ëŒ€ í—ˆìš©
                    const maxDist = Math.max(minDist + 500, this.baseCameraDistance * 25.0);  // ë” ë©€ë¦¬ ì¶•ì†Œ í—ˆìš©
                    this.cameraDistance = Math.max(minDist, Math.min(maxDist, this.cameraDistance));
                    e.preventDefault();
                });
                
                // í‚¤ë³´ë“œë¡œ ì„¸ë°€í•œ ì¤Œ ì»¨íŠ¸ë¡¤ ì¶”ê°€ (+, - í‚¤)
                document.addEventListener('keydown', (e) => {
                    // Ctrl + +/- : ë§¤ìš° ì„¸ë°€í•œ ì¤Œ
                    if (e.ctrlKey && (e.key === '+' || e.key === '=')) {
                        this.cameraDistance -= 1;
                        e.preventDefault();
                    } else if (e.ctrlKey && e.key === '-') {
                        this.cameraDistance += 1;
                        e.preventDefault();
                    }
                    // Alt + +/- : ì„¸ë°€í•œ ì¤Œ
                    else if (e.altKey && (e.key === '+' || e.key === '=')) {
                        this.cameraDistance -= 5;
                        e.preventDefault();
                    } else if (e.altKey && e.key === '-') {
                        this.cameraDistance += 5;
                        e.preventDefault();
                    }
                    // +/- : ì¼ë°˜ ì¤Œ
                    else if (e.key === '+' || e.key === '=') {
                        this.cameraDistance -= 10;
                        e.preventDefault();
                    } else if (e.key === '-') {
                        this.cameraDistance += 10;
                        e.preventDefault();
                    }
                    
                    // í•œê³„ ì ìš©
                    const minDist = Math.max(10, this.baseCameraDistance * 0.01);
                    const maxDist = Math.max(minDist + 500, this.baseCameraDistance * 25.0);
                    this.cameraDistance = Math.max(minDist, Math.min(maxDist, this.cameraDistance));
                });

                this.updateCamera = () => {
                    // íƒ€ê²Ÿì´ ì„¤ì •ë˜ì–´ ìˆìœ¼ë©´ íƒ€ê²Ÿ ì¤‘ì‹¬, ì—†ìœ¼ë©´ ë§µ ì¤‘ì‹¬
                    if (this.cameraTarget) {
                        // í¬ì»¤ìŠ¤ ëª¨ë“œì—ì„œë„ íŒ¨ë‹ ì˜¤í”„ì…‹ ì ìš©
                        const target = this.cameraTarget;
                        const baseX = target.x + this.cameraDistance * Math.sin(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                        const baseY = target.y + this.cameraDistance * Math.sin(this.cameraRotationX);
                        const baseZ = target.z + this.cameraDistance * Math.cos(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                        // íŒ¨ë‹ ì˜¤í”„ì…‹ ì ìš©
                        this.camera.position.set(
                            baseX + this.panOffset.x,
                            baseY + this.panOffset.y,
                            baseZ + this.panOffset.z
                        );
                        this.camera.lookAt(
                            target.x + this.panOffset.x,
                            target.y + this.panOffset.y,
                            target.z + this.panOffset.z
                        );
                    } else if (this.mapBounds) {
                        const bounds = this.mapBounds;
                        const baseX = bounds.centerX + this.cameraDistance * Math.sin(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                        const baseY = bounds.centerZ + this.cameraDistance * Math.sin(this.cameraRotationX);
                        const baseZ = bounds.centerY + this.cameraDistance * Math.cos(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                        // íŒ¨ë‹ ì˜¤í”„ì…‹ ì ìš©
                        this.camera.position.set(
                            baseX + this.panOffset.x,
                            baseY + this.panOffset.y,
                            baseZ + this.panOffset.z
                        );
                        this.camera.lookAt(
                            bounds.centerX + this.panOffset.x,
                            bounds.centerZ + this.panOffset.y,
                            bounds.centerY + this.panOffset.z
                        );
                    } else {
                        const baseX = this.cameraDistance * Math.sin(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                        const baseY = this.cameraDistance * Math.sin(this.cameraRotationX);
                        const baseZ = this.cameraDistance * Math.cos(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                        // íŒ¨ë‹ ì˜¤í”„ì…‹ ì ìš©
                        this.camera.position.set(
                            baseX + this.panOffset.x,
                            baseY + this.panOffset.y,
                            baseZ + this.panOffset.z
                        );
                        this.camera.lookAt(
                            this.panOffset.x,
                            this.panOffset.y,
                            this.panOffset.z
                        );
                    }
                };

                document.getElementById('play-btn').addEventListener('click', () => {
                    this.togglePlay();
                });

                document.getElementById('timeline').addEventListener('click', (e) => {
                    const rect = e.currentTarget.getBoundingClientRect();
                    const percent = (e.clientX - rect.left) / rect.width;
                    this.seekTo(percent);
                });

                document.querySelectorAll('.speed-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        const newSpeed = parseFloat(btn.dataset.speed);
                        console.log('ì¬ìƒ ì†ë„ ë³€ê²½:', this.playSpeed, '->', newSpeed);
                        this.playSpeed = newSpeed;
                        // ì¬ìƒ ì†ë„ ë³€ê²½ ì‹œ ì¦‰ì‹œ ë°˜ì˜ë˜ë„ë¡ lastUpdateTime ë¦¬ì…‹
                        this.lastUpdateTime = Date.now();
                    });
                });

                // ESC í‚¤ë¡œ í¬ì»¤ìŠ¤ ëª¨ë“œ ì¢…ë£Œ
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.focusMode) {
                        this.exitFocusMode();
                    }
                });

                // Reset view
                document.getElementById('reset-view').addEventListener('click', () => {
                    this.cameraRotationX = 0.3;
                    this.cameraRotationY = 0;
                    this.cameraDistance = this.baseCameraDistance;
                    this.cameraTarget = null; // íƒ€ê²Ÿ í•´ì œ
                    // íŒ¨ë‹ ì˜¤í”„ì…‹ ì´ˆê¸°í™”
                    if (this.panOffset) {
                        this.panOffset.x = 0;
                        this.panOffset.y = 0;
                        this.panOffset.z = 0;
                    }
                    this.updateCamera();
                });
            }

            setupResizableBottom() {
                const panel = document.getElementById('bottom-panel');
                const handle = document.getElementById('resize-handle');
                const minH = 160; // px
                const maxH = Math.floor(window.innerHeight * 0.8);
                // Load saved height
                const saved = localStorage.getItem('bottomPanelHeight');
                if (saved) panel.style.height = `${parseInt(saved,10)}px`;

                let dragging = false;
                let startY = 0;
                let startH = 0;

                handle.addEventListener('mousedown', (e) => {
                    dragging = true;
                    startY = e.clientY;
                    startH = panel.getBoundingClientRect().height;
                    document.body.style.userSelect = 'none';
                });

                window.addEventListener('mousemove', (e) => {
                    if (!dragging) return;
                    const dy = startY - e.clientY; // drag up increases height
                    let h = startH + dy;
                    h = Math.max(minH, Math.min(maxH, h));
                    panel.style.height = `${h}px`;
                });

                window.addEventListener('mouseup', () => {
                    if (!dragging) return;
                    dragging = false;
                    document.body.style.userSelect = '';
                    const h = panel.getBoundingClientRect().height;
                    localStorage.setItem('bottomPanelHeight', String(Math.round(h)));
                });
            }

            updateUI() {
                if (!this.data) return;

                const m = this.data.metadata;
                document.getElementById('total-players').textContent = m.players.length;
                document.getElementById('total-events').textContent = m.total_events;
                
                // ë§µ ì´ë¦„ ì—…ë°ì´íŠ¸
                const mapName = m.mapName || this.detectedMapName || 'Unknown';
                const mapNameElement = document.getElementById('map-name');
                if (mapNameElement) {
                    mapNameElement.textContent = mapName;
                }
                
                // ë§µ ì •ë³´ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
                const detectedMapNameElement = document.getElementById('detected-map-name');
                if (detectedMapNameElement) {
                    const source = this.detectedMapName ? (this.language === 'ko' ? '(ìœ„ì¹˜ ê¸°ë°˜ ì¶”ë¡ )' : '(Location-based inference)') : 
                                  (this.language === 'ko' ? '(ë°ì´í„° ê¸°ë°˜)' : '(Data-based)');
                    detectedMapNameElement.textContent = `${mapName} ${source}`;
                }
                
                const duration = m.time_range.max - m.time_range.min;
                const mins = Math.floor(duration / 60);
                const secs = Math.floor(duration % 60);
                document.getElementById('game-length').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
                document.getElementById('match-length').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
                
                // Match ID í‘œì‹œ
                const matchIdElement = document.getElementById('match-id');
                if (matchIdElement && m.matchInfo && m.matchInfo.match_id !== null) {
                    matchIdElement.textContent = m.matchInfo.match_id;
                } else if (matchIdElement) {
                    matchIdElement.textContent = '-';
                }
                
                // ì‹œì‘ ì‹œê°„ (timestampì—ì„œ ë‚ ì§œ ì¶”ì¶œ)
                const startDate = new Date();
                startDate.setTime(m.time_range.min * 1000);
                const startTimeElement = document.getElementById('start-time');
                if (startTimeElement) {
                    startTimeElement.textContent = startDate.toLocaleDateString('ko-KR') + ' ' + startDate.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });
                }
                
                // Match Start Time
                const matchStartTimeElement = document.getElementById('match-start-time');
                if (matchStartTimeElement) {
                    matchStartTimeElement.textContent = startDate.toLocaleDateString('ko-KR') + ' ' + startDate.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });
                }

                const playerList = document.getElementById('player-list');
                playerList.innerHTML = '';
                m.players.forEach(name => {
                    const stats = m.playerStats[name] || { kills: 0, deaths: 0, team: '' };
                    const item = document.createElement('div');
                    item.className = `player-item ${stats.team.toLowerCase()}`;
                    const kd = stats.deaths > 0 ? (stats.kills / stats.deaths).toFixed(2) : stats.kills.toFixed(2);
                    item.innerHTML = `
                        <span>${name}</span>
                        <span class="player-kd">${stats.kills}/${stats.deaths} (${kd})</span>
                    `;
                    item.style.cursor = 'pointer';
                    item.addEventListener('click', () => {
                        // í”Œë ˆì´ì–´ í´ë¦­ ì‹œ í•´ë‹¹ í”Œë ˆì´ì–´ê°€ ì°¸ì—¬í•œ í‚¬ ì´ë²¤íŠ¸ë¡œ í•„í„°ë§
                        const playerKills = this.data.events.filter(e => 
                            (e.attacker.name === name || e.victim.name === name) &&
                            (e.event_type_lower.includes('kill') || e.event_type_lower.includes('died'))
                        );
                        if (playerKills.length > 0) {
                            this.selectEvent(playerKills[0]);
                        }
                    });
                    playerList.appendChild(item);
                });

                this.updateEventLog();
            }

            populateKillPicker() {
                if (!this.data) return;
                const select = document.getElementById('kill-select');
                const goBtn = document.getElementById('go-kill');
                select.innerHTML = '';
                const kills = this.data.events.filter(e => (e.event_type_lower||'').includes('kill') || (e.event_type_lower||'').includes('died'));
                if (kills.length === 0) {
                    const opt = document.createElement('option');
                    opt.textContent = 'No kill events';
                    opt.value = '';
                    select.appendChild(opt);
                    goBtn.disabled = true;
                    return;
                }
                goBtn.disabled = false;
                kills.forEach((e, idx) => {
                    const opt = document.createElement('option');
                    const t = this.formatTime(e.game_time);
                    const label = `${t} ${e.attacker.name || 'Unknown'} â†’ ${e.victim.name || 'Unknown'}`;
                    opt.value = String(idx);
                    opt.textContent = label;
                    select.appendChild(opt);
                });

                goBtn.onclick = () => {
                    const i = parseInt(select.value);
                    if (isNaN(i)) return;
                    const e = kills[i];
                    this.selectEvent(e);
                };
            }

            populatePlayerPicker() {
                if (!this.data || !this.playerIndex) return;
                const select = document.getElementById('player-select');
                select.innerHTML = '<option value="">Players</option>';
                Array.from(this.playerIndex.keys()).sort().forEach(name => {
                    const opt = document.createElement('option');
                    opt.value = name;
                    opt.textContent = name;
                    select.appendChild(opt);
                });

                select.onchange = () => {
                    this.selectedPlayer = select.value || null;
                };

                document.getElementById('follow-toggle').onclick = () => {
                    if (!this.selectedPlayer) return;
                    this.followPlayer = !this.followPlayer;
                    document.getElementById('follow-toggle').textContent = this.followPlayer ? 'Following' : 'Follow';
                    if (!this.followPlayer) {
                        this.cameraTarget = null;
                    }
                };

                document.getElementById('prev-player-tick').onclick = () => {
                    this.seekToPlayerTick(-1);
                };
                document.getElementById('next-player-tick').onclick = () => {
                    this.seekToPlayerTick(1);
                };
            }

            seekToPlayerTick(direction) {
                if (!this.selectedPlayer || !this.playerIndex.has(this.selectedPlayer)) return;
                const arr = this.playerIndex.get(this.selectedPlayer);
                if (!arr || arr.length === 0) return;
                // í˜„ì¬ í‹± ê¸°ì¤€ ì´ì „/ë‹¤ìŒ í•­ëª© ì°¾ê¸°
                let idx = arr.findIndex(e => e.tick >= this.data.positions[this.currentTick].tick);
                if (idx === -1) idx = arr.length - 1;
                idx = idx + direction;
                idx = Math.max(0, Math.min(arr.length - 1, idx));
                const target = arr[idx];
                const tickIdx = this.findTickByTime(target.time);
                if (tickIdx !== -1) {
                    this.currentTick = tickIdx;
                    if (this.followPlayer) {
                        this.cameraTarget = { x: target.position[0], y: target.position[2], z: target.position[1] };
                    }
                    this.renderTick(this.currentTick);
                    this.updateTimeDisplay();
                }
            }

            updateEventLog() {
                if (!this.data) return;
                
                const eventLog = document.getElementById('event-log');
                eventLog.innerHTML = '';
                
                let eventsToShow = this.data.events;
                
                // í¬ì»¤ìŠ¤ ëª¨ë“œì¸ ê²½ìš° ì‹œê°„ ë²”ìœ„ í•„í„°ë§
                if (this.focusMode && this.focusTickRange) {
                    const startT = this.data.positions[this.focusTickRange.startIdx].game_time;
                    const endT = this.data.positions[this.focusTickRange.endIdx].game_time;
                    eventsToShow = this.data.events.filter(e => e.game_time >= startT && e.game_time <= endT);
                } else {
                    // í˜„ì¬ ì‹œê°„ ê¸°ì¤€ Â±5ì´ˆ ì´ë‚´ ì´ë²¤íŠ¸ í‘œì‹œ
                    const currentTickData = this.data.positions[this.currentTick];
                    const currentTime = currentTickData ? currentTickData.game_time : 0;
                    eventsToShow = this.data.events.filter(e => 
                        Math.abs(e.game_time - currentTime) < 5
                    );
                }
                
                eventsToShow.slice(0, 100).forEach((event, idx) => {
                    const item = document.createElement('div');
                    let className = 'event-item';
                    const isSelected = this.selectedEvent && this.selectedEvent.tick === event.tick;
                    
                    if (event.event_type_lower.includes('kill') || event.event_type_lower.includes('died')) {
                        className += ' kill';
                    } else if (event.event_type_lower.includes('attack')) {
                        className += ' attack';
                    } else if (event.event_type_lower.includes('hit')) {
                        className += ' hit';
                    }
                    
                    if (isSelected) {
                        className += ' selected';
                    }
                    
                    item.className = className;
                    
                    // HTMLë¡œ ìƒ‰ìƒ êµ¬ë¶„í•˜ì—¬ í‘œì‹œ
                    const time = this.formatTime(event.game_time);
                    let html = `<span class="event-time">${time}</span> `;
                    
                    if (event.event_type_lower.includes('kill') || event.event_type_lower.includes('died')) {
                        if (event.attacker.name && event.victim.name) {
                            html += `<span class="event-action">killed</span> `;
                            html += `<span class="event-victim">${event.victim.name}</span>`;
                            if (event.weapon) {
                                html += ` <span class="event-weapon">with ${event.weapon}</span>`;
                            }
                            html = `<span class="event-player">${event.attacker.name}</span> ` + html;
                        } else {
                            html += `<span class="event-action">${event.event_type}</span>`;
                        }
                    } else if (event.event_type_lower.includes('attack')) {
                        html += `<span class="event-player">${event.attacker.name || 'Unknown'}</span> `;
                        html += `<span class="event-action">initiated an Attack</span>`;
                        if (event.weapon) {
                            html += ` <span class="event-action">with weapon</span> <span class="event-weapon">${event.weapon}</span>`;
                        }
                    } else {
                        html += `<span class="event-action">${event.event_type}</span>`;
                    }
                    
                    item.innerHTML = html;
                    
                    // í´ë¦­ ì´ë²¤íŠ¸ ì¶”ê°€
                    item.addEventListener('click', () => {
                        this.selectEvent(event);
                    });
                    
                    eventLog.appendChild(item);
                });
                
                // ìŠ¤í¬ë¡¤ì„ ë§¨ ìœ„ë¡œ
                eventLog.scrollTop = 0;
            }

            selectEvent(event) {
                // ê¸°ì¡´ ì„ íƒ í•´ì œ
                if (this.selectedEvent) {
                    document.querySelectorAll('.event-item.selected').forEach(item => {
                        item.classList.remove('selected');
                    });
                }
                
                this.selectedEvent = event;
                
                // í¬ì»¤ìŠ¤ ëª¨ë“œ í™œì„±í™” (ì´ë²¤íŠ¸ ì „í›„ 30í‹±)
                this.focusMode = true;
                const centerIdx = this.findTickByTime(event.game_time);
                const startIdx = Math.max(0, centerIdx - 30);
                const endIdx = Math.min(this.data.positions.length - 1, centerIdx + 30);
                this.focusTickRange = { startIdx, endIdx, centerIdx };
                this.focusTimeRange = {
                    start: this.data.positions[startIdx].game_time,
                    end: this.data.positions[endIdx].game_time
                };
                
                // í•´ë‹¹ ì‹œê°„ìœ¼ë¡œ ì´ë™
                const targetTick = this.findTickByTime(event.game_time);
                if (targetTick !== -1) {
                    this.currentTick = targetTick;
                    this.renderTick(this.currentTick);
                    this.updateTimeDisplay();
                }
                
                // ê³µê²©ìë¥¼ ì‹œë®¬ë ˆì´ì…˜ ì¤‘ì•™ì— ë°°ì¹˜
                if (event.attacker.position[0] !== null && this.mapBounds) {
                    const attackerPos = {
                        x: event.attacker.position[0],
                        y: event.attacker.position[2],
                        z: event.attacker.position[1]
                    };
                    
                    // ì¹´ë©”ë¼ë¥¼ ê³µê²©ì ìœ„ì¹˜ë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ì¡°ì •
                    const bounds = this.mapBounds;
                    const maxDim = Math.max(bounds.width, bounds.height, bounds.depth);
                    this.cameraDistance = maxDim * 0.8;
                    
                    // ê³µê²©ì ìœ„ì¹˜ë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ì¹´ë©”ë¼ ë°°ì¹˜
                    this.cameraRotationX = 0.4;
                    this.cameraRotationY = Math.PI / 4; // 45ë„ ê°ë„
                    
                    // ì¹´ë©”ë¼ íƒ€ê²Ÿì„ ê³µê²©ì ìœ„ì¹˜ë¡œ ì„¤ì •
                    this.cameraTarget = attackerPos;
                    
                    // ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸
                    this.updateCameraToTarget();
                }
                
                // ì´ë²¤íŠ¸ ë¡œê·¸ ì—…ë°ì´íŠ¸
                this.updateEventLog();
                
                // í¬ì»¤ìŠ¤ ëª¨ë“œ í‘œì‹œ
                this.showFocusModeIndicator();
                // Aim Trace íƒ­ì´ ì—´ë ¤ìˆë‹¤ë©´ ê°±ì‹ 
                const activeTabEl = document.querySelector('.tab-btn.active');
                const activeTab = activeTabEl ? activeTabEl.getAttribute('data-tab') : null;
                if (activeTab === 'aim') this.renderAimTrace();
            }
            
            updateCameraToTarget() {
                if (!this.cameraTarget || !this.mapBounds) return;
                
                const target = this.cameraTarget;
                const x = target.x + this.cameraDistance * Math.sin(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                const y = target.y + this.cameraDistance * Math.sin(this.cameraRotationX);
                const z = target.z + this.cameraDistance * Math.cos(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                
                // íŒ¨ë‹ ì˜¤í”„ì…‹ ì ìš©
                this.camera.position.set(
                    x + (this.panOffset ? this.panOffset.x : 0),
                    y + (this.panOffset ? this.panOffset.y : 0),
                    z + (this.panOffset ? this.panOffset.z : 0)
                );
                this.camera.lookAt(
                    target.x + (this.panOffset ? this.panOffset.x : 0),
                    target.y + (this.panOffset ? this.panOffset.y : 0),
                    target.z + (this.panOffset ? this.panOffset.z : 0)
                );
            }

            findTickByTime(targetTime) {
                if (!this.data) return -1;
                
                let closestTick = 0;
                let minDiff = Infinity;
                
                this.data.positions.forEach((pos, idx) => {
                    const diff = Math.abs(pos.game_time - targetTime);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestTick = idx;
                    }
                });
                
                return closestTick;
            }

            showFocusModeIndicator() {
                // í¬ì»¤ìŠ¤ ëª¨ë“œ ì¸ë””ì¼€ì´í„° í‘œì‹œ
                const focusControls = document.getElementById('focus-controls');
                const timeDisplay = document.getElementById('time-display');
                
                if (this.focusMode && this.focusTimeRange) {
                    focusControls.classList.add('show');
                    const range = this.focusTimeRange.end - this.focusTimeRange.start;
                    const info = document.getElementById('focus-info');
                    info.textContent = `Focus: ${this.formatTime(this.focusTimeRange.start)} - ${this.formatTime(this.focusTimeRange.end)} (${this.formatTime(range)})`;
                    timeDisplay.style.color = '#4a90e2';
                    timeDisplay.style.fontWeight = 'bold';
                } else {
                    focusControls.classList.remove('show');
                    timeDisplay.style.color = '';
                    timeDisplay.style.fontWeight = '';
                }
            }

            exitFocusMode() {
                this.focusMode = false;
                this.focusTimeRange = null;
                this.selectedEvent = null;
                this.cameraTarget = null; // íƒ€ê²Ÿ í•´ì œ
                this.updateCamera();
                this.showFocusModeIndicator();
                this.updateEventLog();
            }

            renderTick(tickIndex) {
                if (!this.data || !this.data.positions) {
                    console.warn('renderTick: data ë˜ëŠ” positionsê°€ ì—†ìŠµë‹ˆë‹¤');
                    return;
                }

                const tickData = this.data.positions[tickIndex];
                if (!tickData) {
                    console.warn('renderTick: tickDataê°€ ì—†ìŠµë‹ˆë‹¤', { tickIndex, totalPositions: this.data.positions.length });
                    return;
                }

                if (!tickData.players || tickData.players.length === 0) {
                    console.warn('renderTick: playersê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤', { tickIndex, tick: tickData.tick });
                    // í”Œë ˆì´ì–´ê°€ ì—†ì–´ë„ ê¸°ì¡´ ì˜¤ë¸Œì íŠ¸ëŠ” ì œê±°
                    this.playerObjects.forEach(obj => this.scene.remove(obj));
                    this.playerLabels.forEach(obj => this.scene.remove(obj));
                    this.playerObjects.clear();
                    this.playerLabels.clear();
                    return;
                }

                // ë””ë²„ê¹…: ì²« ë²ˆì§¸ í‹±ì—ì„œ ëª¨ë“  í”Œë ˆì´ì–´ì˜ X, Y, Z ê°’ ì¶œë ¥
                if (tickIndex === 0) {
                    console.log('=== ì²« ë²ˆì§¸ í‹± í”Œë ˆì´ì–´ ì¢Œí‘œ ===');
                    console.log('ì´ í”Œë ˆì´ì–´ ìˆ˜:', tickData.players.length);
                    tickData.players.forEach((player, idx) => {
                        console.log(`í”Œë ˆì´ì–´ ${idx + 1} (${player.name}):`, {
                            position: player.position,
                            X: player.position[0],
                            Y: player.position[1], 
                            Z: player.position[2],
                            ThreeJS_X: player.position[0],
                            ThreeJS_Y: player.position[2],
                            ThreeJS_Z: player.position[1]
                        });
                    });
                }

                // ê¸°ì¡´ ì˜¤ë¸Œì íŠ¸ ì œê±°
                this.playerObjects.forEach(obj => this.scene.remove(obj));
                this.playerLabels.forEach(obj => this.scene.remove(obj));
                this.playerObjects.clear();
                this.playerLabels.clear();

                // í”Œë ˆì´ì–´ ë Œë”ë§
                for (let i = 0; i < tickData.players.length; i++) {
                    const player = tickData.players[i];
                    
                    // ìœ„ì¹˜ ë°ì´í„° ê²€ì¦
                    if (!player.position || !Array.isArray(player.position) || player.position.length < 3) {
                        console.error('í”Œë ˆì´ì–´ ìœ„ì¹˜ ë°ì´í„° ì˜¤ë¥˜:', player.name, player.position);
                        continue;
                    }
                    
                    const posX = player.position[0];
                    const posY = player.position[1];
                    const posZ = player.position[2];
                    
                    if (Number.isNaN(posX) || Number.isNaN(posY) || Number.isNaN(posZ)) {
                        console.error('í”Œë ˆì´ì–´ ìœ„ì¹˜ì— NaN:', player.name, { posX, posY, posZ });
                        continue;
                    }
                    
                    const isCT = player.team === 'CT';
                    const color = isCT ? 0x5b9bd5 : 0xff6b6b;
                    
                    // CTëŠ” ì›í˜•, TëŠ” ì‚¼ê°í˜•
                    let geometry;
                    if (isCT) {
                        geometry = new THREE.SphereGeometry(12, 16, 16);
                    } else {
                        geometry = new THREE.ConeGeometry(12, 24, 3);
                        geometry.rotateX(-Math.PI / 2);
                    }
                    
                    const material = new THREE.MeshPhongMaterial({ 
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.4
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    // Three.js ì¢Œí‘œê³„: positionì€ [X, Z, Y] í˜•ì‹ì´ë¯€ë¡œ [0], [2], [1] ìˆœì„œë¡œ ì„¤ì •
                    mesh.position.set(posX, posZ, posY);
                    this.scene.add(mesh);
                    this.playerObjects.set(player.name, mesh);
                    
                    // ë””ë²„ê¹…: ì²« ë²ˆì§¸ í”Œë ˆì´ì–´ì˜ ì‹¤ì œ ë Œë”ë§ ìœ„ì¹˜ ì¶œë ¥
                    if (i === 0 && tickIndex === 0) {
                        console.log('ì²« ë²ˆì§¸ í”Œë ˆì´ì–´ ë Œë”ë§ ìœ„ì¹˜:', {
                            name: player.name,
                            position_array: player.position,
                            mesh_position: { x: mesh.position.x, y: mesh.position.y, z: mesh.position.z },
                            camera_position: { x: this.camera.position.x, y: this.camera.position.y, z: this.camera.position.z }
                        });
                    }

                    // í”Œë ˆì´ì–´ ID ë¼ë²¨ (í¬ê²Œ)
                    // í˜„ì¬ í‹±ì— í‚¬ ì´ë²¤íŠ¸ê°€ ìˆê³  ì´ í”Œë ˆì´ì–´ê°€ ê³µê²©ìì¸ì§€ í™•ì¸
                    let isAttacker = false;
                    let attackerWeapon = null;
                    if (this.data && this.data.events) {
                        const currentTime = tickData.game_time;
                        const activeEvent = this.data.events.find(e => 
                            Math.abs(e.game_time - currentTime) < 0.05 && 
                            e.attacker && 
                            e.attacker.name === player.name
                        );
                        if (activeEvent) {
                            isAttacker = true;
                            attackerWeapon = activeEvent.weapon || null;
                        }
                    }
                    
                    // ë¼ë²¨ ë†’ì´ ì¡°ì • (ê³µê²©ìëŠ” í•œ ì¤„ì´ë¯€ë¡œ ë‚®ê²Œ)
                    const labelHeight = isAttacker ? 60 : 96;
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 512;
                    canvas.height = labelHeight;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // ë°°ê²½ í…Œë‘ë¦¬
                    ctx.strokeStyle = isCT ? '#5b9bd5' : '#ff6b6b';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
                    
                    let yPos = 40;
                    
                    // ê³µê²©ìì¸ ê²½ìš° í•œ ì¤„ë¡œ ê°„ë‹¨í•˜ê²Œ í‘œì‹œ
                    if (isAttacker) {
                        // ìºë¦­í„°ëª…(ì‚¬ìš©ë¬´ê¸°ì •ë³´, ê³µê²©ì êµ¬ë¶„) í˜•ì‹ìœ¼ë¡œ í•œ ì¤„ í‘œì‹œ
                        let labelText = player.name;
                        if (attackerWeapon) {
                            labelText += ` (${attackerWeapon}, attacker)`;
                        } else {
                            labelText += ' (attacker)';
                        }
                        
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 28px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(labelText, canvas.width / 2, yPos);
                    } else {
                        // ì¼ë°˜ í”Œë ˆì´ì–´ëŠ” ê¸°ì¡´ëŒ€ë¡œ
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 36px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(player.name, canvas.width / 2, yPos);
                    }
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                        map: texture,
                        transparent: true,
                        depthTest: false
                    }));
                    // ê³µê²©ìì¸ ê²½ìš° ë¼ë²¨ì„ ë” ìœ„ë¡œ ì˜¬ë ¤ì„œ ë‹¤ë¥¸ í”Œë ˆì´ì–´ì™€ ê²¹ì¹˜ì§€ ì•Šë„ë¡
                    const labelYOffset = isAttacker ? 50 : 35;
                    sprite.position.set(player.position[0], player.position[2] + labelYOffset, player.position[1]);
                    // ë¼ë²¨ ë†’ì´ì— ë§ì¶° ìŠ¤ì¼€ì¼ ì¡°ì • (ê³µê²©ìëŠ” í•œ ì¤„ì´ë¯€ë¡œ ë‚®ê²Œ)
                    const spriteHeight = isAttacker ? 30 : 30;
                    // ê³µê²©ì ë¼ë²¨ì€ í…ìŠ¤íŠ¸ê°€ ê¸¸ì–´ì§ˆ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë„ˆë¹„ë¥¼ ë„“ê²Œ
                    const spriteWidth = isAttacker ? 200 : 150;
                    sprite.scale.set(spriteWidth, spriteHeight, 1);
                    this.scene.add(sprite);
                    this.playerLabels.set(player.name, sprite);
                    
                    // íŠ¸ë ˆì¼ ì—…ë°ì´íŠ¸
                    this.updateTrail(player.name, player.position, color);
                }

                this.renderEvents(tickData.game_time);
                this.updateEventLog();
            }

            renderAllPlayerPaths() {
                // ê¸°ì¡´ ê²½ë¡œ ë¼ì¸ ì œê±°
                if (this.playerPathLines) {
                    this.playerPathLines.forEach(line => this.scene.remove(line));
                    this.playerPathLines.clear();
                } else {
                    this.playerPathLines = new Map();
                }
                
                if (!this.data || !this.data.positions) {
                    console.warn('renderAllPlayerPaths: ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤');
                    return;
                }
                
                console.log('=== ëª¨ë“  í”Œë ˆì´ì–´ ê²½ë¡œ ë Œë”ë§ ì‹œì‘ ===');
                
                // ê° í”Œë ˆì´ì–´ë³„ë¡œ ê²½ë¡œ ìˆ˜ì§‘
                const playerPaths = new Map();
                
                for (let i = 0; i < this.data.positions.length; i++) {
                    const tickData = this.data.positions[i];
                    if (!tickData || !tickData.players) continue;
                    
                    for (let j = 0; j < tickData.players.length; j++) {
                        const player = tickData.players[j];
                        if (!player.position || !Array.isArray(player.position) || player.position.length < 3) continue;
                        
                        if (!playerPaths.has(player.name)) {
                            playerPaths.set(player.name, []);
                        }
                        
                        const posX = player.position[0];
                        const posY = player.position[1];
                        const posZ = player.position[2];
                        
                        if (!Number.isNaN(posX) && !Number.isNaN(posY) && !Number.isNaN(posZ)) {
                            // Three.js ì¢Œí‘œê³„: [X, Z, Y]
                            playerPaths.get(player.name).push(new THREE.Vector3(posX, posZ, posY));
                        }
                    }
                }
                
                console.log('ê²½ë¡œ ìˆ˜ì§‘ ì™„ë£Œ:', playerPaths.size, 'ëª…ì˜ í”Œë ˆì´ì–´');
                
                // ê° í”Œë ˆì´ì–´ì˜ ê²½ë¡œë¥¼ ë¼ì¸ìœ¼ë¡œ ë Œë”ë§
                let pathCount = 0;
                playerPaths.forEach((points, playerName) => {
                    if (points.length < 2) return;
                    
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({ 
                        color: 0x00ff00, // ì´ˆë¡ìƒ‰ìœ¼ë¡œ ê²½ë¡œ í‘œì‹œ
                        opacity: 0.6,
                        transparent: true,
                        linewidth: 2
                    });
                    const line = new THREE.Line(geometry, material);
                    this.scene.add(line);
                    this.playerPathLines.set(playerName, line);
                    pathCount++;
                    
                    // ì²« ë²ˆì§¸ í”Œë ˆì´ì–´ì˜ ê²½ë¡œ ì •ë³´ ì¶œë ¥
                    if (pathCount === 1) {
                        console.log(`ì²« ë²ˆì§¸ í”Œë ˆì´ì–´ (${playerName}) ê²½ë¡œ:`, {
                            points_count: points.length,
                            first_point: { x: points[0].x, y: points[0].y, z: points[0].z },
                            last_point: { x: points[points.length - 1].x, y: points[points.length - 1].y, z: points[points.length - 1].z }
                        });
                    }
                });
                
                console.log('ê²½ë¡œ ë Œë”ë§ ì™„ë£Œ:', pathCount, 'ê°œ ê²½ë¡œ');
            }

            updateTrail(playerName, position, color) {
                if (!this.playerTrails.has(playerName)) {
                    const trailGeometry = new THREE.BufferGeometry();
                    const trailMaterial = new THREE.LineBasicMaterial({ 
                        color: color,
                        opacity: 0.4,
                        transparent: true,
                        linewidth: 2
                    });
                    const trail = new THREE.Line(trailGeometry, trailMaterial);
                    this.scene.add(trail);
                    this.playerTrails.set(playerName, {
                        line: trail,
                        points: []
                    });
                }

                const trail = this.playerTrails.get(playerName);
                trail.points.push(new THREE.Vector3(position[0], position[2], position[1]));
                
                if (trail.points.length > 100) {
                    trail.points.shift();
                }

                trail.line.geometry.setFromPoints(trail.points);
            }

            renderEvents(gameTime) {
                this.eventMarkers.forEach(m => this.scene.remove(m));
                this.eventMarkers = [];

                if (!this.data || !this.data.events) return;

                this.data.events.forEach(event => {
                    const timeDiff = Math.abs(event.game_time - gameTime);
                    // ì •í™•íˆ í•´ë‹¹ í‹±ì—ë§Œ í‘œì‹œ (0.05ì´ˆ ì´ë‚´, ì•½ 3í‹±)
                    // í¬ì»¤ìŠ¤ ëª¨ë“œì¼ ë•ŒëŠ” ì„ íƒëœ ì´ë²¤íŠ¸ë§Œ í‘œì‹œ
                    if (this.focusMode && this.selectedEvent) {
                        // í¬ì»¤ìŠ¤ ëª¨ë“œ: ì„ íƒëœ ì´ë²¤íŠ¸ì™€ ì¼ì¹˜í•˜ëŠ” ê²½ìš°ë§Œ í‘œì‹œ
                        if (event.tick !== this.selectedEvent.tick || 
                            !event.attacker || !this.selectedEvent.attacker ||
                            event.attacker.name !== this.selectedEvent.attacker.name ||
                            !event.victim || !this.selectedEvent.victim ||
                            event.victim.name !== this.selectedEvent.victim.name) {
                            return; // ì„ íƒëœ ì´ë²¤íŠ¸ê°€ ì•„ë‹ˆë©´ ìŠ¤í‚µ
                        }
                    }
                    
                    if (timeDiff < 0.05 && event.attacker.position[0] !== null) {
                        // ê³µê²©ì í”Œë ˆì´ì–´ë¥¼ ì› í…Œë‘ë¦¬ë¡œ ê°ì‹¸ê¸°
                        // í”Œë ˆì´ì–´ ëª¨ë¸ í¬ê¸°(ë°˜ì§€ë¦„ ì•½ 12-15)ë¥¼ ê³ ë ¤í•˜ì—¬ ì› í…Œë‘ë¦¬ ìƒì„±
                        const innerRadius = 18;
                        const outerRadius = 20;
                        const ringGeometry = new THREE.RingGeometry(innerRadius, outerRadius, 32);
                        const material = new THREE.MeshPhongMaterial({ 
                            color: 0xff0000,
                            emissive: 0xff0000,
                            emissiveIntensity: 0.6,
                            side: THREE.DoubleSide
                        });
                        const marker = new THREE.Mesh(ringGeometry, material);
                        // ê³µê²©ì í”Œë ˆì´ì–´ ìœ„ì¹˜ì— ë°°ì¹˜ (ì§€ë©´ ë†’ì´)
                        marker.position.set(
                            event.attacker.position[0],
                            event.attacker.position[2], // í”Œë ˆì´ì–´ì™€ ê°™ì€ ë†’ì´
                            event.attacker.position[1]
                        );
                        // ìˆ˜í‰ë©´ì— ë°°ì¹˜ (ì§€ë©´ì— ë†“ì¸ ì› í˜•íƒœ)
                        marker.rotation.x = -Math.PI / 2;
                        this.scene.add(marker);
                        this.eventMarkers.push(marker);

                        if (event.victim.position[0] !== null) {
                            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(
                                    event.attacker.position[0],
                                    event.attacker.position[2],
                                    event.attacker.position[1]
                                ),
                                new THREE.Vector3(
                                    event.victim.position[0],
                                    event.victim.position[2],
                                    event.victim.position[1]
                                )
                            ]);
                            const lineMaterial = new THREE.LineBasicMaterial({ 
                                color: 0xff6b6b,
                                opacity: 0.8,
                                transparent: true,
                                linewidth: 2
                            });
                            const line = new THREE.Line(lineGeometry, lineMaterial);
                            this.scene.add(line);
                            this.eventMarkers.push(line);

                            // Victim 'KILLED' label with HEADSHOT and fadeout
                            // ì •í™•íˆ í•´ë‹¹ í‹±ì—ë§Œ í‘œì‹œí•˜ê³  2ì´ˆê°„ í˜ì´ë“œì•„ì›ƒ
                            if (timeDiff < 2.0) {
                                const fadeStart = 1.5; // 1.5ì´ˆ í›„ë¶€í„° í˜ì´ë“œ ì‹œì‘
                                const fadeEnd = 2.0; // 2ì´ˆì— ì™„ì „íˆ ì‚¬ë¼ì§
                                let opacity = 1.0;
                                
                                if (timeDiff > fadeStart) {
                                    opacity = 1.0 - ((timeDiff - fadeStart) / (fadeEnd - fadeStart));
                                    opacity = Math.max(0, opacity);
                                }
                                
                                if (opacity > 0) {
                                    const canvas = document.createElement('canvas');
                                    const ctx = canvas.getContext('2d');
                                    // ë¬´ê¸° ì •ë³´ë¥¼ í¬í•¨í•œ í¬ê¸°ë¡œ ì„¤ì •
                                    // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì • (ë¬´ê¸° ì •ë³´ ì œê±°ë¡œ í¬ê¸° ì¶•ì†Œ)
                                    canvas.width = 280;
                                    canvas.height = 80;
                                    
                                    // ë°°ê²½ (íˆ¬ëª…ë„ ì ìš©)
                                    ctx.fillStyle = `rgba(0, 0, 0, ${0.85 * opacity})`;
                                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                                    
                                    // í…Œë‘ë¦¬
                                    ctx.strokeStyle = `rgba(255, 107, 107, ${opacity})`;
                                    ctx.lineWidth = 3;
                                    ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
                                    
                                    let yPos = 28;
                                    
                                    // DEAD í…ìŠ¤íŠ¸ (victim ê´€ì )
                                    ctx.fillStyle = `rgba(255, 107, 107, ${opacity})`;
                                    ctx.font = 'bold 26px Arial';
                                    ctx.textAlign = 'center';
                                    ctx.fillText('DEAD', canvas.width / 2, yPos);
                                    
                                    // HEADSHOT í‘œì‹œ (í—¤ë“œìƒ·ì¸ ê²½ìš°)
                                    if (event.headshot) {
                                        yPos += 22;
                                        ctx.fillStyle = `rgba(255, 215, 0, ${opacity})`;
                                        ctx.font = 'bold 16px Arial';
                                        ctx.fillText('HEADSHOT', canvas.width / 2, yPos);
                                    }
                                    
                                    // victim í…ìŠ¤íŠ¸
                                    yPos += 20;
                                    ctx.fillStyle = `rgba(255, 107, 107, ${opacity})`;
                                    ctx.font = '12px Arial';
                                    ctx.fillText('victim', canvas.width / 2, yPos);
                                    
                                    const tex = new THREE.CanvasTexture(canvas);
                                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                                        map: tex, 
                                        transparent: true,
                                        opacity: opacity,
                                        depthTest: false // í•­ìƒ ì•ì— í‘œì‹œ
                                    }));
                                    sprite.position.set(
                                        event.victim.position[0],
                                        event.victim.position[2] + 70, // ë” ìœ„ë¡œ ì˜¬ë¦¼
                                        event.victim.position[1]
                                    );
                                    sprite.scale.set(140, 40, 1); // í¬ê¸° ì¡°ì • (ë¬´ê¸° ì •ë³´ ì œê±°ë¡œ ì›ë˜ í¬ê¸°ë¡œ ë³µì›)
                                    this.scene.add(sprite);
                                    this.eventMarkers.push(sprite);
                                }
                            }
                        }
                    }
                });
            }

            togglePlay() {
                this.isPlaying = !this.isPlaying;
                document.getElementById('play-btn').textContent = this.isPlaying ? 'â¸' : 'â–¶';
            }

            seekTo(percent) {
                if (!this.data) return;
                const maxTick = this.data.positions.length - 1;
                this.currentTick = Math.floor(percent * maxTick);
                this.renderTick(this.currentTick);
                this.updateTimeDisplay();
            }

            updateTimeDisplay() {
                if (!this.data) return;
                
                const tickData = this.data.positions[this.currentTick];
                if (tickData) {
                    const m = this.data.metadata;
                    const currentTime = tickData.game_time - m.time_range.min;
                    const totalTime = m.time_range.max - m.time_range.min;
                    
                    document.getElementById('time-display').textContent = 
                        `${this.formatTime(currentTime)} / ${this.formatTime(totalTime)}`;
                    
                    const progress = (this.currentTick / (this.data.positions.length - 1)) * 100;
                    document.getElementById('timeline-progress').style.width = `${progress}%`;
                }
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                const ms = Math.floor((seconds % 1) * 1000);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                if (this.updateCamera) {
                    this.updateCamera();
                }

                if (this.isPlaying && this.data) {
                    const now = Date.now();
                    if (!this.lastUpdateTime) {
                        this.lastUpdateTime = now;
                    }
                    
                    // í‹± ê°„ ì‹œê°„ ê³„ì‚° (ì‹¤ì œ ê²Œì„ í‹± ì†ë„ ê¸°ë°˜)
                    const tickData = this.data.positions[this.currentTick];
                    const nextTickData = this.data.positions[this.currentTick + 1];
                    
                    let shouldAdvance = false;
                    let delta = now - this.lastUpdateTime;
                    
                    if (tickData && nextTickData) {
                        const tickInterval = (nextTickData.game_time - tickData.game_time) * 1000; // ms
                        if (tickInterval > 0 && !Number.isNaN(tickInterval)) {
                            // playSpeed ì ìš©: 1xë©´ ì›ë˜ ì†ë„, 0.5xë©´ 2ë°° ëŠë¦¬ê²Œ, 2xë©´ 2ë°° ë¹ ë¥´ê²Œ
                            const targetInterval = tickInterval / this.playSpeed;
                            
                            // playSpeedì— ë”°ë¼ í‹± ì§„í–‰ ì†ë„ ì¡°ì ˆ
                            shouldAdvance = delta >= targetInterval;
                            
                            // ë¹ ë¥¸ ì†ë„ì¼ ë•Œ ì—¬ëŸ¬ í‹±ì„ í•œ ë²ˆì— ê±´ë„ˆë›°ê¸°
                            if (shouldAdvance && this.playSpeed > 1) {
                                const ticksToSkip = Math.floor(delta / targetInterval);
                                if (ticksToSkip > 1) {
                                    // ì—¬ëŸ¬ í‹± ê±´ë„ˆë›°ê¸° (ìµœëŒ€ 10í‹±)
                                    const skipCount = Math.min(ticksToSkip - 1, 10);
                                    this.currentTick += skipCount;
                                    shouldAdvance = false; // ì´ë¯¸ ì¦ê°€í–ˆìœ¼ë¯€ë¡œ ì¶”ê°€ ì¦ê°€ ë°©ì§€
                                }
                            }
                            
                            // ë””ë²„ê¹… (ê°€ë”ë§Œ ì¶œë ¥)
                            if (this.currentTick % 100 === 0) {
                                console.log('ì¬ìƒ ì†ë„:', this.playSpeed + 'x', 'í‹± ê°„ê²©:', tickInterval.toFixed(2) + 'ms', 'ëª©í‘œ ê°„ê²©:', targetInterval.toFixed(2) + 'ms', 'ì‹¤ì œ delta:', delta.toFixed(2) + 'ms');
                            }
                        } else {
                            // í‹± ê°„ê²©ì´ ì—†ê±°ë‚˜ ì˜ëª»ëœ ê²½ìš° ê¸°ë³¸ ê°„ê²© ì‚¬ìš©
                            const baseInterval = 16.67 / this.playSpeed; // ê¸°ë³¸ 60fps ê¸°ì¤€ (16.67ms)
                            shouldAdvance = delta >= baseInterval;
                        }
                    } else {
                        // ë‹¤ìŒ í‹± ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ ê°„ê²© ì‚¬ìš©
                        const baseInterval = 16.67 / this.playSpeed; // ê¸°ë³¸ 60fps ê¸°ì¤€ (16.67ms)
                        shouldAdvance = delta >= baseInterval;
                    }
                    
                    // ì¬ìƒ ì¤‘ì—ëŠ” í•­ìƒ í˜„ì¬ í‹±ì„ ë Œë”ë§ (shouldAdvanceì™€ ê´€ê³„ì—†ì´)
                    if (this.currentTick < this.data.positions.length) {
                        // Follow selected player if enabled
                        if (this.followPlayer && this.selectedPlayer && this.playerIndex.has(this.selectedPlayer)) {
                            const arr = this.playerIndex.get(this.selectedPlayer);
                            const tick = this.data.positions[this.currentTick].tick;
                            const entry = arr.find(e => e.tick === tick);
                            if (entry) {
                                this.cameraTarget = { x: entry.position[0], y: entry.position[2], z: entry.position[1] };
                            }
                        }
                        this.renderTick(this.currentTick);
                        this.updateTimeDisplay();
                        // Aim trace ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ (íƒ­ì´ ì—´ë ¤ìˆì„ ë•Œ)
                        const activeTabEl3 = document.querySelector('.tab-btn.active');
                        const activeTab3 = activeTabEl3 ? activeTabEl3.getAttribute('data-tab') : null;
                        if (activeTab3 === 'aim') this.renderAimTrace();
                    }
                    
                    if (shouldAdvance) {
                        this.currentTick += 1;
                        
                        // í¬ì»¤ìŠ¤ ëª¨ë“œì¸ ê²½ìš° ë²”ìœ„ ì²´í¬ (í‹± ê¸°ë°˜)
                        if (this.focusMode && this.focusTickRange) {
                            if (this.currentTick > this.focusTickRange.endIdx) {
                                this.currentTick = this.focusTickRange.startIdx;
                                this.isPlaying = false;
                                document.getElementById('play-btn').textContent = 'â–¶';
                            }
                        }
                        
                        if (this.currentTick >= this.data.positions.length) {
                            this.currentTick = this.data.positions.length - 1;
                            this.isPlaying = false;
                            document.getElementById('play-btn').textContent = 'â–¶';
                        }
                        this.lastUpdateTime = now;
                    }
                }

                this.renderer.render(this.scene, this.camera);
            }
        }

        // ì¦‰ì‹œ ì‹¤í–‰í•˜ì—¬ ì´ˆê¸°í™” ë³´ì¥
        (function() {
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
            new CombatSimulation();
        });
            } else {
                // DOMì´ ì´ë¯¸ ë¡œë“œëœ ê²½ìš° ì¦‰ì‹œ ì‹¤í–‰
                new CombatSimulation();
            }
        })();
    </script>
</body>
</html>

