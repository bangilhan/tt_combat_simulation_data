<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRUMB â€” Combat Replay Unified Monitoring & Behavior-analysis</title>
    <link rel="icon" type="image/png" href="crumb_logo.png" onerror="this.href='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ</text></svg>'">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0f1419;
            color: #fff;
            overflow: hidden;
        }

        #top-nav {
            height: 50px;
            background: #1a1f2e;
            border-bottom: 1px solid #2a2f3e;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 30px;
            position: relative;
            z-index: 1000;
            width: 100%;
        }

        #brand-logo {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-right: 30px;
            padding-right: 30px;
            border-right: 1px solid #2a2f3e;
        }

        #brand-logo img {
            height: 32px;
            width: auto;
            object-fit: contain;
        }

        #brand-text {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        #brand-name {
            font-size: 13px;
            font-weight: 600;
            color: #fff;
            letter-spacing: 0.5px;
        }

        #brand-tagline {
            font-size: 10px;
            color: #8a8fa5;
            font-style: italic;
        }

        .nav-item {
            padding: 8px 16px;
            cursor: pointer;
            color: #8a8fa5;
            font-size: 14px;
            transition: color 0.2s;
        }

        .nav-item:hover {
            color: #fff;
        }

        .nav-item.active {
            color: #4a90e2;
            border-bottom: 2px solid #4a90e2;
        }

        #container {
            display: flex;
            height: calc(100vh - 50px);
            visibility: visible;
        }

        #sidebar {
            width: 350px;
            background: #1a1f2e;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #2a2f3e;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            background: #0a0e15;
            display: block;
            visibility: visible;
        }

        #dashboard-view {
            flex: 1;
            padding: 40px;
            overflow-y: auto;
            overflow-x: hidden;
            background: #0f1419;
            display: block;
            height: calc(100vh - 50px);
        }

        #dashboard-view.hidden {
            display: none;
        }

        #dashboard-content {
            max-width: 900px;
            margin: 0 auto;
            color: #fff;
            padding-right: 20px;
        }

        #dashboard-content h1 {
            font-size: 32px;
            margin-bottom: 20px;
            color: #fff;
        }

        #dashboard-content h2 {
            font-size: 24px;
            margin-top: 30px;
            margin-bottom: 15px;
            color: #4a90e2;
            border-bottom: 2px solid #2a2f3e;
            padding-bottom: 10px;
        }

        #dashboard-content h3 {
            font-size: 18px;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #8a8fa5;
        }

        #dashboard-content h4 {
            font-size: 16px;
            margin-top: 15px;
            margin-bottom: 8px;
            color: #6a6f85;
            font-weight: 600;
        }

        #dashboard-content p, #dashboard-content li {
            line-height: 1.6;
            color: #c0c5d0;
            margin-bottom: 10px;
        }

        #dashboard-content strong {
            color: #fff;
            font-weight: 600;
        }

        #dashboard-content ul, #dashboard-content ol {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        #dashboard-content code {
            background: #1a1f2e;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #4a90e2;
        }

        #dashboard-content pre {
            background: #1a1f2e;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
        }

        #dashboard-content pre code {
            background: none;
            padding: 0;
            color: #c0c5d0;
        }

        #dashboard-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }

        #dashboard-content table th,
        #dashboard-content table td {
            border: 1px solid #2a2f3e;
            padding: 10px;
            text-align: left;
        }

        #dashboard-content table th {
            background: #1a1f2e;
            color: #4a90e2;
        }

        #canvas {
            width: 100%;
            height: 100%;
        }

        /* GitHub CSV ì„ íƒ íŒì—… */
        #csv-popup {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        #csv-popup.active {
            display: flex;
        }

        #csv-popup-content {
            background: #1a1f2e;
            border: 1px solid #2a2f3e;
            border-radius: 8px;
            padding: 20px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        #csv-popup-content h3 {
            margin-top: 0;
            color: #fff;
            margin-bottom: 15px;
        }

        #csv-file-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #csv-file-list li {
            padding: 12px;
            margin-bottom: 8px;
            background: #2a2f3e;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            color: #fff;
        }

        #csv-file-list li:hover {
            background: #3a3f4e;
        }

        #csv-popup-close {
            margin-top: 15px;
            padding: 10px 20px;
            background: #4a90e2;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        #csv-popup-close:hover {
            background: #5aa0f2;
        }

        #bottom-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 300px;
            background: rgba(26, 31, 46, 0.98);
            border-top: 1px solid #2a2f3e;
            display: flex;
            flex-direction: column;
        }

        /* drag handle to resize bottom panel */
        #resize-handle {
            height: 6px;
            cursor: ns-resize;
            background: linear-gradient(180deg, #2a2f3e, #1a1f2e);
        }
        #resize-handle:hover {
            background: linear-gradient(180deg, #3a3f4e, #1f2738);
        }

        #controls {
            padding: 15px 20px;
            border-bottom: 1px solid #2a2f3e;
        }

        #event-tabs {
            display: flex;
            gap: 10px;
            padding: 10px 20px;
            border-bottom: 1px solid #2a2f3e;
            background: #1a1f2e;
        }

        .tab-btn {
            padding: 8px 16px;
            background: transparent;
            border: none;
            color: #8a8fa5;
            cursor: pointer;
            font-size: 13px;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab-btn:hover {
            color: #fff;
        }

        .tab-btn.active {
            color: #4a90e2;
            border-bottom-color: #4a90e2;
        }

        #event-log {
            flex: 1;
            overflow-y: auto;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }

        .event-item {
            padding: 6px 8px;
            margin-bottom: 4px;
            background: #2a2f3e;
            border-radius: 3px;
            color: #8a8fa5;
            border-left: 3px solid transparent;
            cursor: pointer;
            transition: background 0.2s;
        }

        .event-item:hover {
            background: #3a3f4e;
        }

        .event-item.selected {
            background: #4a4f5e;
            border-left-color: #4a90e2;
        }

        .event-item.kill {
            border-left-color: #ff6b6b;
        }

        .event-item.attack {
            border-left-color: #ffa500;
        }

        .event-item.hit {
            border-left-color: #4a90e2;
        }

        .event-time {
            color: #6b9bd5;
            font-weight: 600;
        }

        .event-player {
            color: #4a90e2;
            font-weight: 500;
        }

        .event-victim {
            color: #ff6b6b;
            font-weight: 500;
        }

        .event-action {
            color: #8a8fa5;
        }

        .event-weapon {
            color: #ffa500;
            font-style: italic;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .play-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #4a90e2;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .play-btn:hover {
            background: #5aa0f2;
        }

        .timeline {
            flex: 1;
            height: 6px;
            background: #2a2f3e;
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }

        .timeline-progress {
            height: 100%;
            background: #4a90e2;
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s;
        }

        .time-display {
            min-width: 100px;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .speed-btn {
            padding: 5px 10px;
            background: #2a2f3e;
            border: 1px solid #3a3f4e;
            color: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
        }

        .speed-btn.active {
            background: #4a90e2;
            border-color: #4a90e2;
        }

        .sidebar-section {
            margin-bottom: 25px;
        }

        .sidebar-section h3 {
            font-size: 12px;
            color: #8a8fa5;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #2a2f3e;
            font-size: 12px;
        }

        .stat-label {
            color: #8a8fa5;
        }

        .stat-value {
            color: #fff;
            font-weight: 500;
        }

        .stat-group {
            margin-bottom: 15px;
        }

        .stat-group-title {
            font-size: 11px;
            color: #6a6f85;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #file-input {
            margin-bottom: 20px;
            padding: 12px;
            background: #2a2f3e;
            border-radius: 6px;
            border: 1px solid #3a3f4e;
        }

        #file-input input[type="file"] {
            color: white;
            font-size: 12px;
        }

        #loading {
            text-align: center;
            padding: 20px;
            color: #8a8fa5;
            font-size: 14px;
        }

        .player-item {
            padding: 8px;
            margin-bottom: 5px;
            background: #2a2f3e;
            border-radius: 4px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-item.ct {
            border-left: 3px solid #5b9bd5;
        }

        .player-item.terrorist {
            border-left: 3px solid #ff6b6b;
        }

        .player-kd {
            font-size: 11px;
            color: #8a8fa5;
        }

        #map-info {
            background: #2a2f3e;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
        }

        #map-info-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        #map-bounds {
            font-size: 11px;
            color: #8a8fa5;
            font-family: 'Courier New', monospace;
        }

        #focus-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(26, 31, 46, 0.95);
            padding: 15px;
            border-radius: 8px;
            display: none;
            z-index: 100;
        }

        #focus-controls.show {
            display: block;
        }

        #focus-controls button {
            padding: 8px 16px;
            background: #4a90e2;
            border: none;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 10px;
        }

        #focus-controls button:hover {
            background: #5aa0f2;
        }

        #focus-info {
            font-size: 12px;
            color: #8a8fa5;
            margin-bottom: 10px;
        }

        /* Kill event picker (top-left of canvas) */
        #event-picker {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(26, 31, 46, 0.95);
            border: 1px solid #2a2f3e;
            border-radius: 8px;
            padding: 10px;
            display: flex;
            gap: 8px;
            align-items: center;
            z-index: 120;
        }

        #event-picker select, #event-picker button {
            background: #2a2f3e;
            border: 1px solid #3a3f4e;
            color: #fff;
            border-radius: 4px;
            padding: 6px 8px;
            font-size: 12px;
        }

        #event-picker button.primary {
            background: #4a90e2;
            border-color: #4a90e2;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="top-nav">
        <div id="brand-logo">
            <img id="brand-image" src="crumb_logo.png" alt="CRUMB Logo" onerror="this.style.display='none'">
            <div id="brand-text">
                <div id="brand-name">CRUMB â€” Combat Replay Unified Monitoring & Behavior-analysis</div>
                <div id="brand-tagline">"Follow every trace." ğŸ</div>
            </div>
        </div>
        <div class="nav-item active">Dashboard</div>
        <div class="nav-item">Manage</div>
        <div class="nav-item">Investigate</div>
        <div class="nav-item" id="report-tab">Generate Report</div>
    </div>

    <div id="container" style="display: none;">
        <div id="sidebar">
            <div class="sidebar-section">
                <h3>File Load</h3>
                <div id="file-input">
                    <button id="select-csv-btn" style="width: 100%; padding: 10px; background: #4a90e2; color: #fff; border: none; border-radius: 4px; cursor: pointer; margin-bottom: 10px;">íŒŒì¼ ì„ íƒ</button>
                    <div id="selected-file" style="font-size: 12px; color: #8a8fa5; margin-bottom: 10px;">ì„ íƒëœ íŒŒì¼ ì—†ìŒ</div>
                    <input type="file" id="csv-file" accept=".csv" style="display: none;" />
                    <div id="loading" style="display: none;">CSV íŒŒì¼ ì²˜ë¦¬ ì¤‘...</div>
                </div>
            </div>

            

            <div class="sidebar-section">
                <h3>Statistics</h3>
                
                <div class="stat-group">
                    <div class="stat-group-title">Title</div>
                    <div class="stat-item">
                        <span class="stat-label">Name:</span>
                        <span class="stat-value" id="game-name">CS2</span>
                    </div>
                </div>

                <div class="stat-group">
                    <div class="stat-group-title">Game</div>
                    <div class="stat-item">
                        <span class="stat-label">Server:</span>
                        <span class="stat-value">Valve-Counter-Strike</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Game Mode:</span>
                        <span class="stat-value">SourceTV-Demo</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Start time:</span>
                        <span class="stat-value" id="start-time">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Length:</span>
                        <span class="stat-value" id="game-length">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Players:</span>
                        <span class="stat-value" id="total-players">-</span>
                    </div>
                </div>

                <div class="stat-group">
                    <div class="stat-group-title">Match</div>
                    <div class="stat-item">
                        <span class="stat-label">Match Start Time:</span>
                        <span class="stat-value" id="match-start-time">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Match Length:</span>
                        <span class="stat-value" id="match-length">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Match Mode:</span>
                        <span class="stat-value">5v5</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Map Name:</span>
                        <span class="stat-value" id="map-name">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Total Events:</span>
                        <span class="stat-value" id="total-events">-</span>
                    </div>
                </div>

                <div id="map-info">
                    <div id="map-info-title">Map Bounds</div>
                    <div id="map-bounds">Calculating...</div>
                    <div style="margin-top: 10px; padding: 10px; background: #1a1f2e; border-radius: 4px; font-size: 11px; color: #8a8fa5;">
                        <div style="margin-bottom: 5px;"><strong>ë§µ ë Œë”ë§ ì •ë³´:</strong></div>
                        <div>í˜„ì¬ ë§µ: Anubis (ë°ì´í„° ê¸°ë°˜)</div>
                        <div style="margin-top: 5px;">ë§µ ì§€ì˜¤ë©”íŠ¸ë¦¬ ë°ì´í„°ëŠ” CS2 ê²Œì„ íŒŒì¼(.bsp)ì—ì„œ ì¶”ì¶œí•˜ê±°ë‚˜</div>
                        <div>ì™¸ë¶€ ë§µ ë°ì´í„° APIë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.</div>
                        <div style="margin-top: 5px; color: #4a90e2;">ì°¸ê³ : í˜„ì¬ëŠ” í”Œë ˆì´ì–´ ìœ„ì¹˜ ê¸°ë°˜ ê²½ê³„ë§Œ í‘œì‹œë©ë‹ˆë‹¤.</div>
                    </div>
                </div>

                <div class="stat-group">
                    <div class="stat-group-title">Players (K/D Ratio)</div>
                    <div style="font-size: 10px; color: #6a6f85; margin-bottom: 8px; font-style: italic;">
                        K/D: Kills / Deaths - Click to filter
                    </div>
                    <div id="player-list"></div>
                </div>
            </div>
        </div>

        <div id="canvas-container">
            <canvas id="canvas"></canvas>
            <div id="event-picker">
                <select id="kill-select">
                    <option value="">Kill events will appear here</option>
                </select>
                <button id="go-kill" class="primary">Go</button>
                <button id="reset-view">Reset View</button>

                <span style="width:12px"></span>
                <select id="player-select">
                    <option value="">Players</option>
                </select>
                <button id="prev-player-tick">Prev</button>
                <button id="next-player-tick">Next</button>
                <button id="follow-toggle">Follow</button>
            </div>
            <div id="focus-controls">
                <div id="focus-info">Focus Mode: Event selected</div>
                <button id="exit-focus-btn">Exit Focus Mode</button>
            </div>
        </div>
    </div>

    

    <div id="bottom-panel">
        <div id="resize-handle" title="Drag to resize"></div>
        <div id="controls">
            <div class="control-group">
                <button class="play-btn" id="play-btn">â–¶</button>
                <div class="timeline" id="timeline">
                    <div class="timeline-progress" id="timeline-progress"></div>
                </div>
                <div class="time-display" id="time-display">00:00 / 00:00</div>
                <div class="speed-control">
                    <button class="speed-btn" data-speed="0.5">0.5x</button>
                    <button class="speed-btn active" data-speed="1">1x</button>
                    <button class="speed-btn" data-speed="2">2x</button>
                    <button class="speed-btn" data-speed="3">3x</button>
                </div>
            </div>
        </div>

        <div id="event-tabs">
            <button class="tab-btn active" data-tab="actions">Action Stream</button>
            <button class="tab-btn" data-tab="chat">Match Chat</button>
            <button class="tab-btn" data-tab="aim">Aim Trace</button>
        </div>

        <div id="event-log"></div>
    </div>

    <!-- Dashboard View -->
    <div id="dashboard-view" style="display: block;">
        <div id="dashboard-content"></div>
    </div>
    
    <script>
        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì¦‰ì‹œ Dashboard í‘œì‹œ ë³´ì¥ (ìµœìš°ì„  ì‹¤í–‰)
        (function() {
            function initDashboard() {
                const dashboardView = document.getElementById('dashboard-view');
                const container = document.getElementById('container');
                const bottomPanel = document.getElementById('bottom-panel');
                const topNav = document.getElementById('top-nav');
                
                // ìƒë‹¨ ë„¤ë¹„ê²Œì´ì…˜ í•­ìƒ í‘œì‹œ
                if (topNav) {
                    topNav.style.display = 'flex';
                    topNav.style.visibility = 'visible';
                }
                
                // Dashboard í‘œì‹œ
                if (dashboardView) {
                    dashboardView.style.display = 'block';
                    dashboardView.style.visibility = 'visible';
                    dashboardView.classList.remove('hidden');
                }
                
                // Container ìˆ¨ê¸°ê¸°
                if (container) {
                    container.style.display = 'none';
                    container.style.visibility = 'hidden';
                }
                
                // í•˜ë‹¨ íŒ¨ë„ ìˆ¨ê¸°ê¸°
                if (bottomPanel) {
                    bottomPanel.style.display = 'none';
                    bottomPanel.style.visibility = 'hidden';
                }
            }
            
            // ì¦‰ì‹œ ì‹¤í–‰
            initDashboard();
            
            // DOM ë¡œë“œ í›„ì—ë„ ì‹¤í–‰
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initDashboard);
            }
            
            // ì¶”ê°€ ë³´ì¥ì„ ìœ„í•´ ì•½ê°„ì˜ ì§€ì—° í›„ ì‹¤í–‰
            setTimeout(initDashboard, 100);
        })();
    </script>

    <!-- GitHub CSV ì„ íƒ íŒì—… -->
    <div id="csv-popup">
        <div id="csv-popup-content">
            <h3>í˜„ì¬ ê²½ë¡œì—ì„œ í™•ì¸ë˜ëŠ” ë¦¬í”Œë ˆì´ íŒŒì¼ ì„ íƒ</h3>
            <div id="csv-loading" style="color: #8a8fa5;">íŒŒì¼ ëª©ë¡ ë¡œë”© ì¤‘...</div>
            <ul id="csv-file-list"></ul>
            <button id="csv-popup-close">ë‹«ê¸°</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script>
        class CombatSimulation {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                
                this.data = null;
                this.currentTick = 0;
                this.isPlaying = false;
                this.playSpeed = 1;
                
                this.playerObjects = new Map();
                this.playerLabels = new Map();
                this.playerTrails = new Map();
                this.eventMarkers = [];
                this.mapBounds = null;
                this.selectedEvent = null;
                this.focusMode = false;
                this.focusTimeRange = null;
                this.focusTickRange = null;
                this.baseCameraDistance = 1500;
                this.cameraRotationX = 0.3;
                this.cameraRotationY = 0;
                this.cameraDistance = 1500;
                this.killLabels = new Map(); // í‚¬ ë¼ë²¨ ì¶”ì  (í˜ì´ë“œì•„ì›ƒìš©)
                this.playerIndex = new Map(); // name -> [{tick, pos}]
                this.selectedPlayer = null;
                this.followPlayer = false;
                
                this.init();
            }

            init() {
                this.setupScene();
                this.setupControls();
                this.setupFileInput();
                this.setupTabs();
                this.setupResizableBottom();
                this.setupNavigation();
                // ì´ˆê¸° ë¡œë“œ ì‹œ Dashboard í‘œì‹œ
                this.showDashboard();
                this.animate();
            }

            setupFileInput() {
                const selectBtn = document.getElementById('select-csv-btn');
                const inputEl = document.getElementById('csv-file');
                
                if (selectBtn) {
                    selectBtn.addEventListener('click', () => {
                        this.showCSVPopup();
                    });
                }
                
                if (!inputEl) {
                    console.error('íŒŒì¼ ì…ë ¥ ìš”ì†Œ(#csv-file)ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }
                // ê°™ì€ íŒŒì¼ì„ ì—°ì† ì„ íƒí•  ë•Œ change ì´ë²¤íŠ¸ê°€ ì•ˆ ëœ¨ëŠ” ë¬¸ì œ ë°©ì§€
                inputEl.addEventListener('click', () => {
                    inputEl.value = '';
                });
                inputEl.addEventListener('change', (e) => {
                    const file = e.target.files && e.target.files[0];
                    const loading = document.getElementById('loading');
                    if (loading) {
                        loading.style.display = 'block';
                        loading.innerHTML = 'Parsing CSV file...';
                    }
                    if (file) {
                        console.log('CSV íŒŒì¼ ì„ íƒë¨:', file.name, file.size, 'bytes');
                        document.getElementById('selected-file').textContent = file.name;
                        this.loadCSV(file);
                    } else {
                        console.warn('ì„ íƒëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.');
                        if (loading) loading.style.display = 'none';
                    }
                });

                // íŒì—… ë‹«ê¸° ë²„íŠ¼
                const closeBtn = document.getElementById('csv-popup-close');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => {
                        document.getElementById('csv-popup').classList.remove('active');
                    });
                }
            }

            setupNavigation() {
                const navItems = document.querySelectorAll('.nav-item');
                navItems.forEach(item => {
                    item.addEventListener('click', () => {
                        const text = item.textContent.trim();
                        if (text === 'Dashboard') {
                            this.showDashboard();
                        } else if (text === 'Investigate') {
                            this.showInvestigate();
                        } else {
                            // ë‹¤ë¥¸ íƒ­ë“¤ì€ ë‚˜ì¤‘ì— êµ¬í˜„
                            navItems.forEach(n => n.classList.remove('active'));
                            item.classList.add('active');
                        }
                    });
                });
            }

            showDashboard() {
                document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                document.querySelectorAll('.nav-item').forEach(n => {
                    if (n.textContent.trim() === 'Dashboard') n.classList.add('active');
                });
                
                const dashboardView = document.getElementById('dashboard-view');
                const container = document.getElementById('container');
                const bottomPanel = document.getElementById('bottom-panel');
                
                if (dashboardView && container) {
                    container.style.display = 'none';
                    dashboardView.classList.remove('hidden');
                    // í•˜ë‹¨ íŒ¨ë„ ìˆ¨ê¸°ê¸°
                    if (bottomPanel) {
                        bottomPanel.style.display = 'none';
                    }
                    this.renderDashboard();
                }
            }

            showInvestigate() {
                document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                document.querySelectorAll('.nav-item').forEach(n => {
                    if (n.textContent.trim() === 'Investigate') n.classList.add('active');
                });
                
                const dashboardView = document.getElementById('dashboard-view');
                const container = document.getElementById('container');
                const bottomPanel = document.getElementById('bottom-panel');
                
                // Dashboard ìˆ¨ê¸°ê¸°
                if (dashboardView) {
                    dashboardView.style.display = 'none';
                    dashboardView.style.visibility = 'hidden';
                    dashboardView.classList.add('hidden');
                }
                
                // Container í‘œì‹œ
                if (container) {
                    container.style.display = 'flex';
                    container.style.visibility = 'visible';
                    
                    // í•˜ë‹¨ íŒ¨ë„ ë‹¤ì‹œ í‘œì‹œ
                    if (bottomPanel) {
                        bottomPanel.style.display = 'flex';
                        bottomPanel.style.visibility = 'visible';
                    }
                    
                    // Canvas ì»¨í…Œì´ë„ˆê°€ ë³´ì´ë„ë¡ ë³´ì¥
                    const canvasContainer = document.getElementById('canvas-container');
                    if (canvasContainer) {
                        canvasContainer.style.display = 'block';
                        canvasContainer.style.visibility = 'visible';
                    }
                    
                    // Renderer í¬ê¸° ì¬ì¡°ì •
                    if (this.renderer) {
                        setTimeout(() => {
                            const width = canvasContainer ? canvasContainer.clientWidth : 800;
                            const height = canvasContainer ? canvasContainer.clientHeight : 600;
                            if (width > 0 && height > 0) {
                                this.camera.aspect = width / height;
                                this.camera.updateProjectionMatrix();
                                this.renderer.setSize(width, height);
                            }
                        }, 100);
                    }
                }
            }

            async renderDashboard() {
                const content = document.getElementById('dashboard-content');
                if (!content) return;

                // ë¸Œëœë“œ í—¤ë” ì¶”ê°€
                const brandHeader = `
                    <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 40px; padding-bottom: 20px; border-bottom: 2px solid #2a2f3e;">
                        <img src="crumb_logo.png" alt="CRUMB Logo" onerror="this.style.display='none'" style="height: 64px; width: auto; object-fit: contain;">
                        <div>
                            <h1 style="margin: 0; font-size: 28px; color: #fff; font-weight: 600; letter-spacing: 0.5px;">CRUMB â€” Combat Replay Unified Monitoring & Behavior-analysis</h1>
                            <p style="margin: 8px 0 0 0; font-size: 14px; color: #8a8fa5; font-style: italic;">"Follow every trace." ğŸ</p>
                        </div>
                    </div>
                `;

                // README ë‚´ìš©ì„ HTMLë¡œ ë³€í™˜ (ë” ê°„ê²°í•œ ìš”ì•½)
                const readmeContent = `FPS ì „íˆ¬ êµì „ ìƒí™©ì„ 3Dë¡œ ì‹œë®¬ë ˆì´ì…˜í•˜ê³  ë¶„ì„í•˜ëŠ” ì›¹ í”Œë«í¼ì…ë‹ˆë‹¤.

---

## ğŸš€ ë¹ ë¥¸ ì‹œì‘

1. **Investigate** íƒ­ í´ë¦­
2. ì¢Œì¸¡ ì‚¬ì´ë“œë°” **"íŒŒì¼ ì„ íƒ"** ë²„íŠ¼ í´ë¦­
3. GitHub CSV íŒŒì¼ ì„ íƒ
4. 3D ì‹œë®¬ë ˆì´ì…˜ ìë™ ì‹œì‘

---

## ğŸ¯ ì£¼ìš” ê¸°ëŠ¥

- **3D ì‹œê°í™”**: í”Œë ˆì´ì–´ ìœ„ì¹˜, í‚¬ ì´ë²¤íŠ¸, ì´ë™ ê²½ë¡œ
- **ì¸í„°ë™í‹°ë¸Œ ì»¨íŠ¸ë¡¤**: ì¹´ë©”ë¼ íšŒì „/ì¤Œ, ì¬ìƒ/ì¼ì‹œì •ì§€, ì†ë„ ì¡°ì ˆ
- **í”Œë ˆì´ì–´ ì¶”ì **: Follow ëª¨ë“œ, K/D Ratio, ì‹œì  ì´ë™
- **Aim Trace**: ì¡°ì¤€ ê¶¤ì  ì‹œê°í™”, ì—ì„ë´‡ íƒì§€

---

## ğŸ® ì»¨íŠ¸ë¡¤

| ì…ë ¥ | ë™ì‘ |
|------|------|
| ë§ˆìš°ìŠ¤ ë“œë˜ê·¸ | ì¹´ë©”ë¼ íšŒì „ |
| ë§ˆìš°ìŠ¤ íœ  | ì¤Œ ì¸/ì•„ì›ƒ |
| ì¬ìƒ ë²„íŠ¼ | ì‹œì‘/ì¼ì‹œì •ì§€ |
| íƒ€ì„ë¼ì¸ í´ë¦­ | ì‹œì  ì´ë™ |
| ì†ë„ ë²„íŠ¼ | 0.5x ~ 3x |

---

## ğŸ”§ ê¸°ìˆ  ìŠ¤íƒ

Three.js Â· PapaParse Â· ìˆœìˆ˜ JavaScript`;

                // ê°„ë‹¨í•œ ë§ˆí¬ë‹¤ìš´ íŒŒì„œ (ê¸°ë³¸ì ì¸ ë³€í™˜)
                content.innerHTML = brandHeader + this.markdownToHTML(readmeContent);
            }

            markdownToHTML(markdown) {
                let html = markdown;
                
                // í—¤ë”ì— ID ì¶”ê°€ë¥¼ ìœ„í•œ í—¬í¼ í•¨ìˆ˜
                const createId = (text) => {
                    return text.toLowerCase()
                        .replace(/[^\w\u3131-\u318E\uAC00-\uD7A3]+/g, '-')
                        .replace(/^-+|-+$/g, '');
                };
                
                // ë§í¬ ë³€í™˜ (í—¤ë” ë³€í™˜ ì „ì— ì²˜ë¦¬)
                html = html.replace(/\[([^\]]+)\]\(#([^\)]+)\)/g, (match, text, anchor) => {
                    return `<a href="#${anchor}" style="color: #4a90e2; text-decoration: none; border-bottom: 1px solid #4a90e2;">${text}</a>`;
                });
                
                // í—¤ë” ë³€í™˜ (ID í¬í•¨) - ìˆœì„œ ì¤‘ìš”: h4 -> h3 -> h2 -> h1
                html = html.replace(/^#### (.*$)/gim, (match, text) => {
                    const id = createId(text);
                    return `<h4 id="${id}">${text}</h4>`;
                });
                html = html.replace(/^### (.*$)/gim, (match, text) => {
                    const id = createId(text);
                    return `<h3 id="${id}">${text}</h3>`;
                });
                html = html.replace(/^## (.*$)/gim, (match, text) => {
                    const id = createId(text);
                    return `<h2 id="${id}">${text}</h2>`;
                });
                html = html.replace(/^# (.*$)/gim, (match, text) => {
                    const id = createId(text);
                    return `<h1 id="${id}">${text}</h1>`;
                });
                
                // ë³¼ë“œì²´ ë³€í™˜ (**í…ìŠ¤íŠ¸**)
                html = html.replace(/\*\*([^\*]+)\*\*/g, '<strong>$1</strong>');
                
                // ì½”ë“œ ë¸”ë¡
                html = html.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>');
                html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
                
                // ë¦¬ìŠ¤íŠ¸
                html = html.replace(/^- (.*$)/gim, '<li>$1</li>');
                html = html.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
                
                // í…Œì´ë¸” (ê°„ë‹¨í•œ ì²˜ë¦¬)
                html = html.replace(/\|(.+)\|/g, (match) => {
                    const cells = match.split('|').filter(c => c.trim());
                    if (cells.length > 0) {
                        return '<tr>' + cells.map(c => '<td>' + c.trim() + '</td>').join('') + '</tr>';
                    }
                    return match;
                });
                
                // ë‹¨ë½
                html = html.replace(/\n\n/g, '</p><p>');
                html = '<p>' + html + '</p>';
                
                // ì¤„ë°”ê¿ˆ
                html = html.replace(/\n/g, '<br>');
                
                // ì•µì»¤ ë§í¬ í´ë¦­ ì‹œ Dashboardë¡œ ì´ë™í•˜ê³  ë¶€ë“œëŸ¬ìš´ ìŠ¤í¬ë¡¤
                setTimeout(() => {
                    document.querySelectorAll('#dashboard-content a[href^="#"]').forEach(link => {
                        link.addEventListener('click', (e) => {
                            e.preventDefault();
                            
                            // Dashboardê°€ ì—´ë ¤ìˆì§€ ì•Šìœ¼ë©´ Dashboardë¡œ ì´ë™
                            const dashboardView = document.getElementById('dashboard-view');
                            const container = document.getElementById('container');
                            if (dashboardView && !dashboardView.classList.contains('active')) {
                                // Dashboard íƒ­ í™œì„±í™”
                                document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                                document.querySelectorAll('.nav-item').forEach(n => {
                                    if (n.textContent.trim() === 'Dashboard') n.classList.add('active');
                                });
                                
                                // Dashboard ë·° í‘œì‹œ
                                if (container) {
                                    container.style.display = 'none';
                                }
                                dashboardView.classList.add('active');
                                
                                // í•˜ë‹¨ íŒ¨ë„ ìˆ¨ê¸°ê¸°
                                const bottomPanel = document.getElementById('bottom-panel');
                                if (bottomPanel) {
                                    bottomPanel.style.display = 'none';
                                }
                            }
                            
                            // í•´ë‹¹ ì„¹ì…˜ìœ¼ë¡œ ìŠ¤í¬ë¡¤
                            const targetId = link.getAttribute('href').substring(1);
                            setTimeout(() => {
                                const targetElement = document.getElementById(targetId);
                                if (targetElement) {
                                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                }
                            }, dashboardView && !dashboardView.classList.contains('active') ? 200 : 0);
                        });
                    });
                }, 100);
                
                return html;
            }

            async showCSVPopup() {
                const popup = document.getElementById('csv-popup');
                const fileList = document.getElementById('csv-file-list');
                const loading = document.getElementById('csv-loading');
                
                if (!popup || !fileList) return;
                
                popup.classList.add('active');
                fileList.innerHTML = '';
                loading.style.display = 'block';
                
                try {
                    // GitHub APIë¡œ CSV íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                    const repo = 'bangilhan/fps_combat_simulation';
                    const response = await fetch(`https://api.github.com/repos/${repo}/contents`);
                    const files = await response.json();
                    
                    // CSV íŒŒì¼ë§Œ í•„í„°ë§
                    const csvFiles = files.filter(file => 
                        file.type === 'file' && file.name.endsWith('.csv')
                    );
                    
                    loading.style.display = 'none';
                    
                    if (csvFiles.length === 0) {
                        fileList.innerHTML = '<li style="color: #8a8fa5;">CSV íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</li>';
                        return;
                    }
                    
                    csvFiles.forEach(file => {
                        const li = document.createElement('li');
                        li.textContent = file.name;
                        li.addEventListener('click', () => {
                            this.loadCSVFromGitHub(file.download_url, file.name);
                            popup.classList.remove('active');
                        });
                        fileList.appendChild(li);
                    });
                } catch (error) {
                    console.error('GitHub íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨:', error);
                    loading.style.display = 'none';
                    fileList.innerHTML = '<li style="color: #ff6b6b;">íŒŒì¼ ëª©ë¡ì„ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</li>';
                }
            }

            async loadCSVFromGitHub(url, filename) {
                const loading = document.getElementById('loading');
                const selectedFile = document.getElementById('selected-file');
                
                if (loading) {
                    loading.style.display = 'block';
                    loading.innerHTML = 'GitHubì—ì„œ CSV íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì¤‘...';
                }
                
                if (selectedFile) {
                    selectedFile.textContent = filename;
                }
                
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const text = await response.text();
                    
                    // í…ìŠ¤íŠ¸ë¥¼ Blobìœ¼ë¡œ ë³€í™˜í•˜ì—¬ File ê°ì²´ì²˜ëŸ¼ ì‚¬ìš©
                    const blob = new Blob([text], { type: 'text/csv' });
                    const file = new File([blob], filename, { type: 'text/csv' });
                    
                    await this.loadCSV(file);
                } catch (error) {
                    console.error('CSV íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨:', error);
                    if (loading) {
                        loading.innerHTML = 'ì˜¤ë¥˜: ' + error.message;
                    }
                    alert('CSV íŒŒì¼ì„ ë‹¤ìš´ë¡œë“œí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                }
            }

            setupTabs() {
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        // íƒ­ ì „í™˜
                        const tab = btn.getAttribute('data-tab');
                        if (tab === 'aim') {
                            this.renderAimTrace();
                        } else if (tab === 'actions') {
                            this.updateEventLog();
                        } else {
                            // chat placeholder
                            const eventLog = document.getElementById('event-log');
                            eventLog.innerHTML = '<div style="padding:10px;color:#8a8fa5;">Chat view TBD</div>';
                        }
                    });
                });

                // í¬ì»¤ìŠ¤ ëª¨ë“œ ì¢…ë£Œ ë²„íŠ¼
                document.getElementById('exit-focus-btn').addEventListener('click', () => {
                    this.exitFocusMode();
                });
                
                // ë³´ê³ ì„œ ìƒì„± íƒ­
                document.getElementById('report-tab').addEventListener('click', () => {
                    const playerName = this.selectedPlayer || (this.selectedEvent && this.selectedEvent.attacker && this.selectedEvent.attacker.name) || 
                                    ((this.data && this.data.metadata && this.data.metadata.players && this.data.metadata.players[0]) || null);
                    if (playerName) {
                        this.generateReport(playerName);
                    } else {
                        alert('Please select a player first');
                    }
                });
            }

            async loadCSV(file) {
                const loading = document.getElementById('loading');
                if (loading) {
                    loading.style.display = 'block';
                    loading.innerHTML = 'Parsing CSV file...';
                }
                
                return new Promise((resolve) => {
                    try {
                        // PapaParse ë¡œë“œ í™•ì¸
                        if (typeof Papa === 'undefined' || !Papa || !Papa.parse) {
                            console.error('PapaParseê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                            if (loading) loading.innerHTML = 'Error: CSV parser not loaded. ë„¤íŠ¸ì›Œí¬ë¥¼ í™•ì¸í•˜ê³  ìƒˆë¡œê³ ì¹¨(Ctrl+F5) í•´ì£¼ì„¸ìš”.';
                            resolve();
                            return;
                        }
                        Papa.parse(file, {
                            header: true,
                            skipEmptyLines: true,
                            complete: async (results) => {
                                console.log('CSV íŒŒì‹± ì™„ë£Œ:', results.data.length, 'ì¤„');
                                console.log('ì²« ë²ˆì§¸ í–‰ ìƒ˜í”Œ:', results.data[0]);
                                
                                if (!results || !results.data || results.data.length === 0) {
                                    console.error('CSV íŒŒì‹± ê²°ê³¼ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤');
                                    alert('CSV íŒŒì¼ì— ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                                    if (loading) loading.style.display = 'none';
                                    resolve();
                                    return;
                                }
                                
                                if (loading) loading.innerHTML = 'Processing data... 0%';
                                try {
                                    await this.processData(results.data);
                                } catch (procError) {
                                    console.error('processData ì˜¤ë¥˜:', procError);
                                    alert('ë°ì´í„° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: ' + procError.message);
                                }
                                if (loading) loading.style.display = 'none';
                                resolve();
                            },
                            error: (error) => {
                                console.error('CSV íŒŒì‹± ì˜¤ë¥˜:', error);
                                if (loading) loading.style.display = 'none';
                                alert('CSV íŒŒì¼ì„ ì½ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                                resolve();
                            }
                        });
                    } catch (error) {
                        console.error('loadCSV ì˜¤ë¥˜:', error);
                        if (loading) loading.style.display = 'none';
                        alert('íŒŒì¼ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                        resolve();
                    }
                });
            }

            async processData(rows) {
                try {
                    console.log('processData ì‹œì‘, ì´ í–‰ ìˆ˜:', rows.length);
                    if (!rows || rows.length === 0) {
                        console.error('ë°ì´í„°ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤');
                        alert('CSV íŒŒì¼ì— ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                        return;
                    }
                    
                    const positions = [];
                    const events = [];
                    const aimIndex = new Map(); // name -> [{yaw,pitch,time,type}]
                    
                    // ë§µ ê²½ê³„ ì¶”ì ìš© (ë³„ë„ ë°°ì—´ ì—†ì´ ì§ì ‘ ê³„ì‚°)
                    let minX = Infinity, maxX = -Infinity;
                    let minY = Infinity, maxY = -Infinity;
                    let minZ = Infinity, maxZ = -Infinity;
                    
                    let tickData = {};
                    let currentTick = null;
                    
                    const totalRows = rows.length;
                    const chunkSize = 1000; // ì²­í¬ ë‹¨ìœ„ë¡œ ì²˜ë¦¬í•˜ì—¬ UI ì°¨ë‹¨ ë°©ì§€
                    
                    // ì§„í–‰ ìƒí™© í‘œì‹œ
                    const loading = document.getElementById('loading');
                    const updateProgress = (progress) => {
                        if (loading) {
                            loading.style.display = 'block';
                            loading.innerHTML = 'Processing data... ' + Math.round(progress) + '%';
                        }
                    };
                    
                    // ì²­í¬ ë‹¨ìœ„ ì²˜ë¦¬
                    for (let chunkStart = 0; chunkStart < totalRows; chunkStart += chunkSize) {
                        const chunkEnd = Math.min(chunkStart + chunkSize, totalRows);
                        const chunk = rows.slice(chunkStart, chunkEnd);
                        
                        chunk.forEach((row, localIdx) => {
                        const idx = chunkStart + localIdx;
                        
                        const tickStr = row.tick && row.tick.trim ? row.tick.trim() : null;
                        if (!tickStr) return;
                        
                        const tick = parseInt(tickStr);
                        const gameTime = parseFloat(row.game_time || 0);
                        
                        if (currentTick !== tick && currentTick !== null && tickData.players && tickData.players.length) {
                            positions.push({
                                tick: currentTick,
                                game_time: tickData.game_time || 0,
                                players: tickData.players || []
                            });
                            tickData = { players: [] };
                        }
                        
                        currentTick = tick;
                        tickData.game_time = gameTime;
                        
                        const x = row.X && row.X.trim ? row.X.trim() : null;
                        const y = row.Y && row.Y.trim ? row.Y.trim() : null;
                        const z = row.Z && row.Z.trim ? row.Z.trim() : null;
                        if (x && y && z && row.name && row.name.trim && row.name.trim()) {
                            const posX = parseFloat(x);
                            const posY = parseFloat(y);
                            const posZ = parseFloat(z);
                            
                            // ë§µ ê²½ê³„ ì§ì ‘ ì—…ë°ì´íŠ¸ (ë°°ì—´ ì €ì¥ ë¶ˆí•„ìš”)
                            if (!Number.isNaN(posX)) {
                                if (posX < minX) minX = posX;
                                if (posX > maxX) maxX = posX;
                            }
                            if (!Number.isNaN(posY)) {
                                if (posY < minY) minY = posY;
                                if (posY > maxY) maxY = posY;
                            }
                            if (!Number.isNaN(posZ)) {
                                if (posZ < minZ) minZ = posZ;
                                if (posZ > maxZ) maxZ = posZ;
                            }
                            
                            tickData.players = tickData.players || [];
                            // yaw, pitch ì •ë³´ë„ ìˆ˜ì§‘ (í”Œë ˆì´ì–´ ë°ì´í„°ì—) - ìƒˆ ë°ì´í„°ëŠ” ê° í‹±ë³„ë¡œ ëª¨ë“  í”Œë ˆì´ì–´ì˜ yaw/pitchê°€ ìˆìŒ
                            const yawStr = row.yaw && row.yaw.trim ? row.yaw.trim() : null;
                            const pitchStr = row.pitch && row.pitch.trim ? row.pitch.trim() : null;
                            // attacker_yaw/pitchëŠ” fallbackìœ¼ë¡œë§Œ ì‚¬ìš© (í‚¬ ì´ë²¤íŠ¸ ì‹œ)
                            const yaw = yawStr ? parseFloat(yawStr) : (row.attacker_yaw && row.attacker_yaw.trim ? parseFloat(row.attacker_yaw.trim()) : null);
                            const pitch = pitchStr ? parseFloat(pitchStr) : (row.attacker_pitch && row.attacker_pitch.trim ? parseFloat(row.attacker_pitch.trim()) : null);
                            
                            tickData.players.push({
                                name: row.name.trim(),
                            team: (row.team_name && row.team_name.trim ? row.team_name.trim() : '') || '',
                                position: [posX, posZ, posY],
                                health: parseFloat(row.health || 100),
                                round: parseInt(row.round || 1),
                            weapon: (row.weapon && row.weapon.trim ? row.weapon.trim() : null),
                                yaw: !Number.isNaN(yaw) ? yaw : null,
                                pitch: !Number.isNaN(pitch) ? pitch : null
                            });
                        }
                        
                        if (row.event && row.event.trim && row.event.trim()) {
                            const eventType = row.event.trim().toLowerCase();
                            
                            // í‚¬ ì´ë²¤íŠ¸ ì¤‘ë³µ ì²´í¬: ê°™ì€ tickì˜ í‚¬ ì´ë²¤íŠ¸ê°€ ì´ë¯¸ ìˆìœ¼ë©´ ì¶”ê°€í•˜ì§€ ì•ŠìŒ
                            let shouldAddEvent = true;
                            if (eventType.includes('kill') || eventType.includes('died')) {
                                const attackerName = row.attacker_name && row.attacker_name.trim ? row.attacker_name.trim() : null;
                                const victimName = row.victim_name && row.victim_name.trim ? row.victim_name.trim() : null;
                                const existingKill = events.find(e => 
                                    e.tick === tick && 
                                    (e.event_type_lower && (e.event_type_lower.includes('kill') || e.event_type_lower.includes('died'))) &&
                                    e.attacker && e.attacker.name === attackerName &&
                                    e.victim && e.victim.name === victimName
                                );
                                if (existingKill) {
                                    // ì´ë¯¸ ê°™ì€ í‚¬ ì´ë²¤íŠ¸ê°€ ìˆìœ¼ë©´ ì¶”ê°€í•˜ì§€ ì•ŠìŒ
                                    shouldAddEvent = false;
                                }
                            }
                            
                            if (shouldAddEvent) {
                                events.push({
                                tick: tick,
                                game_time: gameTime,
                                event_type: row.event.trim(),
                                event_type_lower: eventType,
                            attacker: {
                                    name: (row.attacker_name && row.attacker_name.trim ? row.attacker_name.trim() : null),
                                    team: (row.attacker_team_name && row.attacker_team_name.trim ? row.attacker_team_name.trim() : null),
                                    position: [
                                        (row.attacker_X && row.attacker_X.trim ? parseFloat(row.attacker_X) : null),
                                        (row.attacker_Z && row.attacker_Z.trim ? parseFloat(row.attacker_Z) : null),
                                        (row.attacker_Y && row.attacker_Y.trim ? parseFloat(row.attacker_Y) : null)
                                    ],
                                    weapon: (row.weapon && row.weapon.trim ? row.weapon.trim() : null)
                                },
                                victim: {
                                    name: (row.victim_name && row.victim_name.trim ? row.victim_name.trim() : null),
                                    team: (row.victim_team_name && row.victim_team_name.trim ? row.victim_team_name.trim() : null),
                                    position: [
                                        (row.victim_X && row.victim_X.trim ? parseFloat(row.victim_X) : null),
                                        (row.victim_Z && row.victim_Z.trim ? parseFloat(row.victim_Z) : null),
                                        (row.victim_Y && row.victim_Y.trim ? parseFloat(row.victim_Y) : null)
                                    ]
                                },
                            weapon: (row.weapon && row.weapon.trim ? row.weapon.trim() : null),
                            headshot: (row.headshot && row.headshot.trim ? row.headshot.trim().toLowerCase() === 'true' : false)
                                });
                            }

                            // í‚¬ ì´ë²¤íŠ¸ì˜ ê³µê²©ì Aim ë°ì´í„° ìˆ˜ì§‘ (ë‚˜ì¤‘ì— ì¼ê´„ ì²˜ë¦¬)
                            if (eventType.includes('kill') || eventType.includes('died')) {
                            const yawStr = row.attacker_yaw && row.attacker_yaw.trim ? row.attacker_yaw.trim() : null;
                            const pitchStr = row.attacker_pitch && row.attacker_pitch.trim ? row.attacker_pitch.trim() : null;
                            const attackerName = row.attacker_name && row.attacker_name.trim ? row.attacker_name.trim() : null;
                                if (attackerName && yawStr && pitchStr) {
                                    const yaw = parseFloat(yawStr);
                                    const pitch = parseFloat(pitchStr);
                                    if (!Number.isNaN(yaw) && !Number.isNaN(pitch)) {
                                        if (!aimIndex.has(attackerName)) aimIndex.set(attackerName, []);
                                        // ì¤‘ë³µ ì²´í¬: ê°™ì€ tickì˜ í‚¬ì´ ì´ë¯¸ ìˆìœ¼ë©´ ì¶”ê°€í•˜ì§€ ì•ŠìŒ
                                        const existingKill = aimIndex.get(attackerName).find(a => 
                                            a.type === 'kill' && a.tick === tick && Math.abs(a.time - gameTime) < 0.01
                                        );
                                        if (!existingKill) {
                                            // ì„ì‹œë¡œ ì €ì¥ (ë‚˜ì¤‘ì— ì¼ê´„ ì²˜ë¦¬)
                                            aimIndex.get(attackerName).push({ 
                                                yaw, pitch, time: gameTime, tick: tick, type: 'kill',
                                                _temp: true // ì„ì‹œ í‘œì‹œ
                                            });
                                        }
                                    }
                                }
                            }
                            }
                        });
                        
                        // ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸ ë° UI ì°¨ë‹¨ ë°©ì§€
                        updateProgress((chunkEnd / totalRows) * 100);
                        await new Promise(resolve => setTimeout(resolve, 0)); // ë‹¤ìŒ ì´ë²¤íŠ¸ ë£¨í”„ë¡œ
                    }
                    
                    if (currentTick !== null && tickData.players && tickData.players.length) {
                        positions.push({
                            tick: currentTick,
                            game_time: tickData.game_time || 0,
                            players: tickData.players || []
                        });
                    }
                    
                    // ë§µ ê²½ê³„ ê³„ì‚° (ì´ë¯¸ ê³„ì‚°ë¨)
                    if (minX !== Infinity && maxX !== -Infinity) {
                        this.mapBounds = {
                            minX: minX,
                            maxX: maxX,
                            minY: minY,
                            maxY: maxY,
                            minZ: minZ,
                            maxZ: maxZ,
                            centerX: (minX + maxX) / 2,
                            centerY: (minY + maxY) / 2,
                            centerZ: (minZ + maxZ) / 2,
                            width: maxX - minX,
                            height: maxY - minY,
                            depth: maxZ - minZ
                        };
                    }
                    
                    const gameTimes = positions.map(p => p.game_time).filter(t => t);
                    const ticks = positions.map(p => p.tick).filter(t => t);
                    const players = new Set();
                    const playerStats = new Map();
                    const playerIndex = new Map();
                    
                    // í”Œë ˆì´ì–´ ì¸ë±ìŠ¤ ë° Aim ë°ì´í„° ìˆ˜ì§‘ (ìµœì í™”)
                    positions.forEach(p => {
                    p.players.forEach(pl => {
                        if (pl.name) {
                            players.add(pl.name);
                            if (!playerStats.has(pl.name)) {
                                playerStats.set(pl.name, { kills: 0, deaths: 0, team: pl.team });
                            }
                            if (!playerIndex.has(pl.name)) playerIndex.set(pl.name, []);
                            playerIndex.get(pl.name).push({ tick: p.tick, time: p.game_time, position: pl.position });
                            
                            // Aim ë°ì´í„° ìˆ˜ì§‘ (ëª¨ë“  í‹±ì—ì„œ yaw/pitch)
                            if (pl.yaw !== null && pl.yaw !== undefined && 
                                pl.pitch !== null && pl.pitch !== undefined) {
                                if (!aimIndex.has(pl.name)) aimIndex.set(pl.name, []);
                                aimIndex.get(pl.name).push({ 
                                    yaw: pl.yaw, 
                                    pitch: pl.pitch, 
                                    time: p.game_time, 
                                    tick: p.tick,
                                    type: 'move' 
                                });
                            }
                            }
                        });
                    });
                    
                    // Kill ì´ë²¤íŠ¸ì˜ aim ë°ì´í„°ë¥¼ move ë°ì´í„°ì™€ ë³‘í•© (ì¼ê´„ ì²˜ë¦¬)
                    aimIndex.forEach((arr, name) => {
                        const kills = arr.filter(a => a.type === 'kill' && a._temp);
                        const moves = arr.filter(a => a.type === 'move');
                        
                        // kill íƒ€ì…ì„ ê°™ì€ ì‹œê°„/í‹±ì˜ moveì— ë³‘í•©
                        kills.forEach(kill => {
                            const existing = moves.find(m => 
                                Math.abs(m.time - kill.time) < 0.01 && m.tick === kill.tick
                            );
                            if (existing) {
                                existing.type = 'kill';
                            }
                        });
                        
                        // ì„ì‹œ kill í•­ëª© ì œê±° (ë³‘í•©ëœ ê²ƒë§Œ ë‚¨ê¹€)
                        arr.splice(0, arr.length, ...moves, ...kills.filter(k => {
                            const exists = moves.some(m => 
                                Math.abs(m.time - k.time) < 0.01 && m.tick === k.tick
                            );
                            return !exists;
                        }));
                    });
                    
                    events.forEach(e => {
                        if (e.event_type_lower && (e.event_type_lower.includes('kill') || e.event_type_lower.includes('died'))) {
                            if (e.attacker && e.attacker.name) {
                                const stats = playerStats.get(e.attacker.name);
                                if (stats) stats.kills++;
                            }
                            if (e.victim && e.victim.name) {
                                const stats = playerStats.get(e.victim.name);
                                if (stats) stats.deaths++;
                            }
                        }
                    });
                    
                    this.data = {
                        metadata: {
                            total_ticks: positions.length,
                            total_events: events.length,
                            time_range: {
                                min: gameTimes.length ? Math.min(...gameTimes) : 0,
                                max: gameTimes.length ? Math.max(...gameTimes) : 0
                            },
                            tick_range: {
                                min: ticks.length ? Math.min(...ticks) : 0,
                                max: ticks.length ? Math.max(...ticks) : 0
                            },
                            players: Array.from(players).sort(),
                            playerStats: Object.fromEntries(playerStats),
                            teams: ['CT', 'TERRORIST']
                        },
                        positions: positions,
                        events: events
                    };
                    this.playerIndex = playerIndex;
                    // aimIndex ì •ë ¬ (ì‹œê°„ìˆœ)
                    aimIndex.forEach((arr, name) => {
                        arr.sort((a, b) => a.time - b.time);
                    });
                    this.aimIndex = aimIndex;
                    
                    console.log('ë°ì´í„° ì²˜ë¦¬ ì™„ë£Œ:', this.data.metadata);
                    console.log('ë§µ ê²½ê³„:', this.mapBounds);
                    console.log('Positions ìˆ˜:', positions.length);
                    console.log('Events ìˆ˜:', events.length);
                    
                    if (positions.length === 0) {
                        console.error('Positionsê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤. ë°ì´í„° í¬ë§·ì„ í™•ì¸í•˜ì„¸ìš”.');
                        alert('ë°ì´í„°ë¥¼ ì²˜ë¦¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. CSV íŒŒì¼ í¬ë§·ì„ í™•ì¸í•˜ì„¸ìš”.');
                        return;
                    }
                    
                    this.updateUI();
                    this.setupMapBounds();
                    this.populateKillPicker();
                    this.populatePlayerPicker();
                    
                    // íŒŒì¼ ë¡œë“œ í›„ Investigate íƒ­ìœ¼ë¡œ ìë™ ì „í™˜
                    this.showInvestigate();
                    
                    // ì‹œë®¬ë ˆì´ì…˜ ë Œë”ë§ ì´ˆê¸°í™”
                    setTimeout(() => {
                        this.renderTick(0);
                        // renderer í¬ê¸° ì¬ì¡°ì • (containerê°€ ìˆ¨ê²¨ì ¸ ìˆì„ ìˆ˜ ìˆìŒ)
                        const container = document.getElementById('canvas-container');
                        if (container && this.renderer) {
                            const width = container.clientWidth;
                            const height = container.clientHeight;
                            if (width > 0 && height > 0) {
                                this.camera.aspect = width / height;
                                this.camera.updateProjectionMatrix();
                                this.renderer.setSize(width, height);
                            }
                        }
                    }, 100);
                } catch (error) {
                    console.error('processData ì˜¤ë¥˜:', error);
                    alert('ë°ì´í„° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                    const loading = document.getElementById('loading');
                    if (loading) loading.style.display = 'none';
                }
            }

            renderAimTrace() {
                const container = document.getElementById('event-log');
                container.innerHTML = '';
                const canvas = document.createElement('canvas');
                canvas.width = container.clientWidth - 20;
                canvas.height = container.clientHeight - 20;
                canvas.style.background = '#0a0e15';
                canvas.style.border = '1px solid #2a2f3e';
                container.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                const W = canvas.width;
                const H = canvas.height;

                // Focus ëª¨ë“œê°€ ì•„ë‹ˆë©´ ë©”ì‹œì§€ í‘œì‹œ
                if (!this.focusMode || !this.focusTickRange) {
                    ctx.fillStyle = '#8a8fa5';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Aim TraceëŠ” Focus ëª¨ë“œì—ì„œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.', W/2, H/2);
                    ctx.fillText('í‚¬ ì´ë²¤íŠ¸ë¥¼ ì„ íƒí•˜ì—¬ Focus ëª¨ë“œë¥¼ í™œì„±í™”í•˜ì„¸ìš”.', W/2, H/2 + 30);
                    return;
                }

                // ì„ íƒëœ í”Œë ˆì´ì–´ ìš°ì„ ìˆœìœ„: í¬ì»¤ìŠ¤ ëª¨ë“œì¼ ë•ŒëŠ” ë°˜ë“œì‹œ ê³µê²©ì -> ì„ íƒëœ í”Œë ˆì´ì–´ -> ì²« ë²ˆì§¸
                let name = null;
                if (this.focusMode && this.selectedEvent && this.selectedEvent.attacker && this.selectedEvent.attacker.name) {
                    // í¬ì»¤ìŠ¤ ëª¨ë“œì¼ ë•ŒëŠ” ë¬´ì¡°ê±´ ê³µê²©ìë¥¼ í‘œì‹œ
                    name = this.selectedEvent.attacker.name;
                    console.log('Aim Trace - í¬ì»¤ìŠ¤ ëª¨ë“œ: ê³µê²©ì', name, 'ì˜ aim trace í‘œì‹œ');
                } else if (this.selectedEvent && this.selectedEvent.attacker && this.selectedEvent.attacker.name) {
                    name = this.selectedEvent.attacker.name;
                } else {
                    name = this.selectedPlayer || ((this.data && this.data.metadata && this.data.metadata.players && this.data.metadata.players[0]) || null);
                }
                
                // ì‹¤ì œ ë°ì´í„°ì—ì„œ Aim ì •ë³´ ìˆ˜ì§‘
                let samples = [];
                if (name && this.data) {
                    console.log('Aim Trace - í”Œë ˆì´ì–´:', name);
                    
                    // í¬ì»¤ìŠ¤ ëª¨ë“œì¼ ë•ŒëŠ” í‹± ì¸ë±ìŠ¤ ë²”ìœ„ë¡œ ì§ì ‘ ìˆ˜ì§‘ (ëª¨ë“  í‹±, ëˆ„ì )
                    if (this.focusMode && this.focusTickRange) {
                        console.log('Aim Trace - í¬ì»¤ìŠ¤ ëª¨ë“œ: í‹± ë²”ìœ„', this.focusTickRange.startIdx, '-', this.focusTickRange.endIdx, 'ì´', (this.focusTickRange.endIdx - this.focusTickRange.startIdx + 1), 'í‹±');
                        let foundCount = 0;
                        let missingCount = 0;
                        let lastYaw = null;
                        let lastPitch = null;
                        
                        // ì²« ë²ˆì§¸ ìœ íš¨í•œ ê°’ì„ ì°¾ê¸° ìœ„í•´ ì—­ë°©í–¥ìœ¼ë¡œë„ ê²€ìƒ‰
                        for (let idx = this.focusTickRange.startIdx - 1; idx >= 0 && idx >= this.focusTickRange.startIdx - 10; idx--) {
                            const pos = this.data.positions[idx];
                            if (pos) {
                                const player = pos.players.find(p => p.name === name);
                                if (player && player.yaw !== null && player.yaw !== undefined && !Number.isNaN(player.yaw) &&
                                    player.pitch !== null && player.pitch !== undefined && !Number.isNaN(player.pitch)) {
                                    lastYaw = player.yaw;
                                    lastPitch = player.pitch;
                                    break;
                                }
                            }
                        }
                        
                        // ëª¨ë“  í‹±ì„ ìˆœíšŒí•˜ë©´ì„œ ì‹¤ì œ ë°ì´í„°ê°€ ìˆëŠ” í‹±ë§Œ ìˆ˜ì§‘ (ì¤‘ë³µ ì œê±°)
                        for (let idx = this.focusTickRange.startIdx; idx <= this.focusTickRange.endIdx; idx++) {
                            const pos = this.data.positions[idx];
                            if (pos) {
                                const player = pos.players.find(p => p.name === name);
                                if (player) {
                                    const yaw = player.yaw;
                                    const pitch = player.pitch;
                                    
                                    // ì‹¤ì œ ë°ì´í„°ê°€ ìˆëŠ” ê²½ìš°ë§Œ ì¶”ê°€ (ë³´ê°„ ì—†ì´)
                                    if (yaw !== null && yaw !== undefined && !Number.isNaN(yaw) &&
                                        pitch !== null && pitch !== undefined && !Number.isNaN(pitch)) {
                                        // ì´ì „ ìƒ˜í”Œê³¼ ê°’ì´ ë‹¤ë¥¼ ë•Œë§Œ ì¶”ê°€ (ì¤‘ë³µ ì œê±°)
                                        if (lastYaw === null || lastPitch === null || 
                                            Math.abs(yaw - lastYaw) > 0.01 || Math.abs(pitch - lastPitch) > 0.01) {
                                            samples.push({
                                                yaw: yaw,
                                                pitch: pitch,
                                                time: pos.game_time,
                                                tick: pos.tick,
                                                tickIdx: idx, // í‹± ì¸ë±ìŠ¤ ëª…ì‹œì  ì €ì¥
                                                type: 'move'
                                            });
                                            lastYaw = yaw;
                                            lastPitch = pitch;
                                            foundCount++;
                                        } else {
                                            // ê°™ì€ ê°’ì´ë©´ ìŠ¤í‚µ (ì¤‘ë³µ ì œê±°)
                                            missingCount++;
                                        }
                                    } else {
                                        missingCount++;
                                    }
                                } else {
                                    missingCount++;
                                }
                            }
                        }
                        console.log('Aim Trace - í¬ì»¤ìŠ¤ ëª¨ë“œ ìˆ˜ì§‘:', foundCount, 'ê³ ìœ  ìƒ˜í”Œ, ì¤‘ë³µ/ì—†ìŒ:', missingCount, '/ ì „ì²´ í‹±:', (this.focusTickRange.endIdx - this.focusTickRange.startIdx + 1));
                        console.log('Aim Trace - í¬ì»¤ìŠ¤ ëª¨ë“œ ë²”ìœ„:', this.focusTickRange.startIdx, '~', this.focusTickRange.endIdx, 'í‹±');
                    } else {
                        // ì¼ë°˜ ëª¨ë“œ: ì „ì²´ positionsì—ì„œ ìˆ˜ì§‘ (ì¤‘ë³µ ì œê±° í¬í•¨)
                        let foundCount = 0;
                        let missingCount = 0;
                        let lastYaw = null;
                        let lastPitch = null;
                        this.data.positions.forEach(pos => {
                            const player = pos.players.find(p => p.name === name);
                            if (player) {
                                // yaw/pitch í™•ì¸ (null ì²´í¬ ë° ìœ íš¨ì„± ê²€ì‚¬)
                                const yaw = player.yaw;
                                const pitch = player.pitch;
                                if (yaw !== null && yaw !== undefined && !Number.isNaN(yaw) &&
                                    pitch !== null && pitch !== undefined && !Number.isNaN(pitch)) {
                                    // ì´ì „ ìƒ˜í”Œê³¼ ê°’ì´ ë‹¤ë¥¼ ë•Œë§Œ ì¶”ê°€ (ì¤‘ë³µ ì œê±°)
                                    if (lastYaw === null || lastPitch === null || 
                                        Math.abs(yaw - lastYaw) > 0.01 || Math.abs(pitch - lastPitch) > 0.01) {
                                        samples.push({
                                            yaw: yaw,
                                            pitch: pitch,
                                            time: pos.game_time,
                                            tick: pos.tick,
                                            type: 'move'
                                        });
                                        lastYaw = yaw;
                                        lastPitch = pitch;
                                        foundCount++;
                                    } else {
                                        missingCount++;
                                    }
                                } else {
                                    missingCount++;
                                }
                            } else {
                                missingCount++;
                            }
                        });
                        console.log('Aim Trace - ì¼ë°˜ ëª¨ë“œ ìˆ˜ì§‘:', foundCount, 'ê³ ìœ  ìƒ˜í”Œ, ì¤‘ë³µ/ì—†ìŒ:', missingCount, '/ ì „ì²´:', this.data.positions.length);
                    }
                    
                    // í‚¬ ì´ë²¤íŠ¸ì—ì„œ kill íƒ€ì… ë§ˆí‚¹ (ì¤‘ë³µ ì œê±° ê°•í™”)
                    if (this.aimIndex && this.aimIndex.has(name)) {
                        let killPoints = this.aimIndex.get(name).filter(a => a.type === 'kill');

                        // í¬ì»¤ìŠ¤ ëª¨ë“œì—ì„œëŠ” ì„ íƒëœ ì´ë²¤íŠ¸ì˜ í‚¬ë§Œ í‘œì‹œ (ì¤‘ë³µ ë¶‰ì€ ì  ë°©ì§€)
                        if (this.focusMode && this.selectedEvent && this.selectedEvent.tick !== undefined) {
                            const focusTick = this.selectedEvent.tick;
                            const focusVictim = this.selectedEvent.victim ? this.selectedEvent.victim.name : null;
                            killPoints = killPoints.filter(kp => {
                                if (kp.tick !== focusTick) return false;
                                // victim ì •ë³´ê°€ ìˆìœ¼ë©´ ì¼ì¹˜í•˜ëŠ” ê²½ìš°ë§Œ í‘œì‹œ
                                return focusVictim ? true : true;
                            });
                        }
                        console.log('Aim Trace - Kill í¬ì¸íŠ¸ ìˆ˜ (ì¤‘ë³µ ì œê±° ì „):', killPoints.length);
                        
                        // ì¤‘ë³µ ì œê±°: ê°™ì€ tickì˜ í‚¬ì€ í•˜ë‚˜ë§Œ ë‚¨ê¹€
                        const uniqueKillPoints = [];
                        const seenTicks = new Set();
                        killPoints.forEach(kp => {
                            if (!seenTicks.has(kp.tick)) {
                                seenTicks.add(kp.tick);
                                uniqueKillPoints.push(kp);
                            }
                        });
                        
                        console.log('Aim Trace - Kill í¬ì¸íŠ¸ ìˆ˜ (ì¤‘ë³µ ì œê±° í›„):', uniqueKillPoints.length);
                        
                        uniqueKillPoints.forEach(kp => {
                            const existing = samples.find(s => 
                                Math.abs(s.time - kp.time) < 0.01 && s.tick === kp.tick
                            );
                            if (existing) {
                                existing.type = 'kill';
                            } else {
                                samples.push(kp);
                            }
                        });
                    }
                    
                    samples.sort((a, b) => a.time - b.time);
                    console.log('Aim Trace - ìµœì¢… ìƒ˜í”Œ ìˆ˜:', samples.length);
                    
                    // ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ê²½ê³ 
                    if (samples.length === 0) {
                        console.warn('Aim Trace - ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. í”Œë ˆì´ì–´:', name);
                    }
                } else {
                    console.warn('Aim Trace - í”Œë ˆì´ì–´ ì´ë¦„ ë˜ëŠ” ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                }

                // í˜„ì¬ ì¬ìƒ êµ¬ê°„ - í¬ì»¤ìŠ¤ ëª¨ë“œì¼ ë•ŒëŠ” í¬ì»¤ìŠ¤ ë²”ìœ„ ì‚¬ìš©
                let tStart, tEnd;
                if (this.focusMode && this.focusTickRange) {
                    // í¬ì»¤ìŠ¤ ëª¨ë“œ: ì„ íƒëœ ì´ë²¤íŠ¸ ì „í›„ Â±30í‹± ë²”ìœ„
                    tStart = this.data.positions[this.focusTickRange.startIdx].game_time;
                    tEnd = this.data.positions[this.focusTickRange.endIdx].game_time;
                    console.log('Aim Trace - í¬ì»¤ìŠ¤ ëª¨ë“œ ë²”ìœ„:', tStart.toFixed(2), '-', tEnd.toFixed(2), 'ë²”ìœ„:', (tEnd - tStart).toFixed(2), 'ì´ˆ');
                } else {
                    const endIdx = this.currentTick;
                    // ë” ë„“ì€ ë²”ìœ„: ìµœê·¼ 300í‹± ë˜ëŠ” 5ì´ˆ
                    const startIdx = Math.max(0, endIdx - 300);
                    tStart = (this.data.positions[startIdx] && this.data.positions[startIdx].game_time != null) ? this.data.positions[startIdx].game_time : 0;
                    const currentTime = (this.data.positions[endIdx] && this.data.positions[endIdx].game_time != null) ? this.data.positions[endIdx].game_time : tStart;
                    tEnd = currentTime;
                    // ìµœì†Œ 5ì´ˆ ë²”ìœ„ ë³´ì¥
                    if (tEnd - tStart < 5) {
                        tStart = Math.max(0, tEnd - 5);
                    }
                }
                const currentTime = (this.data.positions[this.currentTick] && this.data.positions[this.currentTick].game_time != null) ? this.data.positions[this.currentTick].game_time : tStart;
                
                // í¬ì»¤ìŠ¤ ëª¨ë“œì¼ ë•ŒëŠ” ì¬ìƒ ì¤‘ì´ë©´ í˜„ì¬ í‹±ê¹Œì§€ ëˆ„ì , ì•„ë‹ˆë©´ ì „ì²´ í‘œì‹œ
                // ì¼ë°˜ ëª¨ë“œì¼ ë•Œë§Œ ì‹œê°„ ë²”ìœ„ë¡œ í•„í„°ë§
                let windowSamples;
                if (this.focusMode && this.focusTickRange) {
                    // í¬ì»¤ìŠ¤ ëª¨ë“œ: ì¬ìƒ ì¤‘ì´ë©´ í˜„ì¬ í‹±ê¹Œì§€ ëˆ„ì  í‘œì‹œ (í‹± ì¸ë±ìŠ¤ ê¸°ë°˜)
                    const currentTickIdx = this.currentTick;
                    const startTickIdx = this.focusTickRange.startIdx;
                    
                    // í¬ì»¤ìŠ¤ ëª¨ë“œì—ì„œëŠ” í•­ìƒ ì „ì²´ ìƒ˜í”Œ í‘œì‹œ (ëˆ„ì )
                    // ì¬ìƒ ì¤‘ì´ë©´ í˜„ì¬ í‹±ê¹Œì§€ë§Œ í‘œì‹œí•˜ë„ë¡ ì˜µì…˜ ì œê³µ
                    if (this.isPlaying && currentTickIdx > startTickIdx) {
                        // ì¬ìƒ ì¤‘: í˜„ì¬ í‹±ê¹Œì§€ì˜ ìƒ˜í”Œë§Œ í‘œì‹œ (ìˆœì°¨ì  ëˆ„ì )
                        windowSamples = samples.filter(s => {
                            // tickIdxê°€ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ positionsì—ì„œ ì°¾ê¸°
                            let sampleTickIdx = s.tickIdx;
                            if (sampleTickIdx === undefined) {
                                sampleTickIdx = this.data.positions.findIndex(p => p.tick === s.tick);
                            }
                            return sampleTickIdx !== -1 && sampleTickIdx <= currentTickIdx && sampleTickIdx >= startTickIdx;
                        });
                        console.log('Aim Trace - í¬ì»¤ìŠ¤ ëª¨ë“œ (ì¬ìƒ ì¤‘): í‹±', startTickIdx, '~', currentTickIdx, 'ê¹Œì§€', windowSamples.length, 'ìƒ˜í”Œ ëˆ„ì  (ì „ì²´ samples:', samples.length, ')');
                    } else {
                        // ì •ì§€ ìƒíƒœë©´ ì „ì²´ í‘œì‹œ (ëª¨ë“  ìƒ˜í”Œ)
                        windowSamples = samples;
                        console.log('Aim Trace - í¬ì»¤ìŠ¤ ëª¨ë“œ (ì •ì§€): ì „ì²´', windowSamples.length, 'ìƒ˜í”Œ í‘œì‹œ');
                    }
                } else {
                    // ì¼ë°˜ ëª¨ë“œ: ì‹œê°„ ë²”ìœ„ë¡œ í•„í„°ë§
                    windowSamples = samples.filter(s => s.time >= tStart && s.time <= tEnd);
                }
                
                console.log('Aim Trace - ìœˆë„ìš° ìƒ˜í”Œ ìˆ˜:', windowSamples.length, 'ì‹œê°„ ë²”ìœ„:', tStart.toFixed(2), '-', tEnd.toFixed(2), 'ë²”ìœ„:', (tEnd - tStart).toFixed(2), 'ì´ˆ');
                console.log('Aim Trace - ìƒ˜í”Œ yaw ë²”ìœ„:', windowSamples.length > 0 ? [Math.min(...windowSamples.map(s => s.yaw)).toFixed(2), Math.max(...windowSamples.map(s => s.yaw)).toFixed(2)] : 'ì—†ìŒ');
                console.log('Aim Trace - ìƒ˜í”Œ pitch ë²”ìœ„:', windowSamples.length > 0 ? [Math.min(...windowSamples.map(s => s.pitch)).toFixed(2), Math.max(...windowSamples.map(s => s.pitch)).toFixed(2)] : 'ì—†ìŒ');
                
                // ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ë©”ì‹œì§€ í‘œì‹œ
                if (samples.length === 0) {
                    ctx.fillStyle = '#8a8fa5';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('No aim data available for ' + (name || 'selected player'), W/2, H/2);
                    ctx.textAlign = 'left';
                    return;
                }
                
                if (windowSamples.length === 0) {
                    ctx.fillStyle = '#8a8fa5';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('No data in current time window', W/2, H/2);
                    ctx.textAlign = 'left';
                    return;
                }

                // ì‹¤ì œ ë°ì´í„° ë²”ìœ„ ê³„ì‚° (ë™ì  ìŠ¤ì¼€ì¼ë§)
                const yaws = windowSamples.map(s => s.yaw).filter(v => !Number.isNaN(v));
                const pitches = windowSamples.map(s => s.pitch).filter(v => !Number.isNaN(v));
                
                let xMin, xMax, yMin, yMax;
                if (yaws.length > 0 && pitches.length > 0) {
                    const yawMin = Math.min(...yaws);
                    const yawMax = Math.max(...yaws);
                    const pitchMin = Math.min(...pitches);
                    const pitchMax = Math.max(...pitches);
                    
                    const yawRange = yawMax - yawMin;
                    const pitchRange = pitchMax - pitchMin;
                    
                    // ë²”ìœ„ê°€ ë§¤ìš° ì¢ìœ¼ë©´ (10ë„ ì´í•˜) í™•ëŒ€, ì•„ë‹ˆë©´ ì „ì²´ ë²”ìœ„ ì‚¬ìš©
                    if (yawRange < 10 && pitchRange < 10) {
                        // í™•ëŒ€: ì¤‘ì•™ ê¸°ì¤€ìœ¼ë¡œ Â±20ë„ ë²”ìœ„
                        const yawCenter = (yawMin + yawMax) / 2;
                        const pitchCenter = (pitchMin + pitchMax) / 2;
                        xMin = yawCenter - 20;
                        xMax = yawCenter + 20;
                        yMin = pitchCenter - 20;
                        yMax = pitchCenter + 20;
                        console.log('Aim Trace - í™•ëŒ€ ëª¨ë“œ:', {yawCenter, pitchCenter, range: 'Â±20Â°'});
                    } else {
                        // ì—¬ë°± ì¶”ê°€ (10% padding)
                        const yawPadding = Math.max(yawRange * 0.1, 5);
                        const pitchPadding = Math.max(pitchRange * 0.1, 5);
                        xMin = yawMin - yawPadding;
                        xMax = yawMax + yawPadding;
                        yMin = pitchMin - pitchPadding;
                        yMax = pitchMax + pitchPadding;
                        console.log('Aim Trace - ë™ì  ë²”ìœ„:', {yaw: [xMin, xMax], pitch: [yMin, yMax]});
                    }
                } else {
                    // ê¸°ë³¸ ë²”ìœ„
                    xMin = -180; xMax = 180; yMin = -90; yMax = 90;
                }
                
                console.log('Aim Trace - ì¢Œí‘œ ë²”ìœ„:', {yaw: [xMin.toFixed(1), xMax.toFixed(1)], pitch: [yMin.toFixed(1), yMax.toFixed(1)]});
                
                const pad = 40;
                
                function xScale(v){ return pad + (v - xMin) / (xMax - xMin) * (W - 2*pad); }
                function yScale(v){ return H - (pad + (v - yMin) / (yMax - yMin) * (H - 2*pad)); }

                // ë°°ê²½ ê·¸ë¦¬ë“œ (ë™ì  ë²”ìœ„ì— ë§ì¶°)
                ctx.strokeStyle = '#2a2f3e'; ctx.lineWidth = 1;
                const gridStepX = Math.max(1, Math.ceil((xMax - xMin) / 20)); // ì•½ 20ê°œ ê·¸ë¦¬ë“œ
                const gridStepY = Math.max(1, Math.ceil((yMax - yMin) / 15)); // ì•½ 15ê°œ ê·¸ë¦¬ë“œ
                
                for (let x = Math.floor(xMin / gridStepX) * gridStepX; x <= xMax; x += gridStepX) {
                    const sx = xScale(x);
                    if (sx >= pad && sx <= W - pad) {
                        ctx.beginPath(); ctx.moveTo(sx, pad); ctx.lineTo(sx, H - pad); ctx.stroke();
                    }
                }
                for (let y = Math.floor(yMin / gridStepY) * gridStepY; y <= yMax; y += gridStepY) {
                    const sy = yScale(y);
                    if (sy >= pad && sy <= H - pad) {
                        ctx.beginPath(); ctx.moveTo(pad, sy); ctx.lineTo(W - pad, sy); ctx.stroke();
                    }
                }
                
                // ì¶• ë¼ë²¨ (ë²”ìœ„ í‘œì‹œ)
                ctx.fillStyle = '#8a8fa5'; ctx.font = '12px Arial';
                ctx.fillText(`Yaw (Â°) [${xMin.toFixed(1)} ~ ${xMax.toFixed(1)}]`, W/2 - 80, H-10);
                ctx.save(); ctx.translate(10, H/2); ctx.rotate(-Math.PI/2); 
                ctx.fillText(`Pitch (Â°) [${yMin.toFixed(1)} ~ ${yMax.toFixed(1)}]`, 0, 0); ctx.restore();

                // ëª¨ë“  í¬ì¸íŠ¸ í‘œì‹œ (ëˆ„ì  ì´ë™ ê²½ë¡œ) - ê³ ìœ í•œ ê°’ë§Œ í‘œì‹œ
                console.log('Aim Trace - ë Œë”ë§í•  í¬ì¸íŠ¸ ìˆ˜:', windowSamples.length);
                
                // ì¤‘ë³µ ì œê±°: ì—°ì†ëœ ê°™ì€ ê°’ ì œê±° (ë¨¼ì € ìƒì„±)
                const uniqueSamples = [];
                let lastRenderedYaw = null;
                let lastRenderedPitch = null;
                
                windowSamples.forEach((s, idx) => {
                    // ê°’ì´ ë³€ê²½ë˜ì—ˆê±°ë‚˜ ì²« ë²ˆì§¸ ìƒ˜í”Œì´ë©´ ì¶”ê°€
                    if (lastRenderedYaw === null || lastRenderedPitch === null ||
                        Math.abs(s.yaw - lastRenderedYaw) > 0.01 || Math.abs(s.pitch - lastRenderedPitch) > 0.01) {
                        uniqueSamples.push(s);
                        lastRenderedYaw = s.yaw;
                        lastRenderedPitch = s.pitch;
                    }
                });
                
                console.log('Aim Trace - ì¤‘ë³µ ì œê±° í›„ ê³ ìœ  í¬ì¸íŠ¸ ìˆ˜:', uniqueSamples.length, '/', windowSamples.length);

                // ê²½ë¡œ ì—°ê²°ì„  (ê¸°ë³¸ íšŒìƒ‰) - ê³ ìœ  í¬ì¸íŠ¸ë§Œ ì—°ê²°
                if (uniqueSamples.length > 1){
                    ctx.beginPath();
                    ctx.strokeStyle = '#5a637a'; ctx.lineWidth = 1.5;
                    let firstPoint = true;
                    for (let i = 0; i < uniqueSamples.length; i++) {
                        const s = uniqueSamples[i];
                        const x = xScale(s.yaw);
                        const y = yScale(s.pitch);
                        if (firstPoint) {
                            ctx.moveTo(x, y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                }
                
                // í¬ì¸íŠ¸ ë Œë”ë§
                if (uniqueSamples.length === 0) {
                    console.warn('Aim Trace - ë Œë”ë§í•  ê³ ìœ  í¬ì¸íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. windowSamples:', windowSamples.length);
                } else {
                    console.log('Aim Trace - ë Œë”ë§ ì‹œì‘: ê³ ìœ  í¬ì¸íŠ¸', uniqueSamples.length, 'ê°œ');
                }
                
                uniqueSamples.forEach((s, idx) => {
                    const x = xScale(s.yaw);
                    const y = yScale(s.pitch);
                    
                    // ìº”ë²„ìŠ¤ ë²”ìœ„ ì²´í¬
                    if (x < 0 || x > W || y < 0 || y > H) {
                        if (idx < 3) {
                            console.warn(`í¬ì¸íŠ¸ ${idx}ê°€ ìº”ë²„ìŠ¤ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¨: canvas(${x.toFixed(1)}, ${y.toFixed(1)})`);
                        }
                        return; // ë²”ìœ„ë¥¼ ë²—ì–´ë‚œ í¬ì¸íŠ¸ëŠ” ìŠ¤í‚µ
                    }
                    
                    // ë””ë²„ê¹…: ì²˜ìŒ 3ê°œì™€ ë§ˆì§€ë§‰ 3ê°œ í¬ì¸íŠ¸ë§Œ ë¡œê·¸
                    if (idx < 3 || idx >= uniqueSamples.length - 3) {
                        console.log(`ê³ ìœ  í¬ì¸íŠ¸ ${idx}/${uniqueSamples.length}: yaw=${s.yaw.toFixed(2)}, pitch=${s.pitch.toFixed(2)}, canvas(${x.toFixed(1)}, ${y.toFixed(1)})`);
                    }
                    
                    if (s.type === 'kill') {
                        // Kill ì‹œì : ì§„ë¹¨ê°• í° ì› + í…Œë‘ë¦¬
                        ctx.fillStyle = '#cc0000';
                        ctx.beginPath(); ctx.arc(x, y, 5, 0, Math.PI*2); ctx.fill();
                        ctx.strokeStyle = '#ff3333'; ctx.lineWidth = 2; ctx.stroke();
                    } else {
                        // ì¼ë°˜ ì´ë™ í¬ì¸íŠ¸: ì‘ì€ íšŒìƒ‰ ì  (ëª¨ë‘ í‘œì‹œ)
                        ctx.fillStyle = '#8a8fa5';
                        ctx.beginPath(); ctx.arc(x, y, 2, 0, Math.PI*2); ctx.fill();
                    }
                });

                // í˜„ì¬ í‹±ì˜ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ í•˜ì´ë¼ì´íŠ¸ (íŒŒë‘ í° ì ) - ê³ ìœ  ìƒ˜í”Œì—ì„œ ì°¾ê¸°
                const curr = uniqueSamples.reduce((prev, s) => {
                    const prevDiff = prev ? Math.abs(s.time - currentTime) : Infinity;
                    const currDiff = Math.abs(s.time - currentTime);
                    return currDiff < prevDiff ? s : prev;
                }, null);
                if (curr) {
                    const cx = xScale(curr.yaw), cy = yScale(curr.pitch);
                    ctx.fillStyle = '#4a90e2';
                    ctx.beginPath(); ctx.arc(cx, cy, 6, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 2; ctx.stroke();
                }

                // ë²”ë¡€
                const legend = [
                    {label:'Current', color:'#4a90e2'},
                    {label:'Kill', color:'#cc0000'}
                ];
                let lx = pad, ly = pad-12;
                legend.forEach(l =>{
                    ctx.fillStyle = l.color; ctx.beginPath(); ctx.arc(lx,ly,4,0,Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#8a8fa5'; ctx.fillText(l.label, lx+10, ly+4);
                    lx += 80;
                });

                // ì œëª© ë° ê±°ë¦¬ ì •ë³´
                ctx.fillStyle = '#ffffff'; ctx.font = '14px Arial';
                let titleText = `Aim Trace - ${name || 'N/A'}`;
                
                // í‚¬ ì´ë²¤íŠ¸ê°€ ìˆìœ¼ë©´ ê±°ë¦¬ ì •ë³´ ì¶”ê°€
                if (this.selectedEvent && this.selectedEvent.attacker && this.selectedEvent.victim) {
                    const attackerPos = this.selectedEvent.attacker.position;
                    const victimPos = this.selectedEvent.victim.position;
                    if (attackerPos && victimPos && attackerPos[0] !== null && victimPos[0] !== null) {
                        // 3D ìœ í´ë¦¬ë“œ ê±°ë¦¬ ê³„ì‚° (Source ì—”ì§„ ì¢Œí‘œê³„)
                        // position ë°°ì—´: [X, Z, Y] (X: ì¢Œìš°, Y: ì „í›„, Z: ë†’ì´)
                        const dx = attackerPos[0] - victimPos[0]; // X ì°¨ì´
                        const dy = attackerPos[1] - victimPos[1]; // Z ì°¨ì´ (ë†’ì´)
                        const dz = attackerPos[2] - victimPos[2]; // Y ì°¨ì´ (ì „í›„)
                        const distanceUnits = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        
                        // Source ì—”ì§„ ë‹¨ìœ„ ë³€í™˜: 1 unit = 0.75 ì¸ì¹˜ = ì•½ 1.905 cm
                        // ë˜ëŠ” 1 unit = 1 ì¸ì¹˜ = 2.54 cm (ì¼ë¶€ ê²Œì„)
                        // CS:GO/CS2 ê¸°ì¤€: 1 unit = 0.75 ì¸ì¹˜ = 1.905 cm
                        const distanceMeters = distanceUnits * 0.75 * 2.54 / 100; // ë¯¸í„°ë¡œ ë³€í™˜
                        const distanceFeet = distanceUnits * 0.75 / 12; // í”¼íŠ¸ë¡œ ë³€í™˜
                        
                        titleText += ` | ì‚¬ê±°ë¦¬: ${distanceUnits.toFixed(1)} units (${distanceMeters.toFixed(2)}m / ${distanceFeet.toFixed(1)}ft)`;
                    }
                }
                
                ctx.fillText(titleText, pad, 20);
            }

            generateReport(playerName) {
                if (!this.data || !playerName) return;
                
                const stats = this.data.metadata.playerStats[playerName] || { kills: 0, deaths: 0, team: '' };
                // í”Œë ˆì´ì–´ê°€ í‚¬í•œ ì´ë²¤íŠ¸ë§Œ í•„í„°ë§ (ì¤‘ë³µ ì œê±°)
                let playerKills = this.data.events.filter(e => 
                    e.attacker && e.attacker.name === playerName &&
                    e.event_type_lower && e.event_type_lower.includes('kill')
                );
                
                // ê°™ì€ tickì˜ ì¤‘ë³µ í‚¬ ì œê±°
                const seenTicks = new Set();
                playerKills = playerKills.filter(e => {
                    if (seenTicks.has(e.tick)) {
                        return false;
                    }
                    seenTicks.add(e.tick);
                    return true;
                });
                
                console.log('Generate Report - í”Œë ˆì´ì–´ í‚¬ ìˆ˜ (ì¤‘ë³µ ì œê±° í›„):', playerKills.length);
                
                // ê° í‚¬ ì´ë²¤íŠ¸ë³„ë¡œ Aim Trace ìƒì„± (Â±30í‹± ë²”ìœ„)
                const killTraceImages = [];
                
                playerKills.forEach((killEvent, killIdx) => {
                    // í‚¬ ì´ë²¤íŠ¸ì˜ í‹± ì¸ë±ìŠ¤ ì°¾ê¸°
                    const killTickIdx = this.data.positions.findIndex(p => p.tick === killEvent.tick);
                    if (killTickIdx === -1) return;
                    
                    // Â±30í‹± ë²”ìœ„ ê³„ì‚°
                    const startIdx = Math.max(0, killTickIdx - 30);
                    const endIdx = Math.min(this.data.positions.length - 1, killTickIdx + 30);
                    
                    // í•´ë‹¹ ë²”ìœ„ì˜ Aim ë°ì´í„° ìˆ˜ì§‘
                    const killAimData = [];
                    for (let idx = startIdx; idx <= endIdx; idx++) {
                        const pos = this.data.positions[idx];
                        if (pos) {
                            const player = pos.players.find(p => p.name === playerName);
                            if (player && player.yaw !== null && player.yaw !== undefined && !Number.isNaN(player.yaw) &&
                                player.pitch !== null && player.pitch !== undefined && !Number.isNaN(player.pitch)) {
                                killAimData.push({
                                    yaw: player.yaw,
                                    pitch: player.pitch,
                                    time: pos.game_time,
                                    tick: pos.tick,
                                    tickIdx: idx,
                                    type: idx === killTickIdx ? 'kill' : 'move'
                                });
                            }
                        }
                    }
                    
                    if (killAimData.length === 0) return;
                    
                    // ì¤‘ë³µ ì œê±° (ì—°ì†ëœ ê°™ì€ ê°’)
                    const uniqueKillAimData = [];
                    let lastYaw = null;
                    let lastPitch = null;
                    killAimData.forEach(s => {
                        if (lastYaw === null || lastPitch === null ||
                            Math.abs(s.yaw - lastYaw) > 0.01 || Math.abs(s.pitch - lastPitch) > 0.01) {
                            uniqueKillAimData.push(s);
                            lastYaw = s.yaw;
                            lastPitch = s.pitch;
                        }
                    });
                    
                    // Aim Trace ìº”ë²„ìŠ¤ ìƒì„±
                    const killTraceCanvas = document.createElement('canvas');
                    killTraceCanvas.width = 800;
                    killTraceCanvas.height = 600;
                    const killCtx = killTraceCanvas.getContext('2d');
                    
                    // ë™ì  ë²”ìœ„ ê³„ì‚°
                    const yaws = uniqueKillAimData.map(s => s.yaw);
                    const pitches = uniqueKillAimData.map(s => s.pitch);
                    let xMin = Math.min(...yaws);
                    let xMax = Math.max(...yaws);
                    let yMin = Math.min(...pitches);
                    let yMax = Math.max(...pitches);
                    
                    // ë²”ìœ„ê°€ ë„ˆë¬´ ì¢ìœ¼ë©´ í™•ëŒ€
                    const xRange = xMax - xMin;
                    const yRange = yMax - yMin;
                    if (xRange < 10) {
                        const center = (xMin + xMax) / 2;
                        xMin = center - 10;
                        xMax = center + 10;
                    }
                    if (yRange < 10) {
                        const center = (yMin + yMax) / 2;
                        yMin = center - 10;
                        yMax = center + 10;
                    }
                    
                    // íŒ¨ë”© ì¶”ê°€
                    const xPadding = (xMax - xMin) * 0.1;
                    const yPadding = (yMax - yMin) * 0.1;
                    xMin -= xPadding;
                    xMax += xPadding;
                    yMin -= yPadding;
                    yMax += yPadding;
                    
                    const pad = 40;
                    const W = killTraceCanvas.width, H = killTraceCanvas.height;
                    
                    function xScale(v){ return pad + (v - xMin) / (xMax - xMin) * (W - 2*pad); }
                    function yScale(v){ return H - (pad + (v - yMin) / (yMax - yMin) * (H - 2*pad)); }
                    
                    // ë°°ê²½
                    killCtx.fillStyle = '#0a0e15';
                    killCtx.fillRect(0, 0, W, H);
                    
                    // ê·¸ë¦¬ë“œ
                    killCtx.strokeStyle = '#2a2f3e';
                    killCtx.lineWidth = 1;
                    const xStep = Math.max(10, Math.ceil((xMax - xMin) / 10));
                    const yStep = Math.max(5, Math.ceil((yMax - yMin) / 10));
                    for (let x = Math.floor(xMin / xStep) * xStep; x <= xMax; x += xStep) {
                        const sx = xScale(x);
                        if (sx >= pad && sx <= W - pad) {
                            killCtx.beginPath();
                            killCtx.moveTo(sx, pad);
                            killCtx.lineTo(sx, H - pad);
                            killCtx.stroke();
                        }
                    }
                    for (let y = Math.floor(yMin / yStep) * yStep; y <= yMax; y += yStep) {
                        const sy = yScale(y);
                        if (sy >= pad && sy <= H - pad) {
                            killCtx.beginPath();
                            killCtx.moveTo(pad, sy);
                            killCtx.lineTo(W - pad, sy);
                            killCtx.stroke();
                        }
                    }
                    
                    // ê²½ë¡œ ì—°ê²°ì„ 
                    if (uniqueKillAimData.length > 1) {
                        killCtx.beginPath();
                        killCtx.strokeStyle = '#5a637a';
                        killCtx.lineWidth = 1.5;
                        killCtx.moveTo(xScale(uniqueKillAimData[0].yaw), yScale(uniqueKillAimData[0].pitch));
                        for (let i = 1; i < uniqueKillAimData.length; i++) {
                            killCtx.lineTo(xScale(uniqueKillAimData[i].yaw), yScale(uniqueKillAimData[i].pitch));
                        }
                        killCtx.stroke();
                    }
                    
                    // í¬ì¸íŠ¸
                    uniqueKillAimData.forEach(s => {
                        const x = xScale(s.yaw), y = yScale(s.pitch);
                        if (s.type === 'kill') {
                            // Kill ì‹œì : ì§„ë¹¨ê°• í° ì› + í…Œë‘ë¦¬
                            killCtx.fillStyle = '#cc0000';
                            killCtx.beginPath();
                            killCtx.arc(x, y, 5, 0, Math.PI*2);
                            killCtx.fill();
                            killCtx.strokeStyle = '#ff3333';
                            killCtx.lineWidth = 2;
                            killCtx.stroke();
                        } else {
                            // ì¼ë°˜ ì´ë™ í¬ì¸íŠ¸: ì‘ì€ íšŒìƒ‰ ì 
                            killCtx.fillStyle = '#8a8fa5';
                            killCtx.beginPath();
                            killCtx.arc(x, y, 2, 0, Math.PI*2);
                            killCtx.fill();
                        }
                    });
                    
                    // ì œëª© ë° ì •ë³´
                    killCtx.fillStyle = '#ffffff';
                    killCtx.font = 'bold 16px Arial';
                    killCtx.fillText(`Kill #${killIdx + 1} - ${killEvent.victim ? killEvent.victim.name : 'Unknown'}`, pad, 25);
                    killCtx.font = '12px Arial';
                    killCtx.fillStyle = '#8a8fa5';
                    const timeStr = killEvent.game_time ? `${Math.floor(killEvent.game_time / 60)}:${(killEvent.game_time % 60).toFixed(2)}` : 'N/A';
                    killCtx.fillText(`Time: ${timeStr} | Tick: ${killEvent.tick}`, pad, 45);
                    killCtx.fillText(`Yaw: [${xMin.toFixed(1)} ~ ${xMax.toFixed(1)}] Pitch: [${yMin.toFixed(1)} ~ ${yMax.toFixed(1)}]`, pad, H - 15);
                    
                    killTraceImages.push({
                        image: killTraceCanvas.toDataURL('image/png'),
                        killNum: killIdx + 1,
                        victim: killEvent.victim ? killEvent.victim.name : 'Unknown',
                        time: timeStr
                    });
                });
                
                // ëª¨ë“  í‚¬ íŠ¸ë ˆì´ìŠ¤ë¥¼ í•˜ë‚˜ì˜ ì´ë¯¸ì§€ë¡œ í•©ì¹˜ê¸° (ì„¸ë¡œë¡œ ë°°ì¹˜) - ë¹„ë™ê¸° ì²˜ë¦¬
                const generateCombinedImage = () => {
                    return new Promise((resolve) => {
                        if (killTraceImages.length === 0) {
                            resolve('');
                            return;
                        }
                        
                        const combinedCanvas = document.createElement('canvas');
                        const traceHeight = 600;
                        const traceSpacing = 20;
                        combinedCanvas.width = 800;
                        combinedCanvas.height = killTraceImages.length * (traceHeight + traceSpacing) - traceSpacing;
                        const combinedCtx = combinedCanvas.getContext('2d');
                        
                        combinedCtx.fillStyle = '#1a1f2e';
                        combinedCtx.fillRect(0, 0, combinedCanvas.width, combinedCanvas.height);
                        
                        let loadedCount = 0;
                        killTraceImages.forEach((trace, idx) => {
                            const img = new Image();
                            img.onload = () => {
                                const y = idx * (traceHeight + traceSpacing);
                                combinedCtx.drawImage(img, 0, y);
                                loadedCount++;
                                if (loadedCount === killTraceImages.length) {
                                    resolve(combinedCanvas.toDataURL('image/png'));
                                }
                            };
                            img.onerror = () => {
                                loadedCount++;
                                if (loadedCount === killTraceImages.length) {
                                    resolve(combinedCanvas.toDataURL('image/png'));
                                }
                            };
                            img.src = trace.image;
                        });
                    });
                };
                
                // ë³´ê³ ì„œ ìƒì„± (ì´ë¯¸ì§€ ë¡œë”© ëŒ€ê¸°)
                generateCombinedImage().then(combinedAimTraceImage => {
                
                    // ë³´ê³ ì„œ HTML ìƒì„±
                    const reportHTML = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Player Report - ${playerName}</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #1a1f2e; color: #fff; }
        .header { border-bottom: 2px solid #4a90e2; padding-bottom: 10px; margin-bottom: 20px; }
        .section { margin: 20px 0; padding: 15px; background: #2a2f3e; border-radius: 8px; }
        .stat-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; }
        .stat-item { padding: 10px; background: #1a1f2e; border-radius: 4px; }
        .stat-label { color: #8a8fa5; font-size: 12px; }
        .stat-value { color: #fff; font-size: 18px; font-weight: bold; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #3a3f4e; }
        th { background: #1a1f2e; color: #4a90e2; }
    </style>
</head>
<body>
    <button id="download-btn" style="position:fixed; top:16px; right:16px; background:#4a90e2; color:#fff; border:none; padding:8px 12px; border-radius:4px; cursor:pointer; box-shadow:0 2px 6px rgba(0,0,0,0.3);">Download</button>
    <div class="header">
        <h1>Player Analysis Report</h1>
        <h2>${playerName}</h2>
        <p>Generated: ${new Date().toLocaleString()}</p>
    </div>
    
    <div class="section">
        <h3>Match Statistics</h3>
        <div class="stat-grid">
            <div class="stat-item">
                <div class="stat-label">Team</div>
                <div class="stat-value">${stats.team || 'N/A'}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Kills</div>
                <div class="stat-value">${stats.kills}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Deaths</div>
                <div class="stat-value">${stats.deaths}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">K/D Ratio</div>
                <div class="stat-value">${stats.deaths > 0 ? (stats.kills / stats.deaths).toFixed(2) : stats.kills.toFixed(2)}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Total Kills</div>
                <div class="stat-value">${playerKills.length}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Kill Traces</div>
                <div class="stat-value">${killTraceImages.length}</div>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>Kill Events</h3>
        <table>
            <tr><th>Time</th><th>Event</th><th>Victim</th><th>Weapon</th><th>Headshot</th></tr>
            ${playerKills.slice(0, 20).map(e => `
                <tr>
                    <td>${this.formatTime(e.game_time)}</td>
                    <td>${e.attacker.name === playerName ? 'KILLED' : 'DIED'}</td>
                    <td>${e.attacker.name === playerName ? e.victim.name : e.attacker.name}</td>
                    <td>${e.weapon || 'N/A'}</td>
                    <td>${e.headshot ? 'Yes' : 'No'}</td>
                </tr>
            `).join('')}
        </table>
    </div>
    
    <div class="section">
        <h3>Aim Movement Analysis - Kill Events</h3>
        <p>Total Kills: ${playerKills.length}</p>
        <p>Kill Traces Generated: ${killTraceImages.length}</p>
        ${killTraceImages.length > 0 ? `
            <div style="margin-top: 15px;">
                <h4>Individual Kill Aim Traces (Â±30 ticks around each kill)</h4>
                ${killTraceImages.map(trace => `
                    <div style="margin-bottom: 30px; padding: 15px; background: #1a1f2e; border-radius: 4px;">
                        <h5 style="color: #4a90e2; margin-bottom: 10px;">Kill #${trace.killNum} - ${trace.victim} (Time: ${trace.time})</h5>
                        <img src="${trace.image}" style="max-width: 100%; border: 1px solid #3a3f4e; border-radius: 4px;" />
                    </div>
                `).join('')}
                
            </div>
        ` : '<p>No kill events with aim data available</p>'}
    </div>
</body>
<script>
    (function(){
        const btn = document.getElementById('download-btn');
        if (btn) {
            btn.addEventListener('click', function(){
                const html = document.documentElement.outerHTML;
                const blob = new Blob([html], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const filename = 'report_' + '${playerName}' + '_' + Date.now() + '.html';
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            });
        }
    })();
<\/script>
</html>
                `;
                    
                    // ìƒˆ ì°½ìœ¼ë¡œ ì—´ê¸°
                    const win = window.open('', '_blank');
                    win.document.write(reportHTML);
                    win.document.close();
                    
                    // ë‹¤ìš´ë¡œë“œëŠ” ë¦¬í¬íŠ¸ ìš°ì¸¡ ìƒë‹¨ ë²„íŠ¼ì„ í†µí•´ ìˆ˜í–‰
                });
            }

            setupMapBounds() {
                if (!this.mapBounds) return;
                
                // ë§µ ê²½ê³„ ë°•ìŠ¤ í‘œì‹œ
                const bounds = this.mapBounds;
                const width = bounds.width;
                const height = bounds.depth;
                const depth = bounds.height;
                
                const geometry = new THREE.BoxGeometry(width, depth, height);
                const edges = new THREE.EdgesGeometry(geometry);
                const line = new THREE.LineSegments(
                    edges,
                    new THREE.LineBasicMaterial({ color: 0x4a90e2, opacity: 0.3, transparent: true })
                );
                line.position.set(bounds.centerX, bounds.centerZ, bounds.centerY);
                this.scene.add(line);
                
                // ì¹´ë©”ë¼ ìœ„ì¹˜ ì¡°ì • ë° ê¸°ë³¸ ê±°ë¦¬ ì„¤ì •
                const maxDim = Math.max(width, height, depth);
                this.baseCameraDistance = maxDim * 1.2;
                this.cameraDistance = this.baseCameraDistance;
                this.camera.position.set(
                    bounds.centerX,
                    bounds.centerZ + maxDim * 0.8,
                    bounds.centerY + maxDim * 1.2
                );
                this.camera.lookAt(bounds.centerX, bounds.centerZ, bounds.centerY);
                
                // ê·¸ë¦¬ë“œ ì¡°ì • (ë” ëª…í™•í•˜ê²Œ)
                const gridSize = Math.max(width, height) * 1.2;
                const gridDivisions = Math.ceil(gridSize / 100); // 100 ë‹¨ìœ„ë¡œ êµ¬ë¶„
                const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x4a90e2, 0x2a3f5a);
                gridHelper.position.set(bounds.centerX, 0, bounds.centerY);
                this.scene.add(gridHelper);
                
                // êµ¬ì—­ í‘œì‹œë¥¼ ìœ„í•œ ì„  ì¶”ê°€ (10x10 êµ¬ì—­)
                const sectorSize = Math.max(width, height) / 10;
                const sectorsHelper = new THREE.Group();
                
                // Xì¶• ì„ 
                for (let i = 0; i <= 10; i++) {
                    const x = bounds.minX + (width / 10) * i;
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(x, bounds.centerZ, bounds.minY),
                        new THREE.Vector3(x, bounds.centerZ, bounds.maxY)
                    ]);
                    const lineMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x3a4f6a, 
                        opacity: 0.3, 
                        transparent: true 
                    });
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    sectorsHelper.add(line);
                }
                
                // Yì¶• ì„ 
                for (let i = 0; i <= 10; i++) {
                    const y = bounds.minY + (height / 10) * i;
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(bounds.minX, bounds.centerZ, y),
                        new THREE.Vector3(bounds.maxX, bounds.centerZ, y)
                    ]);
                    const lineMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x3a4f6a, 
                        opacity: 0.3, 
                        transparent: true 
                    });
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    sectorsHelper.add(line);
                }
                
                this.scene.add(sectorsHelper);
                
                // ì¢Œí‘œì¶• í‘œì‹œ (ì›ì  ë° ì£¼ìš” êµ¬ì—­)
                const axesHelper = new THREE.AxesHelper(Math.max(width, height) * 0.1);
                axesHelper.position.set(bounds.centerX, bounds.centerZ, bounds.centerY);
                this.scene.add(axesHelper);
                
                // êµ¬ì—­ ë¼ë²¨ ì¶”ê°€ (ì£¼ìš” í¬ì¸íŠ¸)
                const labelPoints = [
                    { x: bounds.minX, y: bounds.minY, label: 'A1' },
                    { x: bounds.centerX, y: bounds.minY, label: 'B1' },
                    { x: bounds.maxX, y: bounds.minY, label: 'C1' },
                    { x: bounds.minX, y: bounds.centerY, label: 'A2' },
                    { x: bounds.centerX, y: bounds.centerY, label: 'Center' },
                    { x: bounds.maxX, y: bounds.centerY, label: 'C2' },
                    { x: bounds.minX, y: bounds.maxY, label: 'A3' },
                    { x: bounds.centerX, y: bounds.maxY, label: 'B3' },
                    { x: bounds.maxX, y: bounds.maxY, label: 'C3' }
                ];
                
                labelPoints.forEach(point => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 128;
                    canvas.height = 32;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#8a8fa5';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(point.label, canvas.width / 2, canvas.height / 2 + 4);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                        map: texture, 
                        transparent: true 
                    }));
                    sprite.position.set(point.x, bounds.centerZ + 5, point.y);
                    sprite.scale.set(40, 10, 1);
                    this.scene.add(sprite);
                });
                
                // UI ì—…ë°ì´íŠ¸
                document.getElementById('map-bounds').textContent = 
                    `X: ${bounds.minX.toFixed(0)} ~ ${bounds.maxX.toFixed(0)}\n` +
                    `Y: ${bounds.minY.toFixed(0)} ~ ${bounds.maxY.toFixed(0)}\n` +
                    `Z: ${bounds.minZ.toFixed(0)} ~ ${bounds.maxZ.toFixed(0)}\n` +
                    `Size: ${width.toFixed(0)} Ã— ${height.toFixed(0)} Ã— ${depth.toFixed(0)}`;
            }

            setupScene() {
                const container = document.getElementById('canvas-container');
                const width = container.clientWidth;
                const height = container.clientHeight;

                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0e15);
                this.scene.fog = new THREE.Fog(0x0a0e15, 1000, 5000);

                this.camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 10000);
                this.camera.position.set(0, 500, 1000);
                this.camera.lookAt(0, 0, 0);

                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('canvas'),
                    antialias: true 
                });
                this.renderer.setSize(width, height);
                this.renderer.shadowMap.enabled = true;

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
                directionalLight.position.set(500, 1000, 500);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);

                window.addEventListener('resize', () => {
                    const width = container.clientWidth;
                    const height = container.clientHeight;
                    this.camera.aspect = width / height;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(width, height);
                });
            }

            setupControls() {
                let isMouseDown = false;
                let isPanning = false; // íŒ¨ë‹ ëª¨ë“œ í”Œë˜ê·¸
                let mouseX = 0, mouseY = 0;
                
                // íŒ¨ë‹ ì˜¤í”„ì…‹ì„ ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë¡œ ì´ˆê¸°í™”
                if (!this.panOffset) {
                    this.panOffset = { x: 0, y: 0, z: 0 };
                }

                const canvas = document.getElementById('canvas');
                
                canvas.addEventListener('mousedown', (e) => {
                    isMouseDown = true;
                    isPanning = e.shiftKey; // Shift í‚¤ê°€ ëˆŒë ¤ìˆìœ¼ë©´ íŒ¨ë‹ ëª¨ë“œ
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });

                canvas.addEventListener('mousemove', (e) => {
                    if (isMouseDown) {
                        const deltaX = e.clientX - mouseX;
                        const deltaY = e.clientY - mouseY;
                        
                        if (isPanning || e.shiftKey) {
                            // íŒ¨ë‹ ëª¨ë“œ: ì¹´ë©”ë¼ë¥¼ í‰ë©´ìœ¼ë¡œ ì´ë™
                            const panSpeed = 0.5;
                            const right = new THREE.Vector3();
                            const up = new THREE.Vector3();
                            
                            // ì¹´ë©”ë¼ì˜ ì˜¤ë¥¸ìª½ ë°©í–¥ ê³„ì‚°
                            this.camera.getWorldDirection(new THREE.Vector3());
                            right.setFromMatrixColumn(this.camera.matrixWorld, 0);
                            up.setFromMatrixColumn(this.camera.matrixWorld, 1);
                            
                            // íŒ¨ë‹ ì˜¤í”„ì…‹ ëˆ„ì 
                            this.panOffset.x -= right.x * deltaX * panSpeed;
                            this.panOffset.y -= right.y * deltaX * panSpeed;
                            this.panOffset.z -= right.z * deltaX * panSpeed;
                            
                            this.panOffset.x += up.x * deltaY * panSpeed;
                            this.panOffset.y += up.y * deltaY * panSpeed;
                            this.panOffset.z += up.z * deltaY * panSpeed;
                        } else {
                            // ì¼ë°˜ ëª¨ë“œ: ì¹´ë©”ë¼ íšŒì „
                            this.cameraRotationY += deltaX * 0.01;
                            this.cameraRotationX += deltaY * 0.01;
                            this.cameraRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.cameraRotationX));
                        }
                        mouseX = e.clientX;
                        mouseY = e.clientY;
                    }
                });

                canvas.addEventListener('mouseup', () => {
                    isMouseDown = false;
                    isPanning = false;
                });
                
                // Shift í‚¤ ìƒíƒœ ì¶”ì 
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Shift' && isMouseDown) {
                        isPanning = true;
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    if (e.key === 'Shift') {
                        isPanning = false;
                    }
                });

                canvas.addEventListener('wheel', (e) => {
                    const speed = e.shiftKey ? 2 : 1; // Shiftë¡œ ë” ë¹ ë¥´ê²Œ
                    this.cameraDistance += e.deltaY * 5 * speed;
                    // í™•ëŒ€/ì¶•ì†Œ í•œê³„ ì™„í™”
                    const minDist = this.baseCameraDistance * 0.05; // ë” ê°€ê¹Œì´ í™•ëŒ€
                    const maxDist = this.baseCameraDistance * 10.0;  // ë” ë©€ë¦¬ ì¶•ì†Œ
                    this.cameraDistance = Math.max(minDist, Math.min(maxDist, this.cameraDistance));
                    e.preventDefault();
                });
                
                this.updateCamera = () => {
                    // íƒ€ê²Ÿì´ ì„¤ì •ë˜ì–´ ìˆìœ¼ë©´ íƒ€ê²Ÿ ì¤‘ì‹¬, ì—†ìœ¼ë©´ ë§µ ì¤‘ì‹¬
                    if (this.cameraTarget) {
                        // í¬ì»¤ìŠ¤ ëª¨ë“œì—ì„œë„ íŒ¨ë‹ ì˜¤í”„ì…‹ ì ìš©
                        const target = this.cameraTarget;
                        const baseX = target.x + this.cameraDistance * Math.sin(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                        const baseY = target.y + this.cameraDistance * Math.sin(this.cameraRotationX);
                        const baseZ = target.z + this.cameraDistance * Math.cos(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                        // íŒ¨ë‹ ì˜¤í”„ì…‹ ì ìš©
                        this.camera.position.set(
                            baseX + this.panOffset.x,
                            baseY + this.panOffset.y,
                            baseZ + this.panOffset.z
                        );
                        this.camera.lookAt(
                            target.x + this.panOffset.x,
                            target.y + this.panOffset.y,
                            target.z + this.panOffset.z
                        );
                    } else if (this.mapBounds) {
                        const bounds = this.mapBounds;
                        const baseX = bounds.centerX + this.cameraDistance * Math.sin(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                        const baseY = bounds.centerZ + this.cameraDistance * Math.sin(this.cameraRotationX);
                        const baseZ = bounds.centerY + this.cameraDistance * Math.cos(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                        // íŒ¨ë‹ ì˜¤í”„ì…‹ ì ìš©
                        this.camera.position.set(
                            baseX + this.panOffset.x,
                            baseY + this.panOffset.y,
                            baseZ + this.panOffset.z
                        );
                        this.camera.lookAt(
                            bounds.centerX + this.panOffset.x,
                            bounds.centerZ + this.panOffset.y,
                            bounds.centerY + this.panOffset.z
                        );
                    } else {
                        const baseX = this.cameraDistance * Math.sin(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                        const baseY = this.cameraDistance * Math.sin(this.cameraRotationX);
                        const baseZ = this.cameraDistance * Math.cos(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                        // íŒ¨ë‹ ì˜¤í”„ì…‹ ì ìš©
                        this.camera.position.set(
                            baseX + this.panOffset.x,
                            baseY + this.panOffset.y,
                            baseZ + this.panOffset.z
                        );
                        this.camera.lookAt(
                            this.panOffset.x,
                            this.panOffset.y,
                            this.panOffset.z
                        );
                    }
                };

                document.getElementById('play-btn').addEventListener('click', () => {
                    this.togglePlay();
                });

                document.getElementById('timeline').addEventListener('click', (e) => {
                    const rect = e.currentTarget.getBoundingClientRect();
                    const percent = (e.clientX - rect.left) / rect.width;
                    this.seekTo(percent);
                });

                document.querySelectorAll('.speed-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        const newSpeed = parseFloat(btn.dataset.speed);
                        console.log('ì¬ìƒ ì†ë„ ë³€ê²½:', this.playSpeed, '->', newSpeed);
                        this.playSpeed = newSpeed;
                        // ì¬ìƒ ì†ë„ ë³€ê²½ ì‹œ ì¦‰ì‹œ ë°˜ì˜ë˜ë„ë¡ lastUpdateTime ë¦¬ì…‹
                        this.lastUpdateTime = Date.now();
                    });
                });

                // ESC í‚¤ë¡œ í¬ì»¤ìŠ¤ ëª¨ë“œ ì¢…ë£Œ
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.focusMode) {
                        this.exitFocusMode();
                    }
                });

                // Reset view
                document.getElementById('reset-view').addEventListener('click', () => {
                    this.cameraRotationX = 0.3;
                    this.cameraRotationY = 0;
                    this.cameraDistance = this.baseCameraDistance;
                    this.cameraTarget = null; // íƒ€ê²Ÿ í•´ì œ
                    // íŒ¨ë‹ ì˜¤í”„ì…‹ ì´ˆê¸°í™”
                    if (this.panOffset) {
                        this.panOffset.x = 0;
                        this.panOffset.y = 0;
                        this.panOffset.z = 0;
                    }
                    this.updateCamera();
                });
            }

            setupResizableBottom() {
                const panel = document.getElementById('bottom-panel');
                const handle = document.getElementById('resize-handle');
                const minH = 160; // px
                const maxH = Math.floor(window.innerHeight * 0.8);
                // Load saved height
                const saved = localStorage.getItem('bottomPanelHeight');
                if (saved) panel.style.height = `${parseInt(saved,10)}px`;

                let dragging = false;
                let startY = 0;
                let startH = 0;

                handle.addEventListener('mousedown', (e) => {
                    dragging = true;
                    startY = e.clientY;
                    startH = panel.getBoundingClientRect().height;
                    document.body.style.userSelect = 'none';
                });

                window.addEventListener('mousemove', (e) => {
                    if (!dragging) return;
                    const dy = startY - e.clientY; // drag up increases height
                    let h = startH + dy;
                    h = Math.max(minH, Math.min(maxH, h));
                    panel.style.height = `${h}px`;
                });

                window.addEventListener('mouseup', () => {
                    if (!dragging) return;
                    dragging = false;
                    document.body.style.userSelect = '';
                    const h = panel.getBoundingClientRect().height;
                    localStorage.setItem('bottomPanelHeight', String(Math.round(h)));
                });
            }

            updateUI() {
                if (!this.data) return;

                const m = this.data.metadata;
                document.getElementById('total-players').textContent = m.players.length;
                document.getElementById('total-events').textContent = m.total_events;
                
                const duration = m.time_range.max - m.time_range.min;
                const mins = Math.floor(duration / 60);
                const secs = Math.floor(duration % 60);
                document.getElementById('game-length').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
                document.getElementById('match-length').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
                
                const startDate = new Date();
                startDate.setHours(8, 55, 0);
                document.getElementById('start-time').textContent = startDate.toLocaleDateString('ko-KR');
                document.getElementById('match-start-time').textContent = startDate.toLocaleDateString('ko-KR');

                const playerList = document.getElementById('player-list');
                playerList.innerHTML = '';
                m.players.forEach(name => {
                    const stats = m.playerStats[name] || { kills: 0, deaths: 0, team: '' };
                    const item = document.createElement('div');
                    item.className = `player-item ${stats.team.toLowerCase()}`;
                    const kd = stats.deaths > 0 ? (stats.kills / stats.deaths).toFixed(2) : stats.kills.toFixed(2);
                    item.innerHTML = `
                        <span>${name}</span>
                        <span class="player-kd">${stats.kills}/${stats.deaths} (${kd})</span>
                    `;
                    item.style.cursor = 'pointer';
                    item.addEventListener('click', () => {
                        // í”Œë ˆì´ì–´ í´ë¦­ ì‹œ í•´ë‹¹ í”Œë ˆì´ì–´ê°€ ì°¸ì—¬í•œ í‚¬ ì´ë²¤íŠ¸ë¡œ í•„í„°ë§
                        const playerKills = this.data.events.filter(e => 
                            (e.attacker.name === name || e.victim.name === name) &&
                            (e.event_type_lower.includes('kill') || e.event_type_lower.includes('died'))
                        );
                        if (playerKills.length > 0) {
                            this.selectEvent(playerKills[0]);
                        }
                    });
                    playerList.appendChild(item);
                });

                this.updateEventLog();
            }

            populateKillPicker() {
                if (!this.data) return;
                const select = document.getElementById('kill-select');
                const goBtn = document.getElementById('go-kill');
                select.innerHTML = '';
                const kills = this.data.events.filter(e => (e.event_type_lower||'').includes('kill') || (e.event_type_lower||'').includes('died'));
                if (kills.length === 0) {
                    const opt = document.createElement('option');
                    opt.textContent = 'No kill events';
                    opt.value = '';
                    select.appendChild(opt);
                    goBtn.disabled = true;
                    return;
                }
                goBtn.disabled = false;
                kills.forEach((e, idx) => {
                    const opt = document.createElement('option');
                    const t = this.formatTime(e.game_time);
                    const label = `${t} ${e.attacker.name || 'Unknown'} â†’ ${e.victim.name || 'Unknown'}`;
                    opt.value = String(idx);
                    opt.textContent = label;
                    select.appendChild(opt);
                });

                goBtn.onclick = () => {
                    const i = parseInt(select.value);
                    if (isNaN(i)) return;
                    const e = kills[i];
                    this.selectEvent(e);
                };
            }

            populatePlayerPicker() {
                if (!this.data || !this.playerIndex) return;
                const select = document.getElementById('player-select');
                select.innerHTML = '<option value="">Players</option>';
                Array.from(this.playerIndex.keys()).sort().forEach(name => {
                    const opt = document.createElement('option');
                    opt.value = name;
                    opt.textContent = name;
                    select.appendChild(opt);
                });

                select.onchange = () => {
                    this.selectedPlayer = select.value || null;
                };

                document.getElementById('follow-toggle').onclick = () => {
                    if (!this.selectedPlayer) return;
                    this.followPlayer = !this.followPlayer;
                    document.getElementById('follow-toggle').textContent = this.followPlayer ? 'Following' : 'Follow';
                    if (!this.followPlayer) {
                        this.cameraTarget = null;
                    }
                };

                document.getElementById('prev-player-tick').onclick = () => {
                    this.seekToPlayerTick(-1);
                };
                document.getElementById('next-player-tick').onclick = () => {
                    this.seekToPlayerTick(1);
                };
            }

            seekToPlayerTick(direction) {
                if (!this.selectedPlayer || !this.playerIndex.has(this.selectedPlayer)) return;
                const arr = this.playerIndex.get(this.selectedPlayer);
                if (!arr || arr.length === 0) return;
                // í˜„ì¬ í‹± ê¸°ì¤€ ì´ì „/ë‹¤ìŒ í•­ëª© ì°¾ê¸°
                let idx = arr.findIndex(e => e.tick >= this.data.positions[this.currentTick].tick);
                if (idx === -1) idx = arr.length - 1;
                idx = idx + direction;
                idx = Math.max(0, Math.min(arr.length - 1, idx));
                const target = arr[idx];
                const tickIdx = this.findTickByTime(target.time);
                if (tickIdx !== -1) {
                    this.currentTick = tickIdx;
                    if (this.followPlayer) {
                        this.cameraTarget = { x: target.position[0], y: target.position[2], z: target.position[1] };
                    }
                    this.renderTick(this.currentTick);
                    this.updateTimeDisplay();
                }
            }

            updateEventLog() {
                if (!this.data) return;
                
                const eventLog = document.getElementById('event-log');
                eventLog.innerHTML = '';
                
                let eventsToShow = this.data.events;
                
                // í¬ì»¤ìŠ¤ ëª¨ë“œì¸ ê²½ìš° ì‹œê°„ ë²”ìœ„ í•„í„°ë§
                if (this.focusMode && this.focusTickRange) {
                    const startT = this.data.positions[this.focusTickRange.startIdx].game_time;
                    const endT = this.data.positions[this.focusTickRange.endIdx].game_time;
                    eventsToShow = this.data.events.filter(e => e.game_time >= startT && e.game_time <= endT);
                } else {
                    // í˜„ì¬ ì‹œê°„ ê¸°ì¤€ Â±5ì´ˆ ì´ë‚´ ì´ë²¤íŠ¸ í‘œì‹œ
                    const currentTickData = this.data.positions[this.currentTick];
                    const currentTime = currentTickData ? currentTickData.game_time : 0;
                    eventsToShow = this.data.events.filter(e => 
                        Math.abs(e.game_time - currentTime) < 5
                    );
                }
                
                eventsToShow.slice(0, 100).forEach((event, idx) => {
                    const item = document.createElement('div');
                    let className = 'event-item';
                    const isSelected = this.selectedEvent && this.selectedEvent.tick === event.tick;
                    
                    if (event.event_type_lower.includes('kill') || event.event_type_lower.includes('died')) {
                        className += ' kill';
                    } else if (event.event_type_lower.includes('attack')) {
                        className += ' attack';
                    } else if (event.event_type_lower.includes('hit')) {
                        className += ' hit';
                    }
                    
                    if (isSelected) {
                        className += ' selected';
                    }
                    
                    item.className = className;
                    
                    // HTMLë¡œ ìƒ‰ìƒ êµ¬ë¶„í•˜ì—¬ í‘œì‹œ
                    const time = this.formatTime(event.game_time);
                    let html = `<span class="event-time">${time}</span> `;
                    
                    if (event.event_type_lower.includes('kill') || event.event_type_lower.includes('died')) {
                        if (event.attacker.name && event.victim.name) {
                            html += `<span class="event-action">killed</span> `;
                            html += `<span class="event-victim">${event.victim.name}</span>`;
                            if (event.weapon) {
                                html += ` <span class="event-weapon">with ${event.weapon}</span>`;
                            }
                            html = `<span class="event-player">${event.attacker.name}</span> ` + html;
                        } else {
                            html += `<span class="event-action">${event.event_type}</span>`;
                        }
                    } else if (event.event_type_lower.includes('attack')) {
                        html += `<span class="event-player">${event.attacker.name || 'Unknown'}</span> `;
                        html += `<span class="event-action">initiated an Attack</span>`;
                        if (event.weapon) {
                            html += ` <span class="event-action">with weapon</span> <span class="event-weapon">${event.weapon}</span>`;
                        }
                    } else {
                        html += `<span class="event-action">${event.event_type}</span>`;
                    }
                    
                    item.innerHTML = html;
                    
                    // í´ë¦­ ì´ë²¤íŠ¸ ì¶”ê°€
                    item.addEventListener('click', () => {
                        this.selectEvent(event);
                    });
                    
                    eventLog.appendChild(item);
                });
                
                // ìŠ¤í¬ë¡¤ì„ ë§¨ ìœ„ë¡œ
                eventLog.scrollTop = 0;
            }

            selectEvent(event) {
                // ê¸°ì¡´ ì„ íƒ í•´ì œ
                if (this.selectedEvent) {
                    document.querySelectorAll('.event-item.selected').forEach(item => {
                        item.classList.remove('selected');
                    });
                }
                
                this.selectedEvent = event;
                
                // í¬ì»¤ìŠ¤ ëª¨ë“œ í™œì„±í™” (ì´ë²¤íŠ¸ ì „í›„ 30í‹±)
                this.focusMode = true;
                const centerIdx = this.findTickByTime(event.game_time);
                const startIdx = Math.max(0, centerIdx - 30);
                const endIdx = Math.min(this.data.positions.length - 1, centerIdx + 30);
                this.focusTickRange = { startIdx, endIdx, centerIdx };
                this.focusTimeRange = {
                    start: this.data.positions[startIdx].game_time,
                    end: this.data.positions[endIdx].game_time
                };
                
                // í•´ë‹¹ ì‹œê°„ìœ¼ë¡œ ì´ë™
                const targetTick = this.findTickByTime(event.game_time);
                if (targetTick !== -1) {
                    this.currentTick = targetTick;
                    this.renderTick(this.currentTick);
                    this.updateTimeDisplay();
                }
                
                // ê³µê²©ìë¥¼ ì‹œë®¬ë ˆì´ì…˜ ì¤‘ì•™ì— ë°°ì¹˜
                if (event.attacker.position[0] !== null && this.mapBounds) {
                    const attackerPos = {
                        x: event.attacker.position[0],
                        y: event.attacker.position[2],
                        z: event.attacker.position[1]
                    };
                    
                    // ì¹´ë©”ë¼ë¥¼ ê³µê²©ì ìœ„ì¹˜ë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ì¡°ì •
                    const bounds = this.mapBounds;
                    const maxDim = Math.max(bounds.width, bounds.height, bounds.depth);
                    this.cameraDistance = maxDim * 0.8;
                    
                    // ê³µê²©ì ìœ„ì¹˜ë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ì¹´ë©”ë¼ ë°°ì¹˜
                    this.cameraRotationX = 0.4;
                    this.cameraRotationY = Math.PI / 4; // 45ë„ ê°ë„
                    
                    // ì¹´ë©”ë¼ íƒ€ê²Ÿì„ ê³µê²©ì ìœ„ì¹˜ë¡œ ì„¤ì •
                    this.cameraTarget = attackerPos;
                    
                    // ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸
                    this.updateCameraToTarget();
                }
                
                // ì´ë²¤íŠ¸ ë¡œê·¸ ì—…ë°ì´íŠ¸
                this.updateEventLog();
                
                // í¬ì»¤ìŠ¤ ëª¨ë“œ í‘œì‹œ
                this.showFocusModeIndicator();
                // Aim Trace íƒ­ì´ ì—´ë ¤ìˆë‹¤ë©´ ê°±ì‹ 
                const activeTabEl = document.querySelector('.tab-btn.active');
                const activeTab = activeTabEl ? activeTabEl.getAttribute('data-tab') : null;
                if (activeTab === 'aim') this.renderAimTrace();
            }
            
            updateCameraToTarget() {
                if (!this.cameraTarget || !this.mapBounds) return;
                
                const target = this.cameraTarget;
                const x = target.x + this.cameraDistance * Math.sin(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                const y = target.y + this.cameraDistance * Math.sin(this.cameraRotationX);
                const z = target.z + this.cameraDistance * Math.cos(this.cameraRotationY) * Math.cos(this.cameraRotationX);
                
                // íŒ¨ë‹ ì˜¤í”„ì…‹ ì ìš©
                this.camera.position.set(
                    x + (this.panOffset ? this.panOffset.x : 0),
                    y + (this.panOffset ? this.panOffset.y : 0),
                    z + (this.panOffset ? this.panOffset.z : 0)
                );
                this.camera.lookAt(
                    target.x + (this.panOffset ? this.panOffset.x : 0),
                    target.y + (this.panOffset ? this.panOffset.y : 0),
                    target.z + (this.panOffset ? this.panOffset.z : 0)
                );
            }

            findTickByTime(targetTime) {
                if (!this.data) return -1;
                
                let closestTick = 0;
                let minDiff = Infinity;
                
                this.data.positions.forEach((pos, idx) => {
                    const diff = Math.abs(pos.game_time - targetTime);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestTick = idx;
                    }
                });
                
                return closestTick;
            }

            showFocusModeIndicator() {
                // í¬ì»¤ìŠ¤ ëª¨ë“œ ì¸ë””ì¼€ì´í„° í‘œì‹œ
                const focusControls = document.getElementById('focus-controls');
                const timeDisplay = document.getElementById('time-display');
                
                if (this.focusMode && this.focusTimeRange) {
                    focusControls.classList.add('show');
                    const range = this.focusTimeRange.end - this.focusTimeRange.start;
                    const info = document.getElementById('focus-info');
                    info.textContent = `Focus: ${this.formatTime(this.focusTimeRange.start)} - ${this.formatTime(this.focusTimeRange.end)} (${this.formatTime(range)})`;
                    timeDisplay.style.color = '#4a90e2';
                    timeDisplay.style.fontWeight = 'bold';
                } else {
                    focusControls.classList.remove('show');
                    timeDisplay.style.color = '';
                    timeDisplay.style.fontWeight = '';
                }
            }

            exitFocusMode() {
                this.focusMode = false;
                this.focusTimeRange = null;
                this.selectedEvent = null;
                this.cameraTarget = null; // íƒ€ê²Ÿ í•´ì œ
                this.updateCamera();
                this.showFocusModeIndicator();
                this.updateEventLog();
            }

            renderTick(tickIndex) {
                if (!this.data || !this.data.positions) return;

                const tickData = this.data.positions[tickIndex];
                if (!tickData) return;

                // ê¸°ì¡´ ì˜¤ë¸Œì íŠ¸ ì œê±°
                this.playerObjects.forEach(obj => this.scene.remove(obj));
                this.playerLabels.forEach(obj => this.scene.remove(obj));
                this.playerObjects.clear();
                this.playerLabels.clear();

                // í”Œë ˆì´ì–´ ë Œë”ë§
                tickData.players.forEach(player => {
                    const isCT = player.team === 'CT';
                    const color = isCT ? 0x5b9bd5 : 0xff6b6b;
                    
                    // CTëŠ” ì›í˜•, TëŠ” ì‚¼ê°í˜•
                    let geometry;
                    if (isCT) {
                        geometry = new THREE.SphereGeometry(12, 16, 16);
                    } else {
                        geometry = new THREE.ConeGeometry(12, 24, 3);
                        geometry.rotateX(-Math.PI / 2);
                    }
                    
                    const material = new THREE.MeshPhongMaterial({ 
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.4
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(player.position[0], player.position[2], player.position[1]);
                    this.scene.add(mesh);
                    this.playerObjects.set(player.name, mesh);

                    // í”Œë ˆì´ì–´ ID ë¼ë²¨ (í¬ê²Œ)
                    // í˜„ì¬ í‹±ì— í‚¬ ì´ë²¤íŠ¸ê°€ ìˆê³  ì´ í”Œë ˆì´ì–´ê°€ ê³µê²©ìì¸ì§€ í™•ì¸
                    let isAttacker = false;
                    if (this.data && this.data.events) {
                        const currentTime = tickData.game_time;
                        const activeEvent = this.data.events.find(e => 
                            Math.abs(e.game_time - currentTime) < 0.05 && 
                            e.attacker && 
                            e.attacker.name === player.name
                        );
                        isAttacker = !!activeEvent;
                    }
                    
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 512;
                    canvas.height = 96;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // ë°°ê²½ í…Œë‘ë¦¬
                    ctx.strokeStyle = isCT ? '#5b9bd5' : '#ff6b6b';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 36px Arial';
                    ctx.textAlign = 'center';
                    // ê³µê²©ìì¸ ê²½ìš° ì´ë¦„ ì˜†ì— (attacker) ì¶”ê°€
                    const displayText = isAttacker ? `${player.name} (attacker)` : player.name;
                    ctx.fillText(displayText, canvas.width / 2, canvas.height / 2 + 12);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                        map: texture,
                        transparent: true,
                        depthTest: false
                    }));
                    sprite.position.set(player.position[0], player.position[2] + 35, player.position[1]);
                    sprite.scale.set(150, 30, 1);
                    this.scene.add(sprite);
                    this.playerLabels.set(player.name, sprite);
                    
                    // íŠ¸ë ˆì¼ ì—…ë°ì´íŠ¸
                    this.updateTrail(player.name, player.position, color);
                });

                this.renderEvents(tickData.game_time);
                this.updateEventLog();
            }

            updateTrail(playerName, position, color) {
                if (!this.playerTrails.has(playerName)) {
                    const trailGeometry = new THREE.BufferGeometry();
                    const trailMaterial = new THREE.LineBasicMaterial({ 
                        color: color,
                        opacity: 0.4,
                        transparent: true,
                        linewidth: 2
                    });
                    const trail = new THREE.Line(trailGeometry, trailMaterial);
                    this.scene.add(trail);
                    this.playerTrails.set(playerName, {
                        line: trail,
                        points: []
                    });
                }

                const trail = this.playerTrails.get(playerName);
                trail.points.push(new THREE.Vector3(position[0], position[2], position[1]));
                
                if (trail.points.length > 100) {
                    trail.points.shift();
                }

                trail.line.geometry.setFromPoints(trail.points);
            }

            renderEvents(gameTime) {
                this.eventMarkers.forEach(m => this.scene.remove(m));
                this.eventMarkers = [];

                if (!this.data || !this.data.events) return;

                this.data.events.forEach(event => {
                    const timeDiff = Math.abs(event.game_time - gameTime);
                    // ì •í™•íˆ í•´ë‹¹ í‹±ì—ë§Œ í‘œì‹œ (0.05ì´ˆ ì´ë‚´, ì•½ 3í‹±)
                    // í¬ì»¤ìŠ¤ ëª¨ë“œì¼ ë•ŒëŠ” ì„ íƒëœ ì´ë²¤íŠ¸ë§Œ í‘œì‹œ
                    if (this.focusMode && this.selectedEvent) {
                        // í¬ì»¤ìŠ¤ ëª¨ë“œ: ì„ íƒëœ ì´ë²¤íŠ¸ì™€ ì¼ì¹˜í•˜ëŠ” ê²½ìš°ë§Œ í‘œì‹œ
                        if (event.tick !== this.selectedEvent.tick || 
                            !event.attacker || !this.selectedEvent.attacker ||
                            event.attacker.name !== this.selectedEvent.attacker.name ||
                            !event.victim || !this.selectedEvent.victim ||
                            event.victim.name !== this.selectedEvent.victim.name) {
                            return; // ì„ íƒëœ ì´ë²¤íŠ¸ê°€ ì•„ë‹ˆë©´ ìŠ¤í‚µ
                        }
                    }
                    
                    if (timeDiff < 0.05 && event.attacker.position[0] !== null) {
                        const geometry = new THREE.ConeGeometry(15, 50, 8);
                        const material = new THREE.MeshPhongMaterial({ 
                            color: 0xff0000,
                            emissive: 0xff0000,
                            emissiveIntensity: 0.6
                        });
                        const marker = new THREE.Mesh(geometry, material);
                        marker.position.set(
                            event.attacker.position[0],
                            event.attacker.position[2] + 25,
                            event.attacker.position[1]
                        );
                        marker.rotation.x = -Math.PI / 2;
                        this.scene.add(marker);
                        this.eventMarkers.push(marker);

                        if (event.victim.position[0] !== null) {
                            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(
                                    event.attacker.position[0],
                                    event.attacker.position[2],
                                    event.attacker.position[1]
                                ),
                                new THREE.Vector3(
                                    event.victim.position[0],
                                    event.victim.position[2],
                                    event.victim.position[1]
                                )
                            ]);
                            const lineMaterial = new THREE.LineBasicMaterial({ 
                                color: 0xff6b6b,
                                opacity: 0.8,
                                transparent: true,
                                linewidth: 2
                            });
                            const line = new THREE.Line(lineGeometry, lineMaterial);
                            this.scene.add(line);
                            this.eventMarkers.push(line);

                            // Victim 'KILLED' label with HEADSHOT and fadeout
                            // ì •í™•íˆ í•´ë‹¹ í‹±ì—ë§Œ í‘œì‹œí•˜ê³  2ì´ˆê°„ í˜ì´ë“œì•„ì›ƒ
                            if (timeDiff < 2.0) {
                                const fadeStart = 1.5; // 1.5ì´ˆ í›„ë¶€í„° í˜ì´ë“œ ì‹œì‘
                                const fadeEnd = 2.0; // 2ì´ˆì— ì™„ì „íˆ ì‚¬ë¼ì§
                                let opacity = 1.0;
                                
                                if (timeDiff > fadeStart) {
                                    opacity = 1.0 - ((timeDiff - fadeStart) / (fadeEnd - fadeStart));
                                    opacity = Math.max(0, opacity);
                                }
                                
                                if (opacity > 0) {
                                    const canvas = document.createElement('canvas');
                                    const ctx = canvas.getContext('2d');
                                    // ë¬´ê¸° ì •ë³´ë¥¼ í¬í•¨í•œ í¬ê¸°ë¡œ ì„¤ì •
                                    canvas.width = 300;
                                    canvas.height = 100;
                                    
                                    // ë°°ê²½ (íˆ¬ëª…ë„ ì ìš©)
                                    ctx.fillStyle = `rgba(0, 0, 0, ${0.85 * opacity})`;
                                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                                    
                                    // í…Œë‘ë¦¬
                                    ctx.strokeStyle = `rgba(255, 107, 107, ${opacity})`;
                                    ctx.lineWidth = 3;
                                    ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
                                    
                                    let yPos = 28;
                                    
                                    // KILLED í…ìŠ¤íŠ¸
                                    ctx.fillStyle = `rgba(255, 107, 107, ${opacity})`;
                                    ctx.font = 'bold 26px Arial';
                                    ctx.textAlign = 'center';
                                    ctx.fillText('KILLED', canvas.width / 2, yPos);
                                    
                                    // HEADSHOT í‘œì‹œ (í—¤ë“œìƒ·ì¸ ê²½ìš°)
                                    if (event.headshot) {
                                        yPos += 22;
                                        ctx.fillStyle = `rgba(255, 215, 0, ${opacity})`;
                                        ctx.font = 'bold 16px Arial';
                                        ctx.fillText('HEADSHOT', canvas.width / 2, yPos);
                                    }
                                    
                                    // ë¬´ê¸° ì •ë³´ í‘œì‹œ
                                    if (event.weapon) {
                                        yPos += 20;
                                        ctx.fillStyle = `rgba(255, 165, 0, ${opacity})`;
                                        ctx.font = '14px Arial';
                                        ctx.fillText(event.weapon, canvas.width / 2, yPos);
                                    }
                                    
                                    // victim í…ìŠ¤íŠ¸
                                    yPos += 18;
                                    ctx.fillStyle = `rgba(255, 107, 107, ${opacity})`;
                                    ctx.font = '12px Arial';
                                    ctx.fillText('victim', canvas.width / 2, yPos);
                                    
                                    const tex = new THREE.CanvasTexture(canvas);
                                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                                        map: tex, 
                                        transparent: true,
                                        opacity: opacity,
                                        depthTest: false // í•­ìƒ ì•ì— í‘œì‹œ
                                    }));
                                    sprite.position.set(
                                        event.victim.position[0],
                                        event.victim.position[2] + 70, // ë” ìœ„ë¡œ ì˜¬ë¦¼
                                        event.victim.position[1]
                                    );
                                    sprite.scale.set(150, 50, 1); // í¬ê¸° ì¡°ì • (ë¬´ê¸° ì •ë³´ ì¶”ê°€ë¡œ ë†’ì´ ì¦ê°€)
                                    this.scene.add(sprite);
                                    this.eventMarkers.push(sprite);
                                }
                            }
                        }
                    }
                });
            }

            togglePlay() {
                this.isPlaying = !this.isPlaying;
                document.getElementById('play-btn').textContent = this.isPlaying ? 'â¸' : 'â–¶';
            }

            seekTo(percent) {
                if (!this.data) return;
                const maxTick = this.data.positions.length - 1;
                this.currentTick = Math.floor(percent * maxTick);
                this.renderTick(this.currentTick);
                this.updateTimeDisplay();
            }

            updateTimeDisplay() {
                if (!this.data) return;
                
                const tickData = this.data.positions[this.currentTick];
                if (tickData) {
                    const m = this.data.metadata;
                    const currentTime = tickData.game_time - m.time_range.min;
                    const totalTime = m.time_range.max - m.time_range.min;
                    
                    document.getElementById('time-display').textContent = 
                        `${this.formatTime(currentTime)} / ${this.formatTime(totalTime)}`;
                    
                    const progress = (this.currentTick / (this.data.positions.length - 1)) * 100;
                    document.getElementById('timeline-progress').style.width = `${progress}%`;
                }
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                const ms = Math.floor((seconds % 1) * 1000);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                if (this.updateCamera) {
                    this.updateCamera();
                }

                if (this.isPlaying && this.data) {
                    const now = Date.now();
                    if (!this.lastUpdateTime) {
                        this.lastUpdateTime = now;
                    }
                    
                    // í‹± ê°„ ì‹œê°„ ê³„ì‚° (ì‹¤ì œ ê²Œì„ í‹± ì†ë„ ê¸°ë°˜)
                    const tickData = this.data.positions[this.currentTick];
                    const nextTickData = this.data.positions[this.currentTick + 1];
                    
                    let shouldAdvance = false;
                    let delta = now - this.lastUpdateTime;
                    
                    if (tickData && nextTickData) {
                        const tickInterval = (nextTickData.game_time - tickData.game_time) * 1000; // ms
                        if (tickInterval > 0 && !Number.isNaN(tickInterval)) {
                            // playSpeed ì ìš©: 1xë©´ ì›ë˜ ì†ë„, 0.5xë©´ 2ë°° ëŠë¦¬ê²Œ, 2xë©´ 2ë°° ë¹ ë¥´ê²Œ
                            const targetInterval = tickInterval / this.playSpeed;
                            
                            // playSpeedì— ë”°ë¼ í‹± ì§„í–‰ ì†ë„ ì¡°ì ˆ
                            shouldAdvance = delta >= targetInterval;
                            
                            // ë¹ ë¥¸ ì†ë„ì¼ ë•Œ ì—¬ëŸ¬ í‹±ì„ í•œ ë²ˆì— ê±´ë„ˆë›°ê¸°
                            if (shouldAdvance && this.playSpeed > 1) {
                                const ticksToSkip = Math.floor(delta / targetInterval);
                                if (ticksToSkip > 1) {
                                    // ì—¬ëŸ¬ í‹± ê±´ë„ˆë›°ê¸° (ìµœëŒ€ 10í‹±)
                                    const skipCount = Math.min(ticksToSkip - 1, 10);
                                    this.currentTick += skipCount;
                                    shouldAdvance = false; // ì´ë¯¸ ì¦ê°€í–ˆìœ¼ë¯€ë¡œ ì¶”ê°€ ì¦ê°€ ë°©ì§€
                                }
                            }
                            
                            // ë””ë²„ê¹… (ê°€ë”ë§Œ ì¶œë ¥)
                            if (this.currentTick % 100 === 0) {
                                console.log('ì¬ìƒ ì†ë„:', this.playSpeed + 'x', 'í‹± ê°„ê²©:', tickInterval.toFixed(2) + 'ms', 'ëª©í‘œ ê°„ê²©:', targetInterval.toFixed(2) + 'ms', 'ì‹¤ì œ delta:', delta.toFixed(2) + 'ms');
                            }
                        } else {
                            // í‹± ê°„ê²©ì´ ì—†ê±°ë‚˜ ì˜ëª»ëœ ê²½ìš° ê¸°ë³¸ ê°„ê²© ì‚¬ìš©
                            const baseInterval = 16.67 / this.playSpeed; // ê¸°ë³¸ 60fps ê¸°ì¤€ (16.67ms)
                            shouldAdvance = delta >= baseInterval;
                        }
                    } else {
                        // ë‹¤ìŒ í‹± ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ ê°„ê²© ì‚¬ìš©
                        const baseInterval = 16.67 / this.playSpeed; // ê¸°ë³¸ 60fps ê¸°ì¤€ (16.67ms)
                        shouldAdvance = delta >= baseInterval;
                    }
                    
                    if (shouldAdvance) {
                        this.currentTick += 1;
                        
                        // í¬ì»¤ìŠ¤ ëª¨ë“œì¸ ê²½ìš° ë²”ìœ„ ì²´í¬ (í‹± ê¸°ë°˜)
                        if (this.focusMode && this.focusTickRange) {
                            if (this.currentTick > this.focusTickRange.endIdx) {
                                this.currentTick = this.focusTickRange.startIdx;
                                this.isPlaying = false;
                                document.getElementById('play-btn').textContent = 'â–¶';
                            }
                        }
                        
                        if (this.currentTick >= this.data.positions.length) {
                            this.currentTick = this.data.positions.length - 1;
                            this.isPlaying = false;
                            document.getElementById('play-btn').textContent = 'â–¶';
                        } else {
                            // Follow selected player if enabled
                            if (this.followPlayer && this.selectedPlayer && this.playerIndex.has(this.selectedPlayer)) {
                                const arr = this.playerIndex.get(this.selectedPlayer);
                                const tick = this.data.positions[this.currentTick].tick;
                                const entry = arr.find(e => e.tick === tick);
                                if (entry) {
                                    this.cameraTarget = { x: entry.position[0], y: entry.position[2], z: entry.position[1] };
                                }
                            }
                            this.renderTick(this.currentTick);
                            this.updateTimeDisplay();
                            // Aim trace ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ (íƒ­ì´ ì—´ë ¤ìˆì„ ë•Œ)
                            const activeTabEl3 = document.querySelector('.tab-btn.active');
                            const activeTab3 = activeTabEl3 ? activeTabEl3.getAttribute('data-tab') : null;
                            if (activeTab3 === 'aim') this.renderAimTrace();
                        }
                        this.lastUpdateTime = now;
                    }
                }

                this.renderer.render(this.scene, this.camera);
            }
        }

        // ì¦‰ì‹œ ì‹¤í–‰í•˜ì—¬ ì´ˆê¸°í™” ë³´ì¥
        (function() {
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
                    new CombatSimulation();
                });
            } else {
                // DOMì´ ì´ë¯¸ ë¡œë“œëœ ê²½ìš° ì¦‰ì‹œ ì‹¤í–‰
                new CombatSimulation();
            }
        })();
    </script>
</body>
</html>

